<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/logo.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          Redis - 宋正兵的博客 | zbsong Blog
        
    </title>

    <link rel="canonical" href="zbsong.top/article/Redis学习/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('https://api.dujin.org/bing/1920.php')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#java" title="java">java</a>
                            
                        </div>
                        <h1>Redis</h1>
                        <!-- <h2 class="subheading">Redis相关知识</h2> -->
                        <span class="meta">
                            宋正兵 on
                            2021-06-22
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">songzblink</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">主页</a>
                    </li>
					<li>
                        <a href="/archive/">归档</a>
                    </li>
					<li>
                        <a href="/tags/">标签</a>
                    </li>
					<li>
                        <a href="/about/">关于</a>
                    </li>
					<!--
					修改about在前面的问题
                    
                        
                    
                        
                        <li>
                            <a href="/about/">关于</a>
                        </li>
                        
                    
                        
                        <li>
                            <a href="/archive/">归档</a>
                        </li>
                        
                    
                        
                        <li>
                            <a href="/tags/">标签</a>
                        </li>
                        
                    
                    -->
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
	// querySelector 获取文档中 id="demo" 的元素
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				
                <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis （远程字典服务器）是一种数据库，能够存储数据、管理数据的一种软件。它是一个用 C 语言编写的、开源的、基于内存运行并支持持久化的、高性能的 NoSQL 数据库。</p>
<h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p>分布式缓存主要解决的是单机缓存的容量受服务器限制并且无法保存通用的信息。因为本地缓存只在当前服务里有效，如果部署了两个相同的服务，两者之间的缓存数据是无法互通的。</p>
<p>常见的分布式缓存技术选型方案有 Memcached 和 Redis。</p>
<h3 id="redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h3><ul>
<li>基于内存的数据库，一般用来当作缓存使用，性能高</li>
<li>有过期策略</li>
<li>支持更丰富的数据类型，除了 k/v 类型，还支持 list、set、hash 等数据结构的存储</li>
<li>支持数据持久化</li>
<li>支持灾难恢复机制</li>
</ul>
<h3 id="为什么要用-redis为什么要用缓存"><a href="#为什么要用-Redis（为什么要用缓存）" class="headerlink" title="为什么要用 Redis（为什么要用缓存）"></a>为什么要用 Redis（为什么要用缓存）</h3><p>简单讲，使用缓存主要是为了提升用户体验以应对更多的用户。从“高性能”和“高并发”两个角度看待这个问题。</p>
<p><strong>高性能</strong></p>
<p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢的，因为是从硬盘中读取数据的。但是如果用户访问的数据属于高频数据并且不会经常改变的话，那么我们可以很放心地将该数据存在缓存中。这样做的好处是，保证用户下次再访问这些数据的时候就可以直接从缓存中获取，操作缓存就是直接操作内存，所以速度会很快。</p>
<p><strong>高并发</strong></p>
<p>一般来讲，使用 Redis 缓存之后的 QPS 能够达到 MySQL 数据库的10倍以上。所以直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，如果把数据库中的部分数据转移到缓存中，这样用户的一部分请求会直接到缓存而不请求数据库，这样就提高了系统整体的并发度。</p>
<blockquote>
<p>QPS（Query Per Second）：服务器每秒可以执行的查询次数。</p>
</blockquote>
<h2 id="redis常见数据结构以及使用场景分析"><a href="#Redis常见数据结构以及使用场景分析" class="headerlink" title="Redis常见数据结构以及使用场景分析"></a>Redis常见数据结构以及使用场景分析</h2><p>Redis 官网提供的<a href="https://try.redis.io/" target="_blank" rel="noopener">在线 redis 环境 Try Redis</a></p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>string 数据结构是简单的 key-value 类型。可以保存<strong>文本数据</strong>或者是<strong>二进制数据</strong>，并且获取字符串长度复杂度为 $O(1)$。</p>
<p><strong>命令：</strong> <code>set、get、strlen、exists、dect、incr、setex</code> 等等</p>
<p><strong>应用场景：</strong> 一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</p>
<p><strong>普通字符串的基本操作</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> key value <span class="comment"># 设置 key-value 类型的值</span></span><br><span class="line">OK</span><br><span class="line">&gt; get key <span class="comment"># 根据 key 获得对应的 value</span></span><br><span class="line"><span class="string">"value"</span></span><br><span class="line">&gt; exists key  <span class="comment"># 判断某个 key 是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; strlen key <span class="comment"># 返回 key 所储存的字符串值的长度。</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">&gt; del key <span class="comment"># 删除某个 key 对应的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; get key</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<p><strong>批量设置</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> mset k1 v1 k2 v2 <span class="comment"># 批量设置 key-value 类型的值</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mget k1 k2 <span class="comment"># 批量获取多个 key 对应的 value</span></span></span><br><span class="line">1) "value1"</span><br><span class="line">2) "value2"</span><br></pre></td></tr></table></figure>
<p><strong>计数器（字符串的内容为整数的时候可以使用）</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> num 1</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> incr num <span class="comment"># 将 key 中储存的数字值增一</span></span></span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get num</span></span><br><span class="line">"2"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> decr num <span class="comment"># 将 key 中储存的数字值减一</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get num</span></span><br><span class="line">"1"</span><br></pre></td></tr></table></figure>
<p><strong>过期设置</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> expire key 60 <span class="comment"># 数据在 60s 后过期</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> setex key 60 value <span class="comment"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ttl key <span class="comment"># 查看数据还有多久过期</span></span></span><br><span class="line">(integer) 56</span><br></pre></td></tr></table></figure>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list 即是链表。Redis 的 list 的实现为一个双向链表。</p>
<p><strong>命令：</strong> <code>rpush、lpop、lpush、rpop、rpush、llen</code> 等</p>
<p><strong>应用场景：</strong> 发布与订阅或者说消息队列、慢查询</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/redis-list.png" alt=""></p>
<p><strong>通过 <code>rpush/lopo</code> 实现队列</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> rpush myList value1 <span class="comment"># 向 list 的头部（右边）添加元素</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> rpush myList value2 value3 <span class="comment"># 向list的头部（最右边）添加多个元素</span></span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> lpop myList <span class="comment"># 将 list的尾部(最左边)元素取出</span></span></span><br><span class="line">"value1"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> lrange myList 0 1 <span class="comment"># 查看对应下标的list列表， 0 为 start,1为 end</span></span></span><br><span class="line">1) "value2"</span><br><span class="line">2) "value3"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> lrange myList 0 -1 <span class="comment"># 查看列表中的所有元素，-1表示倒数第一</span></span></span><br><span class="line">1) "value2"</span><br><span class="line">2) "value3"</span><br></pre></td></tr></table></figure>
<p><strong>通过 <code>rpush/rpop</code> 实现栈</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> rpush myList2 value1 value2 value3</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> rpop myList2 <span class="comment"># 将 list的头部(最右边)元素取出</span></span></span><br><span class="line">"value3"</span><br></pre></td></tr></table></figure>
<p><strong>通过 <code>lrange</code> 查看对应下标范围的列表元素</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> rpush myList value1 value2 value3</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> lrange myList 0 1 <span class="comment"># 查看对应下标的list列表， 0 为 start,1为 end</span></span></span><br><span class="line">1) "value1"</span><br><span class="line">2) "value2"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> lrange myList 0 -1 <span class="comment"># 查看列表中的所有元素，-1表示倒数第一</span></span></span><br><span class="line">1) "value1"</span><br><span class="line">2) "value2"</span><br><span class="line">3) "value3"</span><br></pre></td></tr></table></figure>
<p>通过 <code>lrange</code> 命令，可以基于 list 实现分页查询，性能非常高！</p>
<p><strong>通过 <code>llen</code> 查看链表长度</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> llen myList</span></span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>hash 类似于 JDK 1.8 以前的 HashMap，内部实现也差不多（数组+链表）。hash 是一个 string 类型的变量和 value 的映射表，特别适合用于存储对象，后续操作的时候可以直接仅仅修改这个对象中的某个字段的值。比如可以用 hash 数据结构来存储用户信息、商品信息等等。</p>
<p><strong>常用命令：</strong> <code>hset、hmset、hexists、hget、hgetall、hkeys、hvals</code> 等</p>
<p><strong>应用场景：</strong> 系统中对象数据的存储</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> hmset userInfoKey name <span class="string">"zbsong"</span> description <span class="string">"dev"</span> age <span class="string">"24"</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hexists userInfoKey name <span class="comment"># 查看 key 对应的 value中指定的字段是否存在。</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hget userInfoKey name <span class="comment"># 获取存储在哈希表中指定字段的值。</span></span></span><br><span class="line">"zbsong"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hget userInfoKey age</span></span><br><span class="line">"24"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hgetall userInfoKey <span class="comment"># 获取在哈希表中指定 key 的所有字段和值</span></span></span><br><span class="line">1) "name"</span><br><span class="line">2) "zbsong"</span><br><span class="line">3) "description"</span><br><span class="line">4) "dev"</span><br><span class="line">5) "age"</span><br><span class="line">6) "24"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hkeys userInfoKey <span class="comment"># 获取 key 列表</span></span></span><br><span class="line">1) "name"</span><br><span class="line">2) "description"</span><br><span class="line">3) "age"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hvals userInfoKey <span class="comment"># 获取 value 列表</span></span></span><br><span class="line">1) "zbsong"</span><br><span class="line">2) "dev"</span><br><span class="line">3) "24"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hset userInfoKey name <span class="string">"zbsongGieGie"</span> <span class="comment"># 修改某个字段对应的值</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hget userInfoKey name</span></span><br><span class="line">"zbsongGieGie"</span><br></pre></td></tr></table></figure>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set 类似于 Java 中的 HashSet。set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 锁不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合中。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p>
<p><strong>常用命令：</strong> <code>sadd、spop、smembers、sismember、scard、sinterstore、sunion</code> 等</p>
<p><strong>应用场景：</strong> 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> sadd mySet value1 value2 <span class="comment"># 添加元素进去</span></span></span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sadd mySet value1 <span class="comment"># 不允许有重复元素</span></span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> smembers mySet <span class="comment"># 查看 set 中所有的元素</span></span></span><br><span class="line">1) "value1"</span><br><span class="line">2) "value2"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> scard mySet <span class="comment"># 查看 set 的长度</span></span></span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sismember mySet value1 <span class="comment"># 检查某个元素是否存在set 中，只能接收单个元素</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sadd mySet2 value2 value3</span></span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sinterstore mySet3 mySet mySet2 <span class="comment"># 获取 mySet 和 mySet2 的交集并存放在 mySet3 中</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> smembers mySet3</span></span><br><span class="line">1) "value2"</span><br></pre></td></tr></table></figure>
<h3 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h3><p>和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。</p>
<p><strong>常用命令：</strong> <code>zadd、zcard、zscore、zrange、zrevrange、zrem</code> 等</p>
<p><strong>应用场景：</strong> 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> zadd myZset 3.0 value1 <span class="comment"># 添加元素到 sorted set 中 3.0 为权重</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zadd myZset 2.0 value2 1.0 value3 <span class="comment"># 一次添加多个元素</span></span></span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zcard myZset <span class="comment"># 查看 sorted set 中的元素数量</span></span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zscore myZset value1 <span class="comment"># 查看某个 value 的权重</span></span></span><br><span class="line">"3"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zrange  myZset 0 -1 <span class="comment"># 顺序输出某个范围区间的元素，0 -1 表示输出所有元素</span></span></span><br><span class="line">1) "value3"</span><br><span class="line">2) "value2"</span><br><span class="line">3) "value1"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zrange  myZset 0 1 <span class="comment"># 顺序输出某个范围区间的元素，0 为 start  1 为 stop</span></span></span><br><span class="line">1) "value3"</span><br><span class="line">2) "value2"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zrevrange  myZset 0 1 <span class="comment"># 逆序输出某个范围区间的元素，0 为 start  1 为 stop</span></span></span><br><span class="line">1) "value1"</span><br><span class="line">2) "value2"</span><br></pre></td></tr></table></figure>
<h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><p>bitmap 存储的是连续的二进制数字（0 和 1），通过 bitmap，只需要一个 bit 位来表示某个元素对应的值或状态，key 就是对应元素本身。我们知道 8 个 bit 可以组成一个 byte，所以 bitmap 本身会极大的节省存储空间。</p>
<p><strong>常用命令：</strong> <code>setbit、getbit、bitcount、bitop</code></p>
<p><strong>应用场景：</strong> 适合需要保存状态信息（比如是否签到、是否登录）并需要进一步对这些信息进行分析的场景。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> setbit 会返回之前位的值（默认是 0）这里会把第 7 位设置为 1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> setbit mykey 7 1</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> setbit mykey 7 0</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> getbit mykey 7</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> setbit mykey 6 1</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> setbit mykey 8 1</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 bitcount 统计被被设置为 1 的位的数量。</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> bitcount mykey</span></span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>
<p>针对上述提到的一些场景，进一步地进行说明。</p>
<p><strong>场景一：用户行为分析</strong> 分析用户的喜好，需要研究你点赞过的内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 记录你喜欢过 001 号小姐姐【uid=001】</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> setbit beauty_girl uid 1</span></span><br></pre></td></tr></table></figure>
<p><strong>场景二：统计活跃用户</strong></p>
<p>使用时间作为 key，然后用户 id 为 offset，如果当日活跃过就设置为 1。</p>
<p>如果想计算某几天/月/年的活跃用户，可以使用 <code>bitop</code> 命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> bitop 命令支持 and、or、not、xor 这四种操作中的任意一种参数</span></span><br><span class="line">bitop operation destkey key [key ...]</span><br></pre></td></tr></table></figure>
<p>初始化数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; setbit 20210308 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">&gt; setbit 20210308 2 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">&gt; setbit 20210309 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
<p>统计 20210308~20210309 总活跃用户数：1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; bitop and desk1 20210308 20210309</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; bitcount desk1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<p>统计 20210308~20210309 在线活跃用户数: 2</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; bitop or desk2 20210308 20210309</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; bitcount desk2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>
<p><strong>场景三：用户在线状态</strong></p>
<p>对于获取或者统计用户在线状态，使用 bitmap 是一个节约空间效率又高的一种方法。</p>
<p>只需要一个 key，然后用户 id 为 offset，如果在线就设置为 1，不在线就设置为 0。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>通过命令 <code>set</code> 和 <code>expire</code> 组合在一起的原子指令 <code>set &lt;key&gt; &lt;value&gt; ex &lt;time&gt; nx</code>  来进行分布式锁的实现。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> lock_key <span class="literal">true</span> ex 5 nx</span></span><br><span class="line">OK</span><br><span class="line">...do something critical...</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> del lock_key</span></span><br></pre></td></tr></table></figure>
<p>保证 <code>setnx</code>（set if not exists）指令和设置超时 <code>expire</code> 指令的原子性。</p>
<p>分布式锁不适合较长时间的任务，因为超出了锁的超时限制后，第二个线程可能会提前持有了锁，导致线程安全问题。</p>
<p>如果要实现可重入的话，可以基于 ThreadLocal 存储当前持有锁的计数来实现。</p>
<h2 id="异步消息队列"><a href="#异步消息队列" class="headerlink" title="异步消息队列"></a>异步消息队列</h2><p>利用阻塞读命令来实现 <code>blpop</code> 和 <code>rlpop</code>。消息从固定的一侧进入 Redis 的 list 中，读的时候通过阻塞读来获取，这样在队列没有数据的时候，会立即进入休眠状态，一旦数据到来又立刻醒过来。</p>
<h2 id="redis持久化机制备份机制"><a href="#Redis持久化机制【备份机制】" class="headerlink" title="Redis持久化机制【备份机制】"></a>Redis持久化机制【备份机制】</h2><h3 id="基于快照的全量备份-rdb"><a href="#基于快照的全量备份-RDB" class="headerlink" title="基于快照的全量备份 RDB"></a>基于快照的全量备份 RDB</h3><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<h4 id="手动备份"><a href="#手动备份" class="headerlink" title="手动备份"></a>手动备份</h4><ul>
<li><code>save</code> 命令：同步阻塞的</li>
<li><code>bgsave</code> 命令：非阻塞的（阻塞实际发生在 fork 的子进程中）</li>
</ul>
<h4 id="自动备份"><a href="#自动备份" class="headerlink" title="自动备份"></a>自动备份</h4><p>在 Redis.conf 配置文件中默认有如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure>
<h4 id="持久化存储实现原理"><a href="#持久化存储实现原理" class="headerlink" title="持久化存储实现原理"></a>持久化存储实现原理</h4><p>Redis 进程 fork 出一个子进程，子进程拥有父进程中的所有数据，父进程在接收客户端请求试图修改某个物理页的时候，会先复制一份页出来，然后再在复制出来的物理页上进行修改。</p>
<h3 id="基于指令日志的增量备份-aof"><a href="#基于指令日志的增量备份-AOF" class="headerlink" title="基于指令日志的增量备份 AOF"></a>基于指令日志的增量备份 AOF</h3><p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF 方式的持久化，可通过 appendonly 参数开启：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名都是 appendonly.aof。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure>
<p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec 选项，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没收到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<h3 id="aof重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>AOF 策略会将每条写入命令都写入到 AOF 文件当中，随着时间的逐步推移，AOF 文件就会变得很臃肿。为了解决这个问题，Redis 提供了 AOF 重写功能。</p>
<p>Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最后服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p>
<h3 id="rdb和aof的比较"><a href="#RDB和AOF的比较" class="headerlink" title="RDB和AOF的比较"></a>RDB和AOF的比较</h3><p><strong>RDB 的优点</strong></p>
<ul>
<li>创建的是数据的快照，全量备份，便于数据的传输（比如把 A 服务器上的备份文件传输到 B 服务器，直接将 RDB 文件拷贝即可）</li>
<li>文件采用压缩的二进制文件，重启服务时加载数据文件更快 </li>
</ul>
<p><strong>RDB 的缺点</strong></p>
<ul>
<li>容易丢失数据，因为全量备份比较耗时，如果在全量备份的过程中宕机，会丢失很多数据。</li>
</ul>
<p><strong>AOF 的优点</strong></p>
<ul>
<li>提供多种文件写入（fsync）策略</li>
<li>数据实时保存，数据完整性强</li>
</ul>
<p><strong>AOF 的缺点</strong></p>
<ul>
<li>随着时间的推移文件体积会很大，加载的速度会很慢</li>
</ul>
<p><strong>如何选择两种机制呢？</strong></p>
<ul>
<li>针对不同的情况来选择，建议使用两种方式相结合</li>
<li>针对数据安全性、完整性要求高的采用 AOF 方式</li>
<li>针对不太重要的数据可以使用 RDB 方式</li>
<li>对于数据进行全量备份，便于数据备份的采用 RDB 方式</li>
</ul>
<p><a href="https://blog.csdn.net/weixin_39765697/article/details/112317012" target="_blank" rel="noopener">redis 备份导出rdb_Redis持久化知识点—RDB+AOF ，你了解多少_weixin_39765697的博客-CSDN博客</a></p>
<h3 id="混合策略"><a href="#混合策略" class="headerlink" title="混合策略"></a>混合策略</h3><p>AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头，在重写过程中执行的写命令以 AOF 持久化的方式追加到 AOF 文件的末尾。这样做的好处是可以结合 RDB 和 AOF 的优点，快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<h2 id="过期的数据的删除策略"><a href="#过期的数据的删除策略" class="headerlink" title="过期的数据的删除策略"></a>过期的数据的删除策略</h2><p>Redis 会把每个设置了过期时间的 key 都放到一个独立的字典里，之后会按照指定的策略来删除到期的 key。</p>
<p><strong>惰性删除：</strong>只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期的 key 没有被删除。</p>
<p><strong>定期删除：</strong> 每隔一段时间抽取一批 key 执行删除过期的 key 的操作。这样对内存最友好，通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</p>
<p>Redis 采用的是 定期删除+惰性删除。默认每秒进行 10 次过期扫描，先从字典里随机挑 20 个 key，删除其中过期的，然后计算字典中过期键的比例，如果比例还是比较大，那就重复步骤。</p>
<p>【主从模式下】从节点不会进行过期扫描，从节点对过期的处理是被动的，主节点在 key 到期后，会在 AOF 文件里增加 del 指令，同步到从节点，从节点执行删除操作。</p>
<h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>定期删除和惰性删除还是可能会漏掉很多过期 key 的情况，所以内存淘汰策略就是用来解决这个问题的。</p>
<p>Redis 提供了 6 种数据淘汰策略：</p>
<ol>
<li>volatile-lru（last recently used）：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰</li>
<li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key</li>
<li>allkeys-random：从数据集中任意选择数据淘汰</li>
<li>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错</li>
</ol>
<h2 id="redis给缓存数据设置过期时间有啥用"><a href="#Redis给缓存数据设置过期时间有啥用？" class="headerlink" title="Redis给缓存数据设置过期时间有啥用？"></a>Redis给缓存数据设置过期时间有啥用？</h2><p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，很容易造成 OOM。所以一般情况下，我们设置保存的缓存数据都会设置一个过期时间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; exp key  60 <span class="comment"># 数据在 60s 后过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; setex key 60 value <span class="comment"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span></span><br><span class="line">OK</span><br><span class="line">&gt; ttl key <span class="comment"># 查看数据还有多久过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 56</span><br></pre></td></tr></table></figure>
<p><strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他类型都需要依靠 <code>expire</code> 命令来设置过期时间。<code>persist</code> 命令可以溢出一个键的过期时间。</strong></p>
<p>比如短信验证码可能只在一分钟内有效，用户登录的 token 可能只在一天内有效，用传统的数据库来处理，一般都是自己判断是否过期，这样做很麻烦并且性能差很多，用 Redis 的话直接设置一个过期时间就搞定了。</p>
<h2 id="redis如何判断数据是否过期"><a href="#Redis如何判断数据是否过期" class="headerlink" title="Redis如何判断数据是否过期"></a>Redis如何判断数据是否过期</h2><p>Redis 通过一个过期字典来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key，过期字典的值是一个 long long 类型的整数，这个整数保存了键所指向的数据库 key 的过期时间（毫秒精度的 UNIX 时间戳）。结构大概是这样的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    dict *dict;     <span class="comment">//数据库键空间,保存着数据库中所有键值对 key-value</span></span><br><span class="line">    dict *expires   <span class="comment">// 过期字典,保存着键的过期时间 key-过期时间</span></span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>
<h2 id="redis单线程模型"><a href="#Redis单线程模型" class="headerlink" title="Redis单线程模型"></a>Redis单线程模型</h2><p>Redis 利用 I/O 多路复用程序（<code>aeMain()</code> 方法干的事），去监听客户端的请求（每个客户端对应一个 socket 文件描述符），每个客户端对应的文件描述符都被添加到了 aeFileEvent 链表当中，该链表中第一个文件描述符是 Redis 启动时添加用于监听客户端新连接用的。</p>
<p>当监听到有客户端数据传来时，具体执行什么函数需要根据客户端文件描述符所绑定的事务处理器来决定。</p>
<p>由于只有一个线程在监听这些描述符，并做处理，所以即使客户端并发地发送命令，服务器仍然是依次取出命令，顺序执行。</p>
<p>这也就是我们常说地，redis 是单线程地，命令与命令之间是顺序执行，无需考虑线程安全地问题。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTZ0QgoG3fhicDPejicOsW7J4no2pgA9cZ6kl63WylR1Y2MHcsCGRXdJvSPr678Ud11QgqLWt0TbaSw/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/redis%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8.png" alt=""></p>
<p>《Redis 设计与实现》中介绍：</p>
<blockquote>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器。文件事件处理器使用 I/O 多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
<p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这是文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>
<p>虽然文件事件处理器以单线程方式运行，但通过 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模式，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p>
</blockquote>
<h3 id="单线程是怎么监听大量的客户端连接呢"><a href="#单线程是怎么监听大量的客户端连接呢？" class="headerlink" title="单线程是怎么监听大量的客户端连接呢？"></a>单线程是怎么监听大量的客户端连接呢？</h3><p>Redis 中的文件事件处理器使用 I/O 多路复用程序来同时监听文件描述符，并根据文件描述符目前绑定的事件处理器来执行相应的任务。</p>
<h3 id="redis-60之后为何引入了多线程"><a href="#Redis-6-0之后为何引入了多线程？" class="headerlink" title="Redis 6.0之后为何引入了多线程？"></a>Redis 6.0之后为何引入了多线程？</h3><p>Redis 6.0 引入多线程主要是为了提高网络 I/O 读写性能，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p>
<p>引入多线程只是在网络数据的读写这类耗时操作上使用，执行命令仍然是单线程顺序执行，因此不需要担心线程安全问题。</p>
<h2 id="redis-启动流程"><a href="#Redis-启动流程" class="headerlink" title="Redis 启动流程"></a>Redis 启动流程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server</span><br></pre></td></tr></table></figure>
<p>命令执行后，shell 程序把 Redis 程序加载到了内存，开始执行 Redis 的 main 方法。主要有三大步：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 初始化创建 TCP 连接，监听客户端新连接</span></span><br><span class="line">   initServer();</span><br><span class="line">    ...</span><br><span class="line">   <span class="comment">// 将创建 TCP 连接返回的文件描述符绑定 accpetHandler() 函数，并加入到 aeFileEvent 链表中</span></span><br><span class="line">   aeCreateFileEvent(fd, acceptHandler, ...);</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// I/O 多路复用，监听客户端的请求</span></span><br><span class="line">   aeMain();</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在 acCreateFileEvent() 函数的作用是把相应的事件处理器绑定到文件描述符上</strong>：</p>
<ul>
<li>acceptHandler：连接应答处理器</li>
<li>readQueryFromClient：命令请求处理器</li>
<li>sendReplyToClient：命令回复处理器</li>
</ul>
<p><strong>第一步，创建 TCP 连接</strong></p>
<p>通过 <code>listenToPort()</code> 方法创建一个 TCP 连接，返回一个文件描述符 fd。</p>
<p><strong>第二步，将文件描述符加入到 aeFileEvent 链表中</strong></p>
<p>通过 <code>acCreateFileEvent()</code> 方法，将上面创建了 TCP 连接返回的文件描述符 fd，加入到一个叫做 aeFileEvent 的链表中。</p>
<p>同时将这个文件描述符绑定一个函数 acceptHandler，这样当有客户端连接进来时，便会执行这个函数。</p>
<blockquote>
<p>其实启动之后就是开启了一个 TCP 监听，然后如果有客户端进来的话，让它执行 acceptHandler 函数。</p>
</blockquote>
<p><strong>第三步，I/O多路复用</strong></p>
<p>通过 <code>aeMain()</code> 方法，将上面的 aeFileEvent 链表中的文件描述符，统统作为 select 的入参，这是 I/O 多路复用模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop)</span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它就是在中间一直循环死等，用 select 的方式监听多个文件描述符。<img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXTZ0QgoG3fhicDPejicOsW7J4bIJA6pUSYZFVBLZXVHrFicsiceM3sC1XiaDQ9vlODibibvBwDtz35VM1Mhw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p>
<h2 id="redis客户端连接服务器的流程"><a href="#Redis客户端连接服务器的流程" class="headerlink" title="Redis客户端连接服务器的流程"></a>Redis客户端连接服务器的流程</h2><p>Redis 启动后，假设有一个 redis-client 连接到了该服务器。那么监听客户端新连接的文件描述符感知到，就会执行 acceptHandler 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    cfd = anetAccept(...);</span><br><span class="line">   ...</span><br><span class="line">    c = createClient(cfd))</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> redisClient *createClient(<span class="keyword">int</span> fd) &#123;</span><br><span class="line">   ...</span><br><span class="line">   aeCreateFileEvent(c-&gt;fd, readQueryFromClient, ...);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，当有新客户端连接进来时，便会调用 createClient 创建一个专属的 client 为其服务。所谓的专属服务，其实仍然是这个 <code>aeCreateFileEvent()</code> 函数。</p>
<p>上面讲了，这个函数的功能就是把文件描述符挂在链表上，然后分配一个处理函数。</p>
<p>此处的处理函数不再是处理新客户端连接的 acceptHandler，而是处理具体客户端传来的 redis 命令的函数 readQueryFromClient。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXTZ0QgoG3fhicDPejicOsW7J4rVx1r4789ZRQh7KvjpCY77hVCs8radhBew5jdVOTL27h0bViaGt12iaA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p>
<p>如果再来一个客户端，又来一个客户端，那么不断地将新客户端的文件描述符挂上去即可。而监听新客户端连接的，始终是最上面的那个文件描述符。</p>
<p><strong>总结</strong></p>
<p>当有新客户端建立连接时，会触发 acceptHandler 函数执行，创建一个等待数据的描述符并且绑定 readQueryFromClient 函数。</p>
<p>当有客户端数据传来时，会触发 readQueryFromClient 函数执行，完成这个命令的操作。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTZ0QgoG3fhicDPejicOsW7J4FMTr8xYfFmaf7y9T53SDFHzXNx3aGsJtRHjnoprCic3c4GRmW8Bw8RA/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>由于<strong>只有一个线程在监听这些描述符</strong>，并做处理。所以即使客户端并发地发送命令，服务器仍然是一次取出命令，顺序执行。这也就是我们常常讲的<strong>redis 是单线程的</strong>，命令与命令之间是顺序执行，无需考虑线程安全的问题。</p>
<h2 id="redis命令执行的流程"><a href="#Redis命令执行的流程" class="headerlink" title="Redis命令执行的流程"></a>Redis命令执行的流程</h2><p>已经建立好连接的客户端发送一个 redis 命令，此时 readQueryFromClient 命令请求处理器会被执行，它会到一张表中去寻找对应的函数来执行命令。</p>
<p>处理完命令之后，需要发送响应给客户端。它会调用 acCreateFileEvent 函数，将 sendReplyToClient 命令回复处理器 挂在需要响应的客户端连接的文件描述符上。</p>
<h2 id="io多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>由 epoll 是实现的，在内核中开辟一块缓冲区，首先调用 epoll_create 创建红黑树空间，然后执行 epoll_ctl 将红黑树空间的文件描述符和监听 socket 的文件描述符关联，当有 IO 发生时，记录 IO 的编号并存在一个链表中，当发生 epoll_wait 系统调用的时候，会将记录有事件 IO 的链表返回，用户程序只需要根据这个链表上记录的信息读写产生事件的 IO 描述符即可。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAjXNXJTV82eOqkbJdOrDpQpAaWiceBqvAXyFEOTdV5fC2dNsL29yBW7w/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p><a href="https://mp.weixin.qq.com/s/YdIdoZ_yusVWza1PU7lWaw" target="_blank" rel="noopener">你管这破玩意叫 IO 多路复用？ (qq.com)</a></p>
<p>read 函数在客户端一直不发送数据的情况下，服务端会造成阻塞，且无法处理其他客户端的请求，所以它是<strong>阻塞 IO</strong>。</p>
<p>为了解决这个问题，程序员在用户态可以通过多线程来防止主线程卡死。【每次都创建一个新的进程或者线程去调用 read 函数，并做业务处理】</p>
<p>但是多线程的做法存在一个问题，为每个客户端创建一个线程，服务器端的线程资源很容易被耗光。操作系统层面提供了非阻塞的 read 函数【<strong>非阻塞 IO</strong>，数据没有到达时（到达网卡并拷贝到了内核缓冲区之前）立刻返回一个错误值（-1），但是当数据到达内核缓冲区，这个 read 函数仍然时阻塞的，需要等待数据从内核缓冲区拷贝到用户缓冲区，才能返回数据】，利用这个非阻塞的 read 函数，程序员可以在一个线程内完成多个文件描述符的读取。</p>
<p>当用户态遍历的文件描述符也会越来越多时，相当于在 while 循环里进行了越来越多的系统调用，这样做时不划算的，好在操作系统提供了提供了 <strong>IO 多路复用</strong>机制 ，能够在内核态去遍历文件描述符。</p>
<p>最开始是 <strong>select</strong> 函数，通过它可以把一个文件描述符的数组发给操作系统，让操作系统去遍历，确定哪个文件描述符可以读写并做上标识。用户需要通过遍历刚刚传入的数组，知道哪些是可读的。它存在三个细节：</p>
<ol>
<li>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源很大（可优化为不复制）</li>
<li>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，只不过没有系统调用切换上下文的开销（内核层可优化为异步事件通知）</li>
<li>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</li>
</ol>
<p><strong>poll</strong> 函数解决了select 只能监听 1024 个文件描述符的限制。</p>
<p><strong>epoll</strong> 提供了三个函数：</p>
<ol>
<li><code>int epoll_create(int size)</code>：创建一个 epoll 句柄</li>
<li><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code>：向内核添加、修改或删除要监控的文件描述符</li>
<li><code>int epoll_wait(int epfd, struct epoll_event *events, int max events, int timeout)</code>：类似发起了 <code>select()</code> 调用</li>
</ol>
<p>epoll 解决了 select 的三个不足。</p>
<h2 id="redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>Redis 事务提供了一种将多个命令请求打包的功能。然后再按照顺序执行打包的所有命令，并且不会被中途打断。【即 Redis 不支持回滚操作】</p>
<h3 id="redis-命令"><a href="#Redis-命令" class="headerlink" title="Redis 命令"></a>Redis 命令</h3><ul>
<li><code>MULTI</code>：事务开启指令</li>
<li><code>EXEC</code>：事务执行指令</li>
<li><code>DISCARD</code>：丢弃事务，清空事务队列中保存的所有命令</li>
<li><code>WATCH</code>：监听一个或者多个键的状态，持续到 <code>EXEC</code> 命令位置。如果至少有一个被监听的键在 <code>EXEC</code> 前被修改了，那么整个事务会被取消。【可以基于这个机制去实现 CAS 乐观锁，还能实现原子操作】</li>
</ul>
<h3 id="redis-事务的执行流程"><a href="#Redis-事务的执行流程" class="headerlink" title="Redis 事务的执行流程"></a>Redis 事务的执行流程</h3><ol>
<li><code>MULTI</code> 命令开启一个事务</li>
<li>输入多条命令，这些命令会被放到一个队列中，等待被执行</li>
<li><code>EXEC</code> 命令执行事务，所有队列中的命令会被执行</li>
<li>可以调用 <code>DISCARD</code> 命令清空事务队列，放弃执行事务</li>
</ol>
<p>Redis 的事务不保证原子性，如果有一条命令执行出错了，后面的命令仍然会得到执行。</p>
<h3 id="事务进行到一般断电了怎么办"><a href="#事务进行到一般断电了怎么办" class="headerlink" title="事务进行到一般断电了怎么办"></a>事务进行到一般断电了怎么办</h3><p>如果事务进行到一半的时候 Redis 掉电了，那这个事务的行为肯定还没有执行完，日志页肯定还没持久化完毕，所以在重启后，用 AOF 重放恢复 Redis 服务器时，会因为事务的不完整导致报错并重启失败。此时可以用 redis-check-aof 程序对 AOF 文件进行修复，删除不完整的事务信息，然后就能成功重放恢复了。</p>
<h3 id="redis-不支持回滚"><a href="#Redis-不支持回滚" class="headerlink" title="Redis 不支持回滚"></a>Redis 不支持回滚</h3><p>Redis 事务的失败是由于 Redis 命令执行错误导致的，这些错误本应在程序编写的过程中就得到解决，而不是放到 Redis 服务端解决。Redis 的设计初衷就是简洁高效，如果决定支持事务回滚，那么势必需要添加很多逻辑（比如 MVCC ），那就违背了设计原则。</p>
<h3 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h3><p>Redis 可以通过 <code>MULTI、EXEC、DISCARD、WATCH</code> 等命令来实现事务功能。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> MULTI <span class="comment"># 开启事务</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SET USER <span class="string">"zbsong"</span></span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET USER</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> EXEC <span class="comment"># 事务执行</span></span></span><br><span class="line">1) OK</span><br><span class="line">2) "zbsong"</span><br></pre></td></tr></table></figure>
<p>使用 <code>MULTI</code> 命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <code>EXEC</code> 命令将执行所有命令。</p>
<p>这个过程是这样的：</p>
<ol>
<li>开始事务（<code>MULTI</code>）</li>
<li>命令入队</li>
<li>执行事务（<code>EXEC</code>）</li>
</ol>
<p>也可以通过 <code>DISCARD</code> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET USER <span class="string">"zbsong"</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; GET USER</span><br><span class="line">QUEUED</span><br><span class="line">&gt; DISCARD</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p><code>WATCH</code> 命令用于监听指定的键，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。【类似于 CAS，被监听的键被在事务之外的其他人更改了，那么事务会失败】</p>
<p><a href="https://www.cnblogs.com/badaoliumangqizhi/p/12552756.html" target="_blank" rel="noopener">霸道的程序猿的博客 (cnblogs.com)</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; WATCH USER</span><br><span class="line">OK</span><br><span class="line">&gt; MULTI</span><br><span class="line">&gt; SET USER <span class="string">"zbsong"</span></span><br><span class="line">OK</span><br><span class="line">&gt; GET USER</span><br><span class="line">zbsong</span><br><span class="line">&gt; EXEC</span><br><span class="line">ERR EXEC without MULTI</span><br></pre></td></tr></table></figure>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透就是大量请求的 key 根本不存在于缓存种，导致请求直接到了数据库上，根本没有经过缓存这一层。比如某个黑客故意制造缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p>
<h3 id="缓存穿透情况的处理流程"><a href="#缓存穿透情况的处理流程" class="headerlink" title="缓存穿透情况的处理流程"></a>缓存穿透情况的处理流程</h3><p>用户请求 -&gt; 缓存中是否存在对应的数据 —不存在—&gt; 数据库中是否存在对应的数据 —不存在—&gt; 返回空数据</p>
<h3 id="缓存穿透的解决办法"><a href="#缓存穿透的解决办法" class="headerlink" title="缓存穿透的解决办法"></a>缓存穿透的解决办法</h3><p>最基本的是首先做好参数校验，比如查询数据库的 id 不能小于 0，传入的邮箱格式不对时直接返回错误信息给客户端等。</p>
<p><strong>1）缓存无效key</strong></p>
<p>如果缓存和数据库都查不到某个 key 的数据，就写一个 key-null 的数据并设置一个较短的过期时间。这种做法可以防止攻击者反复使用同一个 key 来暴力攻击。</p>
<p><strong>2）布隆过滤器</strong></p>
<p>将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免将请求打到数据库。</p>
<p>布隆过滤器判断某个元素存在，小概率会误判；布隆过滤器判断某个元素不在，那么这个元素一定不在。</p>
<blockquote>
<p>为什么会出现误判？</p>
<p>当一个元素加入布隆过滤器时：</p>
<ol>
<li>使用布隆过滤器的哈希函数对元素值进行计算，得到哈希值</li>
<li>根据得到的哈希值，在 bitmap 中把对应下标的值置为 1</li>
</ol>
<p>判断一个元素是否存在于布隆过滤器时：</p>
<ol>
<li>对给定元素进行哈希计算得到哈希值</li>
<li>得到哈希值之后判断 bitmap 中对应的元素是否为 1，如果为 1 说明这个值存在，如果不为 1 说明不存在</li>
</ol>
<p>然后可能会出现这样的情况：<strong>不同的字符串可能哈希出来同样的结果</strong>，这样就会导致一个不存在的元素但是哈希值和某个存在的元素的哈希值相同的情况，会出现误判。【通过适当的增加 bitmap 的大小或者调整哈希函数来降低误判的概率】</p>
</blockquote>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。比如系统的缓存模块除了问题（如宕机导致不可用），造成系统的所有访问都要走数据库。又比如一些被大量访问的数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>针对 Redis 服务不可用的情况</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用</li>
<li>限流，避免同时处理大量的请求</li>
</ol>
<p><strong>针对热点缓存失效的情况</strong></p>
<ol>
<li>设置不同的失效时间比如随即设置缓存的失效时间</li>
<li>缓存永不失效</li>
</ol>
<h2 id="缓存常用的读写策略"><a href="#缓存常用的读写策略" class="headerlink" title="缓存常用的读写策略"></a>缓存常用的读写策略</h2><h3 id="cache-aside-pattern-旁路缓存模式"><a href="#Cache-Aside-Pattern-旁路缓存模式" class="headerlink" title="Cache Aside Pattern 旁路缓存模式"></a>Cache Aside Pattern 旁路缓存模式</h3><p>Cache Aside Pattern 是使用较多的一个缓存读写模式，比较适合读请求比较多的场景。</p>
<p>Cache Aside Pattern 中服务端需要同时维护 DB 和 cache，并且是以 DB 的结果为准。</p>
<h4 id="写步骤"><a href="#写步骤" class="headerlink" title="写步骤"></a>写步骤</h4><ul>
<li>先更新 DB</li>
<li>然后直接删除 cache</li>
</ul>
<p><strong>1.可以先删除 cache，然后更新 DB 吗？</strong></p>
<p>先删除 cache 然后更新 DB的话，容易产生脏数据。假设有两个并发操作分别是更新和查询：</p>
<ol>
<li>更新操作先将 cache 删除数据 A</li>
<li>查询操作在 cache 中没有找到数据 A，转头到 DB 中查询，并将查询到的数据 A 写入 cache</li>
<li>更新操作因为属于写操作比较慢，此时刚完成 DB 中数据 A 的更新，于是 cache 中的数据 A 就变成了旧数据</li>
</ol>
<p>如果后续数据 A 不再更新的话，这个数据将一直存在于缓存中。【可以通过设置过期时间来优化这个问题】</p>
<p><strong>2.先更新 DB，后删除 cache 就没问题了吗？</strong></p>
<p>先更新 DB 后删除 cache 产生脏数据的概率较小，但是会出现一致性问题：</p>
<ol>
<li>更新操作先到 DB 中更新数据 A</li>
<li>查询操作先从 cache 中查询数据 A，此时查询到的数据 A 是脏数据</li>
<li>更新操作在 DB 中操作完之后删除 cache，下一轮查询操作就直接走的是 DB，然后将数据 A 放入缓存</li>
</ol>
<p>可以看到脏数据只产生了一次，代价较小。</p>
<h4 id="读步骤"><a href="#读步骤" class="headerlink" title="读步骤"></a>读步骤</h4><ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache 中读取不到的话，就从 DB 中读取数据返回</li>
<li>再把数据放到 cache 中</li>
</ul>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p><strong>1）首次请求的数据一定不在 cache 中</strong></p>
<p>可以将热点数据提前放入 cache 中。</p>
<p><strong>2）写操作比较频繁的话导致 cache 中的数据会被频繁删除，影响缓存命中率</strong></p>
<ul>
<li>数据库和缓存数据强一致场景：更新 DB 的时候同样更新 cache，不过需要加锁/分布式锁来保证更新 cache 的时候不存在线程安全问题</li>
<li>可以短暂地允许数据库和缓存数据不一致地场景：更新 DB 的时候同样更新 cache，但是给缓存加一个较短的过期时间，这样的话就可以保证即使数据不一致影响也比较小。</li>
</ul>
<h3 id="readwrite-through-pattern-读写穿透"><a href="#Read-Write-Through-Pattern-读写穿透" class="headerlink" title="Read/Write Through Pattern 读写穿透"></a>Read/Write Through Pattern 读写穿透</h3><p>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。【很少使用，抛开性能不谈，Redis 也并没有提供 cache 将数据写入 DB 的功能】</p>
<h4 id="写步骤"><a href="#写步骤-1" class="headerlink" title="写步骤"></a>写步骤</h4><ul>
<li>先查 cache，cache 中不存在，直接更新 DB</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB</li>
</ul>
<h4 id="读步骤"><a href="#读步骤-1" class="headerlink" title="读步骤"></a>读步骤</h4><ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>读取不到，就从 DB 加载，然后写入到 cache 后返回</li>
</ul>
<h3 id="write-behind-pattern-异步缓存写入"><a href="#Write-Behind-Pattern-异步缓存写入" class="headerlink" title="Write Behind Pattern 异步缓存写入"></a>Write Behind Pattern 异步缓存写入</h3><p>和读写穿透相似，都是由 cache 服务来负责 cache 和 DB 的读写。</p>
<p>但是 读写穿透是同步更新 cache 和 DB，异步缓存写入则是只更新缓存，通过异步批量的方式来更新 DB。</p>
<p>很显然这种方式对数据一致性带来了很大的挑战，比如 cache 数据可能还没异步更新 DB，cache 服务可能就挂掉了。</p>
<p>但是这种策略的写性能非常高，适用于数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量等。</p>
<h2 id="保证缓存和数据库的一致性"><a href="#保证缓存和数据库的一致性" class="headerlink" title="保证缓存和数据库的一致性"></a>保证缓存和数据库的一致性</h2><p><a href="https://blog.csdn.net/qq_42405666/article/details/107671099" target="_blank" rel="noopener">更新操作先删除缓存后更新DB，还是先更新DB后删除缓存问题？？？_Hello什么来着？-CSDN博客</a></p>
<p>拿旁路缓存模式来讲，如果更新数据库成功，而删除缓存这一步失败的话，有两种解决方案：</p>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p><img src="https://img-blog.csdnimg.cn/20200729213615121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDA1NjY2,size_16,color_FFFFFF,t_70" alt=""></p>
<ol>
<li>更新数据库数据</li>
<li>缓存因为种种原因删除失败</li>
<li>将需要删除的 key 发送至消息队列</li>
<li>自己消费消息，获得需要删除的 key</li>
<li>继续重试删除操作，直到成功</li>
</ol>
<p>该方案的缺点是对业务代码造成大量的侵入，于是有了方案二，启动一个订阅程序去订阅数据库的 binlog，获取需要操作的数据。在应用程序中另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。</p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p><img src="https://img-blog.csdnimg.cn/20200729213739108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDA1NjY2,size_16,color_FFFFFF,t_70" alt=""></p>
<ol>
<li>更新数据库数据</li>
<li>数据库会将操作信息写入 binlog 日志当中</li>
<li>订阅程序提取出所需的数据以及 key</li>
<li>另起一段非业务代码，获得该信息</li>
<li>尝试删除缓存操作，发现删除失败</li>
<li>将这些信息发送至消息队列</li>
<li>重新从消息队列中获得该数据，重试操作</li>
</ol>
<p>订阅 binlog 的程序在 MySQL 中有现成的中间件叫  canal，可以完成订阅 binlog 日志的功能。重试机制如果对一致性要求不高，可以直接在程序中另起一个线程，每隔一段时间去重试即可。</p>
<h2 id="redis主从复制原理"><a href="#Redis主从复制原理" class="headerlink" title="Redis主从复制原理"></a>Redis主从复制原理</h2><p><a href="https://zhuanlan.zhihu.com/p/55532249" target="_blank" rel="noopener">一文让你明白Redis主从同步 - 知乎 (zhihu.com)</a></p>
<p>虽然 Redis 服务重启后会将硬盘上持久化的数据恢复到内存中，但是当 Redis 服务器的硬盘损坏后可能会导致数据丢失，通过 Redis 主从复制机制可以解决这种单点故障问题。</p>
<p><strong>主从同步分为 2 个步骤：同步和命令传播</strong></p>
<ul>
<li>同步：将服务器的数据库状态更新成主服务器当前的数据库状态</li>
<li>命令传播：当主服务器数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的过程。</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>从服务器对主服务器的同步操作，需要通过 sync 命令来实现，sync 命令的执行步骤：</p>
<ol>
<li>从服务器向主服务器发送 sync 命令</li>
<li>收到 sync 命令后，主服务器执行 bgsave 命令，用来生成 RDB 文件，并在一个缓冲区中记录从现在开始执行的写命令</li>
<li>bgsave 执行完成后，将生成的 RDB 文件发送给从服务器，用来给从服务器更新数据</li>
<li>主服务器再将缓冲区记录的写命令发送给从服务器，从服务器执行完这些写命令后，此时的数据库状态便和主服务器一致了</li>
</ol>
<h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>经过同步操作，此时主从的数据库状态其实已经一致了，但这种一致的状态并不是一成不变的。</p>
<p>在完成同步之后，也许主服务器马上就接收到了新的写命令，执行完该命令后，主从的数据库状态又不一致了。</p>
<p>于是为了再次让主从数据库状态一致，主服务器就需要向从服务器执行命令传播操作，即把刚才造成不一致的写命令，发送给从服务器去执行。从服务器执行完成之后，主从数据库状态就又恢复一致了。</p>
<h3 id="优化的同步操作"><a href="#优化的同步操作" class="headerlink" title="优化的同步操作"></a>优化的同步操作</h3><p>从 Redis 2.8 版本开始，进行主从同步可能只需要执行命令传播即可。是为了优化 sync 命令比较消耗资源的问题。</p>
<p>主从同步分两种情况：</p>
<ol>
<li>初次复制：从服务器第一次复制当前主服务器</li>
<li>断线后重复制：处于命令传播阶段的主从服务器，因为网络问题而中断复制，从服务器通过自动重连，重新连接上主服务器并继续复制</li>
</ol>
<p>针对于短线后重复制的情况，Redis 2.8 版本之前会再次执行同步（sync 命令）和命令传播。</p>
<p>但是如果在短线期间，主服务器（已有上万的键值对）只执行了几个写命令，为了让从服务器弥补这几个命令却需要重新执行 sync 来生成新的 RDB 文件，效率非常的低。</p>
<p>为了解决这个问题，Redis 2.8 开始就使用 psync 命令来代替 sync 命令去执行同步操作。</p>
<p><strong>psync 具有两种模式：</strong></p>
<ul>
<li>完整重同步：用于初次复制情况，执行过程同 sync</li>
<li>部分重同步：用于断线后重复制情况，如果满足一定条件，主服务器只需要将短线期间执行的写命令发送给从服务器即可</li>
</ul>
<h4 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h4><p>部分重同步分为三部分：</p>
<ol>
<li>主从服务器的复制偏移量</li>
<li>主服务器的复制积压缓冲区</li>
<li>服务器的运行 id（run id）</li>
</ol>
<p><strong>1）复制偏移量</strong></p>
<p>执行复制的主从服务器都会分别维护各自的复制偏移量：</p>
<ul>
<li>主服务器每次向从服务器传播 n 个字节数据时，都会将自己的复制偏移量加 n</li>
<li>从服务接受主服务器传来的数据时，也会将自己的复制偏移量加 n</li>
</ul>
<p><strong>2）复制积压缓冲区</strong></p>
<p>复制积压缓冲区是固定长度的先进先出队列，默认 1MB。</p>
<p>当主服务器进行命令传播时，不仅会将命令发送给从服务器，还会发送给这个缓冲区。</p>
<p>因此复制积压缓冲区的构造是这样的：</p>
<p><strong><img src="https://pic2.zhimg.com/80/v2-4b129854c6a808e42de4701eb52d6e79_720w.jpg" alt=""></strong></p>
<p>当从服务器向主服务器发送 psync 命令时，还需要将自己的复制偏移量带上，主服务器就可以通过这个复制偏移量和复制积压缓冲区的偏移量进行对比。</p>
<p><strong>若复制积压缓冲区存在从服务器的复制偏移量 +1 后的数据，则进行部分重同步，否则进行完整重同步。</strong></p>
<p><strong>3）run id</strong></p>
<p>运行 id 是在进行初次复制时，主服务器将自己的运行 id 发送给从服务器，让其保存起来。</p>
<p>当从服务器断线重连后，从服务器会将这个运行 id 发送给刚连接上的主服务器。</p>
<p>若当前服务器的运行 id 与之相同，说明从服务器断线前复制的服务器就是当前服务器，主服务器可以尝试执行部分同步；若不同则说明从服务器断线前复制的服务器不是当前服务器，主服务器直接执行完成重同步。</p>
<h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>当完成了同步之后，主从服务器就会进入命令传播阶段，此时从服务器会以每秒 1 次的频率，向主服务器发送命令：<code>REPLCONF ACK &lt;replicaiton_offset&gt;</code> 其中 replication_offset 是从服务器当前的复制偏移量。</p>
<p>发送该命令的主要有三个作用：</p>
<ul>
<li>检测从服务器的网络状态</li>
<li>辅助实现 min-slaves 选项【不懂】</li>
<li>检测命令丢失（若丢失，主服务器会将丢失的写命令重写发给从服务器）</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>发送 <code>SLAVEOF</code> 命令可以进行主从同步，比如：<code>SLAVEOF 127.0.0.6379</code>，将当前服务器编程 <code>127.0.0.6379</code> 的从服务器。</p>
</li>
<li><p>主从同步有同步和命令传播 2 个步骤。</p>
<ul>
<li>同步：将从服务器的数据库状态更新成主服务器当前的数据库状态（一个消耗资源的操作）</li>
<li>命令传播：当主服务器数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的过程</li>
</ul>
</li>
</ul>
<h2 id="redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h3><p>主从模式比较简单，即一台 Master 服务器，若干台 Slave 服务器，Master 提供读写，Slave 提供读。Master 和 Slave 之间进行状态同步。</p>
<h4 id="如何同步"><a href="#如何同步" class="headerlink" title="如何同步"></a>如何同步</h4><p>参考上一节 “Redis 主从复制原理”。</p>
<p>Slave 在启动时会向 Master 发送 SYNC 命令，Master 收到后会执行 bgsave，进行 RDB 备份，并在内存缓冲区 buffer 中记录开始备份之后的写操作。Master 把创建好的 RDB 文件发送给 Slave，Slave 加载快照。随后 Master 会把 buffer 中记录的写命令发送给 Slave，以保证数据一致性。往后 Master 每执行一次写操作，都会同步发送给 Slave。</p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>Master 宕机后，如果数据未同步完成，新的 Master 选出来后会存在数据丢失问题</p>
<h3 id="哨兵模式sentinel模式"><a href="#哨兵模式（Sentinel模式）" class="headerlink" title="哨兵模式（Sentinel模式）"></a>哨兵模式（Sentinel模式）</h3><p>哨兵模式基于主从模式引入了哨兵来监控和自动处理故障。该模式着眼于高可用，在 Master 宕机时会自动将 Slave 提升为 Master，继续提供服务。</p>
<p>哨兵程序单独用一台服务器部署，称为<strong>哨兵节点</strong>，为了防止哨兵节点挂掉影响哨兵模式的运行，部署多个哨兵，采用<strong>哨兵集群</strong>。</p>
<p>如果某个哨兵发现 Master 服务器不可用了（Ping 超时），那么这个哨兵主观地认为 Master 已经挂掉了，称作为<strong>主观下线</strong>。此时还不能认为 Master 真的挂掉了，还需要询问其他哨兵节点，Master 是否已经下线。当主观下线的数量达到一定值，就可以认为 Master <strong>客观下线</strong>。一旦 Master 客观下线了，那么<strong>领头的哨兵节点</strong>就会执行故障处理流程，即选择一个 Slave 变成 Master。</p>
<h4 id="故障处理流程"><a href="#故障处理流程" class="headerlink" title="故障处理流程"></a>故障处理流程</h4><ol>
<li>按照规则挑选出一个从节点变成主节点</li>
<li>修改其他从节点的附属主节点</li>
<li>将挂掉的主节点变为从节点【等它一复活就发给它】</li>
</ol>
<p><strong>如何从所有的 Slave 中选出来一个作为 Master？</strong></p>
<p>首先按照优先级排序，优先级一样则按复制偏移量排【选偏移量大的】，如果都一样，则选 run Id 最小的。</p>
<h4 id="领头哨兵的选举-raft-协议"><a href="#领头哨兵的选举-Raft-协议" class="headerlink" title="领头哨兵的选举 Raft 协议"></a>领头哨兵的选举 Raft 协议</h4><p><a href="https://zhuanlan.zhihu.com/p/125573685" target="_blank" rel="noopener">全面理解Raft协议 - 知乎 (zhihu.com)</a></p>
<p>Raft 是分布式一致性的实现协议。</p>
<p>一个节点有 3 种状态：Follower、Candidate、Leader。</p>
<p>一开始所有节点都是 Follower 状态，当 Follower 在<strong>心跳超时</strong>时间内没有接收到 Leader 周期性发送的 heartbeat 就会开启选举过程。Follower 会等待一个随机的<strong>选举超时</strong>时间（等待随机时间的作用是尽量避免产生多个 Candidate 给选举过程造成麻烦）后，将自己转化为 Candidate，并开始发起第一轮选举。Candidate 节点首先给自己投一票，然后向其他节点发送投票信息，此时有三种情况：</p>
<ol>
<li>获得了多数选票，该节点称为 Leader</li>
<li>收到了 Leader 的消息，有其他节点抢先成为了 Leader</li>
<li>没有获得多数选票，此次选举失败，等待一段时间后发起下一次选举</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>难以扩容，而且还需要额外的资源来启动哨兵，但可用性高</p>
<h3 id="cluster模式"><a href="#Cluster模式" class="headerlink" title="Cluster模式"></a>Cluster模式</h3><p>哨兵模式解决了主从模式不能自动处理故障的问题，实现了高可用，但是没法方便的扩容。Cluster 模式实现了 Redis 的分布式存储，即每个节点存储不同的内容，来解决在线扩容的问题。</p>
<p>Cluster 模式采用无中心架构，它把所有的数据划分到多个槽位中，当我们存取 key 的时候，Redis 会根据 CRC16 算法算出一个结果，然后对槽位数量取余，这样每个 key 都会对应一个槽位编号，然后用这个编号去对应的节点里存取 key。</p>
<p>当客户端连接集群的时候，会得到一份集群槽位的配置信息，这样就可以直接根据配置信息去操作相应的槽位。</p>
<p>Cluster 模式可以实现动态扩容，支持自动故障转移，节点间用 gossip 协议交换状态信息。</p>
<h4 id="gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h4><p>Gossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。</p>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    
                        <li class="next">
                            <a href="/article/数据库学习/" data-toggle="tooltip" data-placement="top" title="数据库">下一篇 &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">目录</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#简介"><span class="toc-nav-number">1.</span> <span class="toc-nav-text"><a href="#&#x7B80;&#x4ECB;" class="headerlink" title="&#x7B80;&#x4ECB;"></a>&#x7B80;&#x4ECB;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#分布式缓存"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text"><a href="#&#x5206;&#x5E03;&#x5F0F;&#x7F13;&#x5B58;" class="headerlink" title="&#x5206;&#x5E03;&#x5F0F;&#x7F13;&#x5B58;"></a>&#x5206;&#x5E03;&#x5F0F;&#x7F13;&#x5B58;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#redis特点"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text"><a href="#Redis&#x7279;&#x70B9;" class="headerlink" title="Redis&#x7279;&#x70B9;"></a>Redis&#x7279;&#x70B9;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#为什么要用-redis为什么要用缓存"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text"><a href="#&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x7528;-Redis&#xFF08;&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x7528;&#x7F13;&#x5B58;&#xFF09;" class="headerlink" title="&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x7528; Redis&#xFF08;&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x7528;&#x7F13;&#x5B58;&#xFF09;"></a>&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x7528; Redis&#xFF08;&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x7528;&#x7F13;&#x5B58;&#xFF09;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#redis常见数据结构以及使用场景分析"><span class="toc-nav-number">2.</span> <span class="toc-nav-text"><a href="#Redis&#x5E38;&#x89C1;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x4EE5;&#x53CA;&#x4F7F;&#x7528;&#x573A;&#x666F;&#x5206;&#x6790;" class="headerlink" title="Redis&#x5E38;&#x89C1;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x4EE5;&#x53CA;&#x4F7F;&#x7528;&#x573A;&#x666F;&#x5206;&#x6790;"></a>Redis&#x5E38;&#x89C1;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x4EE5;&#x53CA;&#x4F7F;&#x7528;&#x573A;&#x666F;&#x5206;&#x6790;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#string"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text"><a href="#string" class="headerlink" title="string"></a>string</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#list"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text"><a href="#list" class="headerlink" title="list"></a>list</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#hash"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text"><a href="#hash" class="headerlink" title="hash"></a>hash</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#set"><span class="toc-nav-number">2.4.</span> <span class="toc-nav-text"><a href="#set" class="headerlink" title="set"></a>set</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#sorted-set"><span class="toc-nav-number">2.5.</span> <span class="toc-nav-text"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#bitmap"><span class="toc-nav-number">2.6.</span> <span class="toc-nav-text"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#分布式锁"><span class="toc-nav-number">3.</span> <span class="toc-nav-text"><a href="#&#x5206;&#x5E03;&#x5F0F;&#x9501;" class="headerlink" title="&#x5206;&#x5E03;&#x5F0F;&#x9501;"></a>&#x5206;&#x5E03;&#x5F0F;&#x9501;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#异步消息队列"><span class="toc-nav-number">4.</span> <span class="toc-nav-text"><a href="#&#x5F02;&#x6B65;&#x6D88;&#x606F;&#x961F;&#x5217;" class="headerlink" title="&#x5F02;&#x6B65;&#x6D88;&#x606F;&#x961F;&#x5217;"></a>&#x5F02;&#x6B65;&#x6D88;&#x606F;&#x961F;&#x5217;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#redis持久化机制备份机制"><span class="toc-nav-number">5.</span> <span class="toc-nav-text"><a href="#Redis&#x6301;&#x4E45;&#x5316;&#x673A;&#x5236;&#x3010;&#x5907;&#x4EFD;&#x673A;&#x5236;&#x3011;" class="headerlink" title="Redis&#x6301;&#x4E45;&#x5316;&#x673A;&#x5236;&#x3010;&#x5907;&#x4EFD;&#x673A;&#x5236;&#x3011;"></a>Redis&#x6301;&#x4E45;&#x5316;&#x673A;&#x5236;&#x3010;&#x5907;&#x4EFD;&#x673A;&#x5236;&#x3011;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#基于快照的全量备份-rdb"><span class="toc-nav-number">5.1.</span> <span class="toc-nav-text"><a href="#&#x57FA;&#x4E8E;&#x5FEB;&#x7167;&#x7684;&#x5168;&#x91CF;&#x5907;&#x4EFD;-RDB" class="headerlink" title="&#x57FA;&#x4E8E;&#x5FEB;&#x7167;&#x7684;&#x5168;&#x91CF;&#x5907;&#x4EFD; RDB"></a>&#x57FA;&#x4E8E;&#x5FEB;&#x7167;&#x7684;&#x5168;&#x91CF;&#x5907;&#x4EFD; RDB</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#手动备份"><span class="toc-nav-number">5.1.1.</span> <span class="toc-nav-text"><a href="#&#x624B;&#x52A8;&#x5907;&#x4EFD;" class="headerlink" title="&#x624B;&#x52A8;&#x5907;&#x4EFD;"></a>&#x624B;&#x52A8;&#x5907;&#x4EFD;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#自动备份"><span class="toc-nav-number">5.1.2.</span> <span class="toc-nav-text"><a href="#&#x81EA;&#x52A8;&#x5907;&#x4EFD;" class="headerlink" title="&#x81EA;&#x52A8;&#x5907;&#x4EFD;"></a>&#x81EA;&#x52A8;&#x5907;&#x4EFD;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#持久化存储实现原理"><span class="toc-nav-number">5.1.3.</span> <span class="toc-nav-text"><a href="#&#x6301;&#x4E45;&#x5316;&#x5B58;&#x50A8;&#x5B9E;&#x73B0;&#x539F;&#x7406;" class="headerlink" title="&#x6301;&#x4E45;&#x5316;&#x5B58;&#x50A8;&#x5B9E;&#x73B0;&#x539F;&#x7406;"></a>&#x6301;&#x4E45;&#x5316;&#x5B58;&#x50A8;&#x5B9E;&#x73B0;&#x539F;&#x7406;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#基于指令日志的增量备份-aof"><span class="toc-nav-number">5.2.</span> <span class="toc-nav-text"><a href="#&#x57FA;&#x4E8E;&#x6307;&#x4EE4;&#x65E5;&#x5FD7;&#x7684;&#x589E;&#x91CF;&#x5907;&#x4EFD;-AOF" class="headerlink" title="&#x57FA;&#x4E8E;&#x6307;&#x4EE4;&#x65E5;&#x5FD7;&#x7684;&#x589E;&#x91CF;&#x5907;&#x4EFD; AOF"></a>&#x57FA;&#x4E8E;&#x6307;&#x4EE4;&#x65E5;&#x5FD7;&#x7684;&#x589E;&#x91CF;&#x5907;&#x4EFD; AOF</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#aof重写"><span class="toc-nav-number">5.3.</span> <span class="toc-nav-text"><a href="#AOF&#x91CD;&#x5199;" class="headerlink" title="AOF&#x91CD;&#x5199;"></a>AOF&#x91CD;&#x5199;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#rdb和aof的比较"><span class="toc-nav-number">5.4.</span> <span class="toc-nav-text"><a href="#RDB&#x548C;AOF&#x7684;&#x6BD4;&#x8F83;" class="headerlink" title="RDB&#x548C;AOF&#x7684;&#x6BD4;&#x8F83;"></a>RDB&#x548C;AOF&#x7684;&#x6BD4;&#x8F83;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#混合策略"><span class="toc-nav-number">5.5.</span> <span class="toc-nav-text"><a href="#&#x6DF7;&#x5408;&#x7B56;&#x7565;" class="headerlink" title="&#x6DF7;&#x5408;&#x7B56;&#x7565;"></a>&#x6DF7;&#x5408;&#x7B56;&#x7565;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#过期的数据的删除策略"><span class="toc-nav-number">6.</span> <span class="toc-nav-text"><a href="#&#x8FC7;&#x671F;&#x7684;&#x6570;&#x636E;&#x7684;&#x5220;&#x9664;&#x7B56;&#x7565;" class="headerlink" title="&#x8FC7;&#x671F;&#x7684;&#x6570;&#x636E;&#x7684;&#x5220;&#x9664;&#x7B56;&#x7565;"></a>&#x8FC7;&#x671F;&#x7684;&#x6570;&#x636E;&#x7684;&#x5220;&#x9664;&#x7B56;&#x7565;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#内存淘汰策略"><span class="toc-nav-number">7.</span> <span class="toc-nav-text"><a href="#&#x5185;&#x5B58;&#x6DD8;&#x6C70;&#x7B56;&#x7565;" class="headerlink" title="&#x5185;&#x5B58;&#x6DD8;&#x6C70;&#x7B56;&#x7565;"></a>&#x5185;&#x5B58;&#x6DD8;&#x6C70;&#x7B56;&#x7565;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#redis给缓存数据设置过期时间有啥用"><span class="toc-nav-number">8.</span> <span class="toc-nav-text"><a href="#Redis&#x7ED9;&#x7F13;&#x5B58;&#x6570;&#x636E;&#x8BBE;&#x7F6E;&#x8FC7;&#x671F;&#x65F6;&#x95F4;&#x6709;&#x5565;&#x7528;&#xFF1F;" class="headerlink" title="Redis&#x7ED9;&#x7F13;&#x5B58;&#x6570;&#x636E;&#x8BBE;&#x7F6E;&#x8FC7;&#x671F;&#x65F6;&#x95F4;&#x6709;&#x5565;&#x7528;&#xFF1F;"></a>Redis&#x7ED9;&#x7F13;&#x5B58;&#x6570;&#x636E;&#x8BBE;&#x7F6E;&#x8FC7;&#x671F;&#x65F6;&#x95F4;&#x6709;&#x5565;&#x7528;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#redis如何判断数据是否过期"><span class="toc-nav-number">9.</span> <span class="toc-nav-text"><a href="#Redis&#x5982;&#x4F55;&#x5224;&#x65AD;&#x6570;&#x636E;&#x662F;&#x5426;&#x8FC7;&#x671F;" class="headerlink" title="Redis&#x5982;&#x4F55;&#x5224;&#x65AD;&#x6570;&#x636E;&#x662F;&#x5426;&#x8FC7;&#x671F;"></a>Redis&#x5982;&#x4F55;&#x5224;&#x65AD;&#x6570;&#x636E;&#x662F;&#x5426;&#x8FC7;&#x671F;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#redis单线程模型"><span class="toc-nav-number">10.</span> <span class="toc-nav-text"><a href="#Redis&#x5355;&#x7EBF;&#x7A0B;&#x6A21;&#x578B;" class="headerlink" title="Redis&#x5355;&#x7EBF;&#x7A0B;&#x6A21;&#x578B;"></a>Redis&#x5355;&#x7EBF;&#x7A0B;&#x6A21;&#x578B;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#单线程是怎么监听大量的客户端连接呢"><span class="toc-nav-number">10.1.</span> <span class="toc-nav-text"><a href="#&#x5355;&#x7EBF;&#x7A0B;&#x662F;&#x600E;&#x4E48;&#x76D1;&#x542C;&#x5927;&#x91CF;&#x7684;&#x5BA2;&#x6237;&#x7AEF;&#x8FDE;&#x63A5;&#x5462;&#xFF1F;" class="headerlink" title="&#x5355;&#x7EBF;&#x7A0B;&#x662F;&#x600E;&#x4E48;&#x76D1;&#x542C;&#x5927;&#x91CF;&#x7684;&#x5BA2;&#x6237;&#x7AEF;&#x8FDE;&#x63A5;&#x5462;&#xFF1F;"></a>&#x5355;&#x7EBF;&#x7A0B;&#x662F;&#x600E;&#x4E48;&#x76D1;&#x542C;&#x5927;&#x91CF;&#x7684;&#x5BA2;&#x6237;&#x7AEF;&#x8FDE;&#x63A5;&#x5462;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#redis-60之后为何引入了多线程"><span class="toc-nav-number">10.2.</span> <span class="toc-nav-text"><a href="#Redis-6-0&#x4E4B;&#x540E;&#x4E3A;&#x4F55;&#x5F15;&#x5165;&#x4E86;&#x591A;&#x7EBF;&#x7A0B;&#xFF1F;" class="headerlink" title="Redis 6.0&#x4E4B;&#x540E;&#x4E3A;&#x4F55;&#x5F15;&#x5165;&#x4E86;&#x591A;&#x7EBF;&#x7A0B;&#xFF1F;"></a>Redis 6.0&#x4E4B;&#x540E;&#x4E3A;&#x4F55;&#x5F15;&#x5165;&#x4E86;&#x591A;&#x7EBF;&#x7A0B;&#xFF1F;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#redis-启动流程"><span class="toc-nav-number">11.</span> <span class="toc-nav-text"><a href="#Redis-&#x542F;&#x52A8;&#x6D41;&#x7A0B;" class="headerlink" title="Redis &#x542F;&#x52A8;&#x6D41;&#x7A0B;"></a>Redis &#x542F;&#x52A8;&#x6D41;&#x7A0B;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#redis客户端连接服务器的流程"><span class="toc-nav-number">12.</span> <span class="toc-nav-text"><a href="#Redis&#x5BA2;&#x6237;&#x7AEF;&#x8FDE;&#x63A5;&#x670D;&#x52A1;&#x5668;&#x7684;&#x6D41;&#x7A0B;" class="headerlink" title="Redis&#x5BA2;&#x6237;&#x7AEF;&#x8FDE;&#x63A5;&#x670D;&#x52A1;&#x5668;&#x7684;&#x6D41;&#x7A0B;"></a>Redis&#x5BA2;&#x6237;&#x7AEF;&#x8FDE;&#x63A5;&#x670D;&#x52A1;&#x5668;&#x7684;&#x6D41;&#x7A0B;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#redis命令执行的流程"><span class="toc-nav-number">13.</span> <span class="toc-nav-text"><a href="#Redis&#x547D;&#x4EE4;&#x6267;&#x884C;&#x7684;&#x6D41;&#x7A0B;" class="headerlink" title="Redis&#x547D;&#x4EE4;&#x6267;&#x884C;&#x7684;&#x6D41;&#x7A0B;"></a>Redis&#x547D;&#x4EE4;&#x6267;&#x884C;&#x7684;&#x6D41;&#x7A0B;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#io多路复用"><span class="toc-nav-number">14.</span> <span class="toc-nav-text"><a href="#IO&#x591A;&#x8DEF;&#x590D;&#x7528;" class="headerlink" title="IO&#x591A;&#x8DEF;&#x590D;&#x7528;"></a>IO&#x591A;&#x8DEF;&#x590D;&#x7528;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#redis事务"><span class="toc-nav-number">15.</span> <span class="toc-nav-text"><a href="#Redis&#x4E8B;&#x52A1;" class="headerlink" title="Redis&#x4E8B;&#x52A1;"></a>Redis&#x4E8B;&#x52A1;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#redis-命令"><span class="toc-nav-number">15.1.</span> <span class="toc-nav-text"><a href="#Redis-&#x547D;&#x4EE4;" class="headerlink" title="Redis &#x547D;&#x4EE4;"></a>Redis &#x547D;&#x4EE4;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#redis-事务的执行流程"><span class="toc-nav-number">15.2.</span> <span class="toc-nav-text"><a href="#Redis-&#x4E8B;&#x52A1;&#x7684;&#x6267;&#x884C;&#x6D41;&#x7A0B;" class="headerlink" title="Redis &#x4E8B;&#x52A1;&#x7684;&#x6267;&#x884C;&#x6D41;&#x7A0B;"></a>Redis &#x4E8B;&#x52A1;&#x7684;&#x6267;&#x884C;&#x6D41;&#x7A0B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#事务进行到一般断电了怎么办"><span class="toc-nav-number">15.3.</span> <span class="toc-nav-text"><a href="#&#x4E8B;&#x52A1;&#x8FDB;&#x884C;&#x5230;&#x4E00;&#x822C;&#x65AD;&#x7535;&#x4E86;&#x600E;&#x4E48;&#x529E;" class="headerlink" title="&#x4E8B;&#x52A1;&#x8FDB;&#x884C;&#x5230;&#x4E00;&#x822C;&#x65AD;&#x7535;&#x4E86;&#x600E;&#x4E48;&#x529E;"></a>&#x4E8B;&#x52A1;&#x8FDB;&#x884C;&#x5230;&#x4E00;&#x822C;&#x65AD;&#x7535;&#x4E86;&#x600E;&#x4E48;&#x529E;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#redis-不支持回滚"><span class="toc-nav-number">15.4.</span> <span class="toc-nav-text"><a href="#Redis-&#x4E0D;&#x652F;&#x6301;&#x56DE;&#x6EDA;" class="headerlink" title="Redis &#x4E0D;&#x652F;&#x6301;&#x56DE;&#x6EDA;"></a>Redis &#x4E0D;&#x652F;&#x6301;&#x56DE;&#x6EDA;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#杂记"><span class="toc-nav-number">15.5.</span> <span class="toc-nav-text"><a href="#&#x6742;&#x8BB0;" class="headerlink" title="&#x6742;&#x8BB0;"></a>&#x6742;&#x8BB0;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#缓存穿透"><span class="toc-nav-number">16.</span> <span class="toc-nav-text"><a href="#&#x7F13;&#x5B58;&#x7A7F;&#x900F;" class="headerlink" title="&#x7F13;&#x5B58;&#x7A7F;&#x900F;"></a>&#x7F13;&#x5B58;&#x7A7F;&#x900F;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#缓存穿透情况的处理流程"><span class="toc-nav-number">16.1.</span> <span class="toc-nav-text"><a href="#&#x7F13;&#x5B58;&#x7A7F;&#x900F;&#x60C5;&#x51B5;&#x7684;&#x5904;&#x7406;&#x6D41;&#x7A0B;" class="headerlink" title="&#x7F13;&#x5B58;&#x7A7F;&#x900F;&#x60C5;&#x51B5;&#x7684;&#x5904;&#x7406;&#x6D41;&#x7A0B;"></a>&#x7F13;&#x5B58;&#x7A7F;&#x900F;&#x60C5;&#x51B5;&#x7684;&#x5904;&#x7406;&#x6D41;&#x7A0B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#缓存穿透的解决办法"><span class="toc-nav-number">16.2.</span> <span class="toc-nav-text"><a href="#&#x7F13;&#x5B58;&#x7A7F;&#x900F;&#x7684;&#x89E3;&#x51B3;&#x529E;&#x6CD5;" class="headerlink" title="&#x7F13;&#x5B58;&#x7A7F;&#x900F;&#x7684;&#x89E3;&#x51B3;&#x529E;&#x6CD5;"></a>&#x7F13;&#x5B58;&#x7A7F;&#x900F;&#x7684;&#x89E3;&#x51B3;&#x529E;&#x6CD5;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#缓存雪崩"><span class="toc-nav-number">17.</span> <span class="toc-nav-text"><a href="#&#x7F13;&#x5B58;&#x96EA;&#x5D29;" class="headerlink" title="&#x7F13;&#x5B58;&#x96EA;&#x5D29;"></a>&#x7F13;&#x5B58;&#x96EA;&#x5D29;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#解决办法"><span class="toc-nav-number">17.1.</span> <span class="toc-nav-text"><a href="#&#x89E3;&#x51B3;&#x529E;&#x6CD5;" class="headerlink" title="&#x89E3;&#x51B3;&#x529E;&#x6CD5;"></a>&#x89E3;&#x51B3;&#x529E;&#x6CD5;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#缓存常用的读写策略"><span class="toc-nav-number">18.</span> <span class="toc-nav-text"><a href="#&#x7F13;&#x5B58;&#x5E38;&#x7528;&#x7684;&#x8BFB;&#x5199;&#x7B56;&#x7565;" class="headerlink" title="&#x7F13;&#x5B58;&#x5E38;&#x7528;&#x7684;&#x8BFB;&#x5199;&#x7B56;&#x7565;"></a>&#x7F13;&#x5B58;&#x5E38;&#x7528;&#x7684;&#x8BFB;&#x5199;&#x7B56;&#x7565;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#cache-aside-pattern-旁路缓存模式"><span class="toc-nav-number">18.1.</span> <span class="toc-nav-text"><a href="#Cache-Aside-Pattern-&#x65C1;&#x8DEF;&#x7F13;&#x5B58;&#x6A21;&#x5F0F;" class="headerlink" title="Cache Aside Pattern &#x65C1;&#x8DEF;&#x7F13;&#x5B58;&#x6A21;&#x5F0F;"></a>Cache Aside Pattern &#x65C1;&#x8DEF;&#x7F13;&#x5B58;&#x6A21;&#x5F0F;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#写步骤"><span class="toc-nav-number">18.1.1.</span> <span class="toc-nav-text"><a href="#&#x5199;&#x6B65;&#x9AA4;" class="headerlink" title="&#x5199;&#x6B65;&#x9AA4;"></a>&#x5199;&#x6B65;&#x9AA4;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#读步骤"><span class="toc-nav-number">18.1.2.</span> <span class="toc-nav-text"><a href="#&#x8BFB;&#x6B65;&#x9AA4;" class="headerlink" title="&#x8BFB;&#x6B65;&#x9AA4;"></a>&#x8BFB;&#x6B65;&#x9AA4;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#缺陷"><span class="toc-nav-number">18.1.3.</span> <span class="toc-nav-text"><a href="#&#x7F3A;&#x9677;" class="headerlink" title="&#x7F3A;&#x9677;"></a>&#x7F3A;&#x9677;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#readwrite-through-pattern-读写穿透"><span class="toc-nav-number">18.2.</span> <span class="toc-nav-text"><a href="#Read-Write-Through-Pattern-&#x8BFB;&#x5199;&#x7A7F;&#x900F;" class="headerlink" title="Read/Write Through Pattern &#x8BFB;&#x5199;&#x7A7F;&#x900F;"></a>Read/Write Through Pattern &#x8BFB;&#x5199;&#x7A7F;&#x900F;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#写步骤"><span class="toc-nav-number">18.2.1.</span> <span class="toc-nav-text"><a href="#&#x5199;&#x6B65;&#x9AA4;-1" class="headerlink" title="&#x5199;&#x6B65;&#x9AA4;"></a>&#x5199;&#x6B65;&#x9AA4;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#读步骤"><span class="toc-nav-number">18.2.2.</span> <span class="toc-nav-text"><a href="#&#x8BFB;&#x6B65;&#x9AA4;-1" class="headerlink" title="&#x8BFB;&#x6B65;&#x9AA4;"></a>&#x8BFB;&#x6B65;&#x9AA4;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#write-behind-pattern-异步缓存写入"><span class="toc-nav-number">18.3.</span> <span class="toc-nav-text"><a href="#Write-Behind-Pattern-&#x5F02;&#x6B65;&#x7F13;&#x5B58;&#x5199;&#x5165;" class="headerlink" title="Write Behind Pattern &#x5F02;&#x6B65;&#x7F13;&#x5B58;&#x5199;&#x5165;"></a>Write Behind Pattern &#x5F02;&#x6B65;&#x7F13;&#x5B58;&#x5199;&#x5165;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#保证缓存和数据库的一致性"><span class="toc-nav-number">19.</span> <span class="toc-nav-text"><a href="#&#x4FDD;&#x8BC1;&#x7F13;&#x5B58;&#x548C;&#x6570;&#x636E;&#x5E93;&#x7684;&#x4E00;&#x81F4;&#x6027;" class="headerlink" title="&#x4FDD;&#x8BC1;&#x7F13;&#x5B58;&#x548C;&#x6570;&#x636E;&#x5E93;&#x7684;&#x4E00;&#x81F4;&#x6027;"></a>&#x4FDD;&#x8BC1;&#x7F13;&#x5B58;&#x548C;&#x6570;&#x636E;&#x5E93;&#x7684;&#x4E00;&#x81F4;&#x6027;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#方案一"><span class="toc-nav-number">19.1.</span> <span class="toc-nav-text"><a href="#&#x65B9;&#x6848;&#x4E00;" class="headerlink" title="&#x65B9;&#x6848;&#x4E00;"></a>&#x65B9;&#x6848;&#x4E00;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#方案二"><span class="toc-nav-number">19.2.</span> <span class="toc-nav-text"><a href="#&#x65B9;&#x6848;&#x4E8C;" class="headerlink" title="&#x65B9;&#x6848;&#x4E8C;"></a>&#x65B9;&#x6848;&#x4E8C;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#redis主从复制原理"><span class="toc-nav-number">20.</span> <span class="toc-nav-text"><a href="#Redis&#x4E3B;&#x4ECE;&#x590D;&#x5236;&#x539F;&#x7406;" class="headerlink" title="Redis&#x4E3B;&#x4ECE;&#x590D;&#x5236;&#x539F;&#x7406;"></a>Redis&#x4E3B;&#x4ECE;&#x590D;&#x5236;&#x539F;&#x7406;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#同步"><span class="toc-nav-number">20.1.</span> <span class="toc-nav-text"><a href="#&#x540C;&#x6B65;" class="headerlink" title="&#x540C;&#x6B65;"></a>&#x540C;&#x6B65;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#命令传播"><span class="toc-nav-number">20.2.</span> <span class="toc-nav-text"><a href="#&#x547D;&#x4EE4;&#x4F20;&#x64AD;" class="headerlink" title="&#x547D;&#x4EE4;&#x4F20;&#x64AD;"></a>&#x547D;&#x4EE4;&#x4F20;&#x64AD;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#优化的同步操作"><span class="toc-nav-number">20.3.</span> <span class="toc-nav-text"><a href="#&#x4F18;&#x5316;&#x7684;&#x540C;&#x6B65;&#x64CD;&#x4F5C;" class="headerlink" title="&#x4F18;&#x5316;&#x7684;&#x540C;&#x6B65;&#x64CD;&#x4F5C;"></a>&#x4F18;&#x5316;&#x7684;&#x540C;&#x6B65;&#x64CD;&#x4F5C;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#部分重同步的实现"><span class="toc-nav-number">20.3.1.</span> <span class="toc-nav-text"><a href="#&#x90E8;&#x5206;&#x91CD;&#x540C;&#x6B65;&#x7684;&#x5B9E;&#x73B0;" class="headerlink" title="&#x90E8;&#x5206;&#x91CD;&#x540C;&#x6B65;&#x7684;&#x5B9E;&#x73B0;"></a>&#x90E8;&#x5206;&#x91CD;&#x540C;&#x6B65;&#x7684;&#x5B9E;&#x73B0;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#心跳检测"><span class="toc-nav-number">20.4.</span> <span class="toc-nav-text"><a href="#&#x5FC3;&#x8DF3;&#x68C0;&#x6D4B;" class="headerlink" title="&#x5FC3;&#x8DF3;&#x68C0;&#x6D4B;"></a>&#x5FC3;&#x8DF3;&#x68C0;&#x6D4B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#总结"><span class="toc-nav-number">20.5.</span> <span class="toc-nav-text"><a href="#&#x603B;&#x7ED3;" class="headerlink" title="&#x603B;&#x7ED3;"></a>&#x603B;&#x7ED3;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#redis集群"><span class="toc-nav-number">21.</span> <span class="toc-nav-text"><a href="#Redis&#x96C6;&#x7FA4;" class="headerlink" title="Redis&#x96C6;&#x7FA4;"></a>Redis&#x96C6;&#x7FA4;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#主从模式"><span class="toc-nav-number">21.1.</span> <span class="toc-nav-text"><a href="#&#x4E3B;&#x4ECE;&#x6A21;&#x5F0F;" class="headerlink" title="&#x4E3B;&#x4ECE;&#x6A21;&#x5F0F;"></a>&#x4E3B;&#x4ECE;&#x6A21;&#x5F0F;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#如何同步"><span class="toc-nav-number">21.1.1.</span> <span class="toc-nav-text"><a href="#&#x5982;&#x4F55;&#x540C;&#x6B65;" class="headerlink" title="&#x5982;&#x4F55;&#x540C;&#x6B65;"></a>&#x5982;&#x4F55;&#x540C;&#x6B65;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#存在的问题"><span class="toc-nav-number">21.1.2.</span> <span class="toc-nav-text"><a href="#&#x5B58;&#x5728;&#x7684;&#x95EE;&#x9898;" class="headerlink" title="&#x5B58;&#x5728;&#x7684;&#x95EE;&#x9898;"></a>&#x5B58;&#x5728;&#x7684;&#x95EE;&#x9898;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#哨兵模式sentinel模式"><span class="toc-nav-number">21.2.</span> <span class="toc-nav-text"><a href="#&#x54E8;&#x5175;&#x6A21;&#x5F0F;&#xFF08;Sentinel&#x6A21;&#x5F0F;&#xFF09;" class="headerlink" title="&#x54E8;&#x5175;&#x6A21;&#x5F0F;&#xFF08;Sentinel&#x6A21;&#x5F0F;&#xFF09;"></a>&#x54E8;&#x5175;&#x6A21;&#x5F0F;&#xFF08;Sentinel&#x6A21;&#x5F0F;&#xFF09;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#故障处理流程"><span class="toc-nav-number">21.2.1.</span> <span class="toc-nav-text"><a href="#&#x6545;&#x969C;&#x5904;&#x7406;&#x6D41;&#x7A0B;" class="headerlink" title="&#x6545;&#x969C;&#x5904;&#x7406;&#x6D41;&#x7A0B;"></a>&#x6545;&#x969C;&#x5904;&#x7406;&#x6D41;&#x7A0B;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#领头哨兵的选举-raft-协议"><span class="toc-nav-number">21.2.2.</span> <span class="toc-nav-text"><a href="#&#x9886;&#x5934;&#x54E8;&#x5175;&#x7684;&#x9009;&#x4E3E;-Raft-&#x534F;&#x8BAE;" class="headerlink" title="&#x9886;&#x5934;&#x54E8;&#x5175;&#x7684;&#x9009;&#x4E3E; Raft &#x534F;&#x8BAE;"></a>&#x9886;&#x5934;&#x54E8;&#x5175;&#x7684;&#x9009;&#x4E3E; Raft &#x534F;&#x8BAE;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#缺点"><span class="toc-nav-number">21.2.3.</span> <span class="toc-nav-text"><a href="#&#x7F3A;&#x70B9;" class="headerlink" title="&#x7F3A;&#x70B9;"></a>&#x7F3A;&#x70B9;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#cluster模式"><span class="toc-nav-number">21.3.</span> <span class="toc-nav-text"><a href="#Cluster&#x6A21;&#x5F0F;" class="headerlink" title="Cluster&#x6A21;&#x5F0F;"></a>Cluster&#x6A21;&#x5F0F;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#gossip-协议"><span class="toc-nav-number">21.3.1.</span> <span class="toc-nav-text"><a href="#Gossip-&#x534F;&#x8BAE;" class="headerlink" title="Gossip &#x534F;&#x8BAE;"></a>Gossip &#x534F;&#x8BAE;</span></a></li></ol></li></ol></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">标签</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#java" title="java">java</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
				<!--
                
                <hr>
                <h5>朋友们</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://tyzhang.top/" target="_blank">ztygalaxy</a></li>
                    
                        <li><a href="http://www.tangyincheng.com/" target="_blank">yctang</a></li>
                    
                        <li><a href="https://dolnw.github.io" target="_blank">JCWang</a></li>
                    
                </ul>
                
				-->
            </div>
        </div>
    </div>
</article>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: ''
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


<!-- chrome Firefox 中文锚点定位失效-->
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<!-- smooth scroll behavior polyfill  -->
<script type="text/javascript" src="/js/smoothscroll.js"></script>
<script>
        $('#toc').on('click','a',function(a){
            // var isChrome = window.navigator.userAgent.indexOf("Chrome") !== -1;
            // console.log(window.navigator.userAgent,isChrome)
                // if(isChrome) {
                    // console.log(a.currentTarget.outerHTML);
                    // console.log($(a.currentTarget).attr("href"));
                    //跳转到指定锚点
                    // document.getElementById(a.target.innerText.toLowerCase()).scrollIntoView(true);
                    document.getElementById($(a.currentTarget).attr("href").replace("#","")).scrollIntoView({behavior: 'smooth' });
                // }
        })  
</script>


    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                
				
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/songzblink">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 宋正兵 2021 
                    <br>
                    Theme by <a href="http://www.huweihuang.com">Huwei Huang</a>
                    re-Ported by <a href="https://github.com/ztygalaxy">ztygalaxy</a>
					
					<br>
                    <a href="http://www.beian.miit.gov.cn/" style="color: gray">浙ICP备2021018896号</a>
					<br>
					<!-- <p class="copyright text-muted" style="margin-top: 5px"> -->
						<img src="../../img/备案图标.png"/>
						<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null" style="color: gray">null</a>
					<!-- </p> -->
					
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("zbsong.top/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="zbsong.top/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>

</html>
