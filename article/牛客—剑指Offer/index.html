<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/logo.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          牛客—剑指Offer - 宋正兵的博客 | zbsong Blog
        
    </title>

    <link rel="canonical" href="zbsong.top/article/牛客—剑指Offer/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('https://api.dujin.org/bing/1920.php')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#algorithm" title="algorithm">algorithm</a>
                            
                        </div>
                        <h1>牛客—剑指Offer</h1>
                        <!-- <h2 class="subheading">记录了在牛客刷题的答案</h2> -->
                        <span class="meta">
                            宋正兵 更新 on
                            2021-06-08
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">songzblink</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">主页</a>
                    </li>
					<li>
                        <a href="/archive/">归档</a>
                    </li>
					<li>
                        <a href="/tags/">标签</a>
                    </li>
					<li>
                        <a href="/about/">关于</a>
                    </li>
					<!--
					修改about在前面的问题
                    
                        
                    
                        
                        <li>
                            <a href="/about/">关于</a>
                        </li>
                        
                    
                        
                        <li>
                            <a href="/archive/">归档</a>
                        </li>
                        
                    
                        
                        <li>
                            <a href="/tags/">标签</a>
                        </li>
                        
                    
                    -->
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
	// querySelector 获取文档中 id="demo" 的元素
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				
                <blockquote>
<font id="qusnum"></font>

<script src="/js/jquery.min.js"></script>
<script language="javascript" type="text/javascript">
$(document).ready(function(){
    var i=$('h3').size();
    var years = {};
 var myDate = new Date(); 
 var year = myDate.getFullYear();
 var month = myDate.getMonth()+1;
 var day = myDate.getDate();
 var newDay = year + "年" + month + "月" + day + "日";
    var str = '截至' + newDay +  '，已收录' + i + '道题目。';
    document.getElementById('qusnum').innerHTML = str;
});
</script>

</blockquote>
<p><a href="https://www.nowcoder.com/ta/coding-interviews" target="_blank" rel="noopener">剑指Offer_在线编程+题解_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="jz1-二维数组中的查找"><a href="#JZ1-二维数组中的查找" class="headerlink" title="JZ1 二维数组中的查找"></a>JZ1 二维数组中的查找</h3><p>题目大意：</p>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>思路：</p>
<p>左下开始找，对于左下角的元素 m，m 已经是该行的最小值，该列的最大值</p>
<ul>
<li>target &gt; m ==》 m 是该列最大的元素，想要更大只能考虑右边一列</li>
<li>target &lt; m ==》 m 是该行最小的元素，想要更小只能考虑上边一行</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = array.length - <span class="number">1</span>, n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || target &gt; array[m][array[<span class="number">0</span>].length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左下开始找，对于左下角的元素m，m已经是该行的最小值，该列的最大值</span></span><br><span class="line">        <span class="comment">// target &gt; m ==》 m是该列最大的元素，想要更大只能考虑右边一列</span></span><br><span class="line">        <span class="comment">// target &lt; m ==》 m是该行最小的元素，想要更小只能考虑上边一行</span></span><br><span class="line">        <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &lt; array[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == array[m][n]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; array[m][n]) &#123;</span><br><span class="line">                n++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                m--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz2-替换空格"><a href="#JZ2-替换空格" class="headerlink" title="JZ2 替换空格"></a>JZ2 替换空格</h3><p>题目大意：</p>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p>思路：</p>
<p>利用 StringBuffer 来拼接，遇上空格就替换成 “%20”。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : s.toCharArray()) &#123;</span><br><span class="line">            sb.append(ch == <span class="string">' '</span>? <span class="string">"%20"</span> : ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz3-从尾到头打印链表"><a href="#JZ3-从尾到头打印链表" class="headerlink" title="JZ3 从尾到头打印链表"></a>JZ3 从尾到头打印链表</h3><p>题目大意：</p>
<p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<p>思路：</p>
<p>翻转链表 + List 插入：翻转链表然后再插入到 ArrayList 当中。之所以不用 list.add(0, listNode) 是因为 ArrayList 插入的时间复杂度是 $O(n)$，n 个元素插入就是 $O(n^{2})$，翻转链表后再插入会快些。</p>
<p>方法二：类似于二叉树的中序遍历时找到第一个节点，进行递归。</p>
<p>代码：</p>
<p>方法一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        listNode = reverse(listNode);</span><br><span class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ListNode headNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode nextNode = listNode.next;</span><br><span class="line">            listNode.next = headNode.next;</span><br><span class="line">            headNode.next = listNode;</span><br><span class="line">            listNode = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            printListFromTailToHead(listNode.next);</span><br><span class="line">            resList.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz4-重建二叉树"><a href="#JZ4-重建二叉树" class="headerlink" title="JZ4 重建二叉树"></a>JZ4 重建二叉树</h3><p>题目大意：</p>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p>思路：</p>
<p>模拟我们根据前序和中序构建二叉树的过程。</p>
<p>根据前序遍历和中序遍历重建二叉树：<br>1、根据前序序列第一个结点确定根结点<br>2、根据根结点在中序序列中的位置分割出左右两个子序列<br>3、对左子树和右子树分别递归使用同样的方法继续分解</p>
<p>前序遍历的顺序就是我们从中序遍历中每次找到当前子树根节点的顺序 1-&gt;2-&gt;3…<br>中序遍历中被我们每次选择的根节点划分为 [左子树, root, 右子树]<br>同样的 左子树 和 右子树 当中也符合上述规则<br>于是递归的进行</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre.length == <span class="number">0</span> || in.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 在中序中找到前序的根</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[<span class="number">0</span>] == in[i]) &#123;</span><br><span class="line">                <span class="comment">// 左子树</span></span><br><span class="line">                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, <span class="number">1</span>, i + <span class="number">1</span>), Arrays.copyOfRange(in, <span class="number">0</span>, i));</span><br><span class="line">                <span class="comment">// 右子树</span></span><br><span class="line">                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + <span class="number">1</span>, pre.length), Arrays.copyOfRange(in, i + <span class="number">1</span>, in.length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz5-用两个栈实现队列"><a href="#JZ5-用两个栈实现队列" class="headerlink" title="JZ5 用两个栈实现队列"></a>JZ5 用两个栈实现队列</h3><p>题目大意：</p>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<p>思路：</p>
<ul>
<li>入队：都往 stack1 中入栈</li>
<li>出队：<ul>
<li>如果 stack2 不为空，从 stack2 中出栈</li>
<li>如果 stack2 为空，将 stack1 全部迁移到 stack2，再从 stack2 出栈</li>
</ul>
</li>
</ul>
<p>即最先入队的元素一定会放在 stack2 的栈顶或者 stack1 的栈底，最后入队的元素一定会在 stack1 的栈顶或者是 stack2 的栈底。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz6-旋转数组的最小数字"><a href="#JZ6-旋转数组的最小数字" class="headerlink" title="JZ6 旋转数组的最小数字"></a>JZ6 旋转数组的最小数字</h3><p>题目大意：</p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>思路：</p>
<p>二分。我们要找最小的数字，且数组是升序的，左边小右边大，所以选择和右边的边界比较，当然左边也行，只不过右边方便些。</p>
<ul>
<li><code>array[mid] &gt; array[right]</code>：最小值在 <code>(mid,right]</code> 内出现，所以 <code>left = mid + 1</code>；</li>
<li><code>array[mid] &lt; array[right]</code>：最小值在 <code>[left,mid]</code> 内出现，注意这里的 <code>array[mid]</code> 也有可能是最小值，所以 <code>right = mid</code>；</li>
<li><code>array[mid] == array[right]</code>：因为是升序的，右边的会大一些，所以直接去掉 <code>array[right]</code> 来排除一个可能的选项，继续进行二分查找。</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>, left = <span class="number">0</span>, right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &gt; array[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; array[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz7-斐波那契数列"><a href="#JZ7-斐波那契数列" class="headerlink" title="JZ7 斐波那契数列"></a>JZ7 斐波那契数列</h3><p>没什么好说的。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz8-跳台阶"><a href="#JZ8-跳台阶" class="headerlink" title="JZ8  跳台阶"></a>JZ8  跳台阶</h3><p>题目大意：</p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// f(n) = f(n-1) + f(n-2)</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span> || target == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jumpFloor(target - <span class="number">1</span>) + jumpFloor(target - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化：因为只用到了上一个状态 f(n-1) 和上上一个状态 f(n-2)，所以可以把递归修改为空间复杂度为 $O(1)$ 的递推。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// f(n) = f(n-1) + f(n-2)</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="comment">// f(i) = f(i-1) + f(i-2)</span></span><br><span class="line">            a = a + b;</span><br><span class="line">            <span class="comment">// f(i-1) = f(i) - f(i-2)</span></span><br><span class="line">            b = a - b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz9-变态跳台阶"><a href="#JZ9-变态跳台阶" class="headerlink" title="JZ9 变态跳台阶"></a>JZ9 变态跳台阶</h3><p>题目大意：</p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p>思路：</p>
<p>对于第 n 级的台阶，跳法有 n+1 种，即从第 0 阶跳 n 级台阶，从第 1 阶跳 n-1 级台阶……，于是就有 $f(n) = \sum\limits_{i = 0}^{n-1}f(i)$ ，如代码一所示。</p>
<p><strong>优化</strong> $f(0)=1$，$f(1)=f(0)=1$，$f(2)=f(0)+f(1)=2$，$f(3)=f(0)+f(1)+f(2)=2*f(2)=4$……列出多项后发现，这其实是一个等比数列，有 $f(n)=2^{n-1}$，于是可以优化为代码二。</p>
<p>代码：</p>
<p>代码一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码二</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (target - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz10-矩形覆盖"><a href="#JZ10-矩形覆盖" class="headerlink" title="JZ10 矩形覆盖"></a>JZ10 矩形覆盖</h3><p>题目大意：</p>
<p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<p>思路：</p>
<p>扩充矩形的方法一共有两种，1）竖着摆放一个，矩形增加 2*1；2）横着摆放两个，矩形增加 2*2。假设我们现在要覆盖一个 2*n 的矩形，有多少种方法？</p>
<p>对于第一种扩充方法，需要从 2*(n-1) 的矩形增加一个竖着摆放的小矩形；对于第二种扩充方法，需要从 2*(n-2) 的矩形增加两个横着摆放的小矩形。</p>
<p>于是覆盖一个 2*n 的矩形的方法数 $f(n)=f(n-1) + f(n-2)$  </p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rectCover(target - <span class="number">1</span>) + rectCover(target - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz11-二进制中1的个数"><a href="#JZ11-二进制中1的个数" class="headerlink" title="JZ11 二进制中1的个数"></a>JZ11 二进制中1的个数</h3><p>题目大意：</p>
<p>输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p>
<p>思路：</p>
<p>每次都通过位运算移除末尾的最后一个 0，统计操作的次数，直到这个数为 0，操作的次数就是 1 的个数。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz12-数值的整数次方"><a href="#JZ12-数值的整数次方" class="headerlink" title="JZ12 数值的整数次方"></a>JZ12 数值的整数次方</h3><p>题目大意：</p>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p>保证base和exponent不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面0的位数。  </p>
<p>思路：</p>
<p>快速幂的思路。先将 exponent 转换为正数，并记录原始的正负状态 isNegative。然后快速幂的思想是：如果指数是偶数 2n，那么就分解成 $num^{n} <em> num^{n}$，如果指数是奇数，那么就分解成 $num^{n-1}</em>num$，转换为偶数的情况处理。最后根据 isNegative 的值判断是否需要把结果写成 $\frac{1}{res}$。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快速幂</span></span><br><span class="line">        <span class="keyword">boolean</span> isNegative = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// exponent 转换为正数的原因为：</span></span><br><span class="line">        <span class="comment">// 在 exponent 为奇数时，负数减1，越减越小了</span></span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            isNegative = <span class="keyword">true</span>;</span><br><span class="line">            exponent = - exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> res = getPower(base, exponent);</span><br><span class="line">        <span class="keyword">return</span> isNegative ? <span class="number">1</span> / res : res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPower</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (exponent == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> temp = getPower(base, exponent / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> temp * temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getPower(base, exponent - <span class="number">1</span>) * base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz13-调整数组顺序使奇数位于偶数前面"><a href="#JZ13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="JZ13 调整数组顺序使奇数位于偶数前面"></a>JZ13 调整数组顺序使奇数位于偶数前面</h3><p>题目大意：</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>思路：</p>
<p>冒泡排序，将判断条件从大小换成奇偶</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reOrderArray (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// 冒泡</span></span><br><span class="line">        <span class="keyword">int</span> n = array.length;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; changed; i--) &#123;</span><br><span class="line">            changed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; array[j + <span class="number">1</span>] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    changed = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                    array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>狗日的牛客改判题条件了，冒泡过不了，换成将奇数往前移，偶数放到新建数组 odd[] 中，然后再将 odd[] 数组中的内容复制到 array[] 中奇数序列的后面。</p>
</blockquote>
<h3 id="jz14-链表中倒数第k个结点"><a href="#JZ14-链表中倒数第k个结点" class="headerlink" title="JZ14 链表中倒数第k个结点"></a>JZ14 链表中倒数第k个结点</h3><p>题目大意：</p>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
<p>如果该链表长度小于k，请返回空。</p>
<p>思路：</p>
<p>快慢指针。如果输出倒数第 1 个结点，则快指针应该比慢指针快一个结点，这样当快指针指向 null 的时候，慢指针刚好指向最后一个结点。那么可以划分为以下几步：</p>
<ul>
<li>快指针先走 k 步</li>
<li>快慢指针同时往后走，直到快指针为 null</li>
<li>返回慢指针</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode slowNode = pHead, fastNode = pHead;</span><br><span class="line">        <span class="keyword">while</span> (fastNode != <span class="keyword">null</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            k--;</span><br><span class="line">            fastNode = fastNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fastNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fastNode = fastNode.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k &gt; <span class="number">0</span> ? <span class="keyword">null</span> : slowNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz15-反转链表"><a href="#JZ15-反转链表" class="headerlink" title="JZ15 反转链表"></a>JZ15 反转链表</h3><p>题目大意：</p>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
<p>思路：</p>
<p>头插，没啥好说的。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummyNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 头插</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = dummyNode.next;</span><br><span class="line">            dummyNode.next = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz16-合并两个排序的链表"><a href="#JZ16-合并两个排序的链表" class="headerlink" title="JZ16 合并两个排序的链表"></a>JZ16 合并两个排序的链表</h3><p>题目大意：</p>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        ListNode dummyNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curNode = dummyNode;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">                curNode.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curNode.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curNode.next = (list1 == <span class="keyword">null</span> ? list2 : list1);</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz17-树的子结构"><a href="#JZ17-树的子结构" class="headerlink" title="JZ17 树的子结构"></a>JZ17 树的子结构</h3><p>题目大意：</p>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p>思路：</p>
<p>遍历二叉树 A，以每一个节点作为子树的根节点和二叉树 B 进行比较 <code>isSubTree(root1, root2)</code>，判断以当前节点为根节点的子树和二叉树 B 是否相同。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 空树不是任意一个树的子结构 || root1为空那么肯定不包含root2结构</span></span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="keyword">null</span> || root1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSubTree(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubTree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// root2遍历到了空节点，不用管root1此时空不空</span></span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// root1为空，root2不为空，肯定不是</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root1.val == root2.val &amp;&amp;</span><br><span class="line">            isSubTree(root1.left, root2.left) &amp;&amp;</span><br><span class="line">            isSubTree(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz18-二叉树的镜像"><a href="#JZ18-二叉树的镜像" class="headerlink" title="JZ18 二叉树的镜像"></a>JZ18 二叉树的镜像</h3><p>题目大意：</p>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Mirror</span> <span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode tempNode = pRoot.left;</span><br><span class="line">            pRoot.left = pRoot.right;</span><br><span class="line">            pRoot.right = tempNode;</span><br><span class="line">            Mirror(pRoot.left);</span><br><span class="line">            Mirror(pRoot.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz19-顺时针打印矩阵"><a href="#JZ19-顺时针打印矩阵" class="headerlink" title="JZ19  顺时针打印矩阵"></a>JZ19  顺时针打印矩阵</h3><p>题目大意：</p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字.</p>
<p>思路：</p>
<p>设置上下左右边界，按照顺序去打印，没打印一行或者一列则把相应的边界挪动一位。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].length - <span class="number">1</span>, up = <span class="number">0</span>, down = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 顶部那行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">                resList.add(matrix[up][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            up++;</span><br><span class="line">            <span class="keyword">if</span> (up &gt; down) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右边那列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = up; i &lt;= down; i++) &#123;</span><br><span class="line">                resList.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下边那行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = right;i &gt;= left; i--) &#123;</span><br><span class="line">                resList.add(matrix[down][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            down--;</span><br><span class="line">            <span class="keyword">if</span> (up &gt; down) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左边那列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = down; i &gt;= up; i--) &#123;</span><br><span class="line">                resList.add(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz20-包含min函数的栈"><a href="#JZ20-包含min函数的栈" class="headerlink" title="JZ20  包含min函数的栈"></a>JZ20  包含min函数的栈</h3><p>题目大意：</p>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数。</p>
<p>思路：</p>
<p>stack1 正常入栈出栈，stack2 在 stack1 入栈的时候陪着入栈最小元素。这样在同样深度的时候就能直接从 stack2 中拿到最小元素。</p>
<p>也可以用内部类 Node (int val, int minVal)，让每一个元素不仅存储原来的值，还存储从自己到最先入队的元素中的最小值。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty()) &#123;</span><br><span class="line">            stack2.push(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node &lt; stack2.peek()) &#123;</span><br><span class="line">                stack2.push(node);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack2.push(stack2.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1.pop();</span><br><span class="line">        stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz21-栈的压入-弹出序列"><a href="#JZ21-栈的压入、弹出序列" class="headerlink" title="JZ21 栈的压入、弹出序列"></a>JZ21 栈的压入、弹出序列</h3><p>题目大意：</p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。</p>
<p>思路：</p>
<p>直接新建一个栈去模拟这个过程，如果栈不为空且栈顶元素等于要出栈的元素，那么出栈。最后判断栈是否为空即可。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : pushA) &#123;</span><br><span class="line">            stack.push(num);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popA[i]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz22-从上往下打印二叉树"><a href="#JZ22-从上往下打印二叉树" class="headerlink" title="JZ22 从上往下打印二叉树"></a>JZ22 从上往下打印二叉树</h3><p>题目大意：</p>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p>思路：</p>
<p>层序遍历。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resList;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode curNode = queue.poll();</span><br><span class="line">            resList.add(curNode.val);</span><br><span class="line">            <span class="keyword">if</span> (curNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(curNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(curNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz23-二叉搜索树的后序遍历序列"><a href="#JZ23-二叉搜索树的后序遍历序列" class="headerlink" title="JZ23 二叉搜索树的后序遍历序列"></a>JZ23 二叉搜索树的后序遍历序列</h3><p>题目大意：</p>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。</p>
<p>思路：</p>
<p>后序遍历的顺序是左右根，反映到二叉搜索树中会有左子树的所有节点小于根节点小于右子树的所有节点。所以我们可以根据这个性质，将后序遍历序列根据根节点的值划分为左子树的后序序列和右子树的后序序列，满足左子树的后序序列小于根节点，右子树的后序序列大于根节点。递归这个判断的过程。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence == <span class="keyword">null</span> || sequence.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isBST(sequence, <span class="number">0</span>, sequence.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">(<span class="keyword">int</span>[] seq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root = seq[end];</span><br><span class="line">        <span class="keyword">int</span> split = start;</span><br><span class="line">        <span class="comment">// 找到左右子树分界</span></span><br><span class="line">        <span class="keyword">for</span> (; split &lt; end &amp;&amp; seq[split] &lt; root; split++);</span><br><span class="line">        <span class="comment">// 右子树中若有小于根节点的，直接返回false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = split; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq[i] &lt; root) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isBST(seq, start, split - <span class="number">1</span>) &amp;&amp; isBST(seq, split, end - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz24-二叉树中和为某一值的路径"><a href="#JZ24-二叉树中和为某一值的路径" class="headerlink" title="JZ24 二叉树中和为某一值的路径"></a>JZ24 二叉树中和为某一值的路径</h3><p>题目大意：</p>
<p>输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p>思路：</p>
<p>DFS 思想，从根节点开始往下搜索，每遍历一个节点就将其加入路径当中。如果当前节点是叶子节点，则检查当前路径和是否和 targer 相等，相等则找到一条路径。</p>
<blockquote>
<p>需要注意的地方：如果按照 <code>if (root == null)</code> 的时候再去检查路径和是否和 target 相等，不能及时的从当前叶子节点退出，会进入叶子节点的左右子节点，造成两次判断生效加入 resList 路径集合操作，导致答案重复。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; tempList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        checkPath(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPath</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + root.val == target) &#123;</span><br><span class="line">                tempList.add(root.val);</span><br><span class="line">                resList.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">                tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剪枝，还没走到叶子节点就大于targer，继续走只会让sum更大</span></span><br><span class="line">        <span class="keyword">if</span> (sum + root.val &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tempList.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkPath(root.left, sum + root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkPath(root.right, sum + root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz25-复杂链表的复制"><a href="#JZ25-复杂链表的复制" class="headerlink" title="JZ25 复杂链表的复制"></a>JZ25 复杂链表的复制</h3><p>题目大意：</p>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点</p>
<p>思路：</p>
<p>分为两步：</p>
<ol>
<li><p>【复制】为所有节点创建备份，存到 map 中，此时复制出来的节点的 next 和 random 字段都为 null</p>
</li>
<li><p>【完善链表结构】根据原始链表的结构，构建复制出来的新链表的结构。</p>
<p>比如原始链表的节点 A，对应复制出来的节点 A*。A 的next是 B，random 是 C，那么对应的 A* 的 next 是 B*，random 是 C*。如何找到 B* 和 C* 呢，就是通过 map 来获取，因为在第一步的时候就把每个节点对应的复制节点存放到了 map 当中。</p>
</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        RandomListNode curNode = pHead;</span><br><span class="line">        <span class="comment">// 将所有值都存入map，每一个结点都被new了【复制】</span></span><br><span class="line">        <span class="keyword">while</span> (curNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(curNode, <span class="keyword">new</span> RandomListNode(curNode.label));</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完善链表的结构</span></span><br><span class="line">        RandomListNode target = <span class="keyword">new</span> RandomListNode(pHead.label);</span><br><span class="line">        curNode = pHead;</span><br><span class="line">        RandomListNode p = target;</span><br><span class="line">        <span class="comment">// 移动 p 和 curNode 来完善链表的结构</span></span><br><span class="line">        <span class="keyword">while</span> (curNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.next = map.get(curNode.next);</span><br><span class="line">            p.random = map.get(curNode.random);</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz26-二叉搜索树与双向链表"><a href="#JZ26-二叉搜索树与双向链表" class="headerlink" title="JZ26  二叉搜索树与双向链表"></a>JZ26  二叉搜索树与双向链表</h3><p>题目大意：</p>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p>思路：</p>
<p>二叉搜索树的一个性质之一是：中序遍历的顺序是有序的，所以我们可以明确的是这道题目需要用到中序遍历。将节点的左指针指向中序遍历的前一个节点，右指针指向中序遍历的后一个节点。</p>
<p>我们可以利用一个 preNode 节点来完成这件事情。当我们遍历到某个节点的时候，它的左指针应该指向它的前一个节点 preNode，同时将 preNode 节点的右指针指向当前节点，完成前一个节点的左右指针调整。等遍历下一个节点的时候，再来完善当前节点的右指针。所以需要把当前节点左右 preNode 节点，去处理下一个节点。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode targetNode = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode preNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRootOfTree == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        <span class="keyword">if</span> (targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            targetNode = pRootOfTree;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            preNode.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = preNode;</span><br><span class="line">        &#125;</span><br><span class="line">        preNode = pRootOfTree;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> targetNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz27-字符串的排列"><a href="#JZ27-字符串的排列" class="headerlink" title="JZ27  字符串的排列"></a>JZ27  字符串的排列</h3><p>题目大意：</p>
<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列</p>
<p>思路：【排列树】</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20200427/284295_1587983313815_36EC2C8836C9F164B867402474E0DC4E" alt=""></p>
<p>从上图可以看到，如果我们先固定 A 不懂，然后交换 B 与 C，可以得到 ABC 和 ACB，同样的对于 B、C 是同样的道理。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;String&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] arr = str.toCharArray();</span><br><span class="line">            backtrace(arr, <span class="number">0</span>, resList);</span><br><span class="line">            Collections.sort(resList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> t, ArrayList&lt;String&gt; resList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t &gt;= arr.length) &#123;</span><br><span class="line">            String tempStr = String.copyValueOf(arr);</span><br><span class="line">            <span class="keyword">if</span> (!resList.contains(tempStr)) &#123;</span><br><span class="line">                resList.add(tempStr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt; arr.length; i++) &#123;</span><br><span class="line">            swap(arr, t, i);</span><br><span class="line">            backtrace(arr, t + <span class="number">1</span>, resList);</span><br><span class="line">            swap(arr, t, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz28-数组中出现次数超过一半的数字"><a href="#JZ28-数组中出现次数超过一半的数字" class="headerlink" title="JZ28  数组中出现次数超过一半的数字"></a>JZ28  数组中出现次数超过一半的数字</h3><p>题目大意：</p>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>思路：</p>
<ul>
<li>从前往后遍历，记录当前候选数字 condition 出现的次数 count，相同则出现次数 +1，不相同则 -1。</li>
<li>当次数 count 被减到 0 时，表示从 0 到当前元素的区间内，候选数字 condition 不是众数。</li>
<li>最后留下来的候选数字 condition 有可能是众数，进行验证</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 该方法是基于如果存在众数，那么遍历数组之后众数k出现的次数一定是大于数组长度一半的</span></span><br><span class="line">        <span class="comment">// 从前往后遍历，记录当前候选数字condition出现的次数count</span></span><br><span class="line">        <span class="comment">// 相同则出现次数+1，不相同则-1</span></span><br><span class="line">        <span class="comment">// 当次数count被减到0时，表示从0到当前元素的区间内，候选数字condition不是众数</span></span><br><span class="line">        <span class="comment">// 最后留下来的候选数字condition有可能是众数，进行验证</span></span><br><span class="line">        <span class="keyword">int</span> condition = -<span class="number">1</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                condition = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num == condition) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验证</span></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == condition) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt; array.length / <span class="number">2</span> ? condition : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz29-最小的k个数"><a href="#▲JZ29-最小的k个数" class="headerlink" title="▲JZ29 最小的k个数"></a>▲JZ29 最小的k个数</h3><p>题目大意：</p>
<p>给定一个数组，找出其中最小的K个数。</p>
<p>思路：</p>
<p>堆排序。构建好堆后，每次将最小的元素交换到数组的末尾，同时加入到结果集合中。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= input.length) &#123;</span><br><span class="line">        	heapSort(input, k, resList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, ArrayList&lt;Integer&gt; resList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建堆，从第一个非叶子节点开始，从下到上，从右往左</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length / <span class="number">2</span> -<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调整堆结构，并加入结果集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            resList.add(arr[<span class="number">0</span>]);</span><br><span class="line">            swap(arr, <span class="number">0</span>, arr.length - i - <span class="number">1</span>);</span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, arr.length - i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取出当前元素</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="comment">// 从第i个节点的左孩子节点开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span> * i + <span class="number">1</span>; k &lt; length; k = <span class="number">2</span> * k + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 右孩子更小则指向右孩子节点</span></span><br><span class="line">            <span class="keyword">if</span> (k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &gt; arr[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果子节点小于父节点（当前元素），则将子节点赋值给父节点</span></span><br><span class="line">            <span class="comment">// 子节点最后由temp来填充</span></span><br><span class="line">            <span class="comment">// 【从这里能看出来是小根堆】</span></span><br><span class="line">            <span class="keyword">if</span> (arr[k] &lt; temp) &#123;</span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将temp放置到最终的位置</span></span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz30-连续子数组的最大和"><a href="#JZ30-连续子数组的最大和" class="headerlink" title="JZ30 连续子数组的最大和"></a>JZ30 连续子数组的最大和</h3><p>题目大意：</p>
<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>思路：</p>
<p>正数负数都有的情况下，连续子数组相加小于零的时候，一定不会是最大子数组。此时可以直接将 sum 清零，开始重新计算子数组的和。</p>
<p>但是当数组元素全是负数的时候该方法就存在问题，得到的结果为 0。解决的办法是 0 + 当前数字，然后先与最大子数组和比较，再去判断小于零则清零。这样做能够在求和的同时，把当前为负数的元素拎出来单独比较。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, maxSum = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; maxSum) &#123;</span><br><span class="line">                maxSum = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz31-整数中1出现的次数从1到n整数中1出现的次数"><a href="#JZ31-整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="JZ31 整数中1出现的次数（从1到n整数中1出现的次数）"></a>JZ31 整数中1出现的次数（从1到n整数中1出现的次数）</h3><p>题目大意：</p>
<p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数</p>
<p>思路：</p>
<p><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/" target="_blank" rel="noopener">面试题43. 1～n 整数中 1 出现的次数（清晰图解） - 1～n 整数中 1 出现的次数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/</span></span><br><span class="line">        <span class="keyword">int</span> oneFreq = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> digit = <span class="number">1</span>; digit &lt;= n; digit *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = n / digit % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> high = n / digit / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> low = n % digit;</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">0</span>) &#123;</span><br><span class="line">                oneFreq += high * digit;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">                oneFreq += high * digit + low + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                oneFreq += (high + <span class="number">1</span>) * digit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oneFreq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz32-把数组排成最小的数"><a href="#JZ32-把数组排成最小的数" class="headerlink" title="JZ32  把数组排成最小的数"></a>JZ32  把数组排成最小的数</h3><p>题目大意：</p>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p>思路：</p>
<p>把问题转化为：如何给这个数组排序，使其看做一个数字的时候最小。</p>
<p>两个字符串 s1, s2，将它们拼接起来看 s1+s2 和 s2+s1 哪个大，如果 s1+s2 大，那么说明 s2 应该放前面。按照我们定义的标准排好序，然后依次拼接起来就是答案。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numbers.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> s1 = Integer.valueOf(numbers[i]+ <span class="string">""</span> +numbers[j]);</span><br><span class="line">                <span class="keyword">int</span> s2 = Integer.valueOf(numbers[j]+ <span class="string">""</span> +numbers[i]);</span><br><span class="line">                <span class="keyword">if</span> (s1 &gt; s2) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">                    numbers[i] = numbers[j];</span><br><span class="line">                    numbers[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拼接</span></span><br><span class="line">        String res = <span class="keyword">new</span> String(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : numbers) &#123;</span><br><span class="line">            res += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz33-丑数"><a href="#▲JZ33-丑数" class="headerlink" title="▲JZ33  丑数"></a>▲JZ33  丑数</h3><p>题目大意：</p>
<p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<p>思路：</p>
<p>首先从丑数的定义我们知道，一个丑数的因子只有 2，3，5，那么丑数 $p = 2 ^ x <em> 3 ^ y </em> 5 ^ z$，换句话说一个丑数一定由另一个丑数乘以 2 或者乘以 3 或者乘以 5 得到，那么我们从 1 开始乘以 2，3，5，就得到 2，3，5 三个丑数，在从这三个丑数出发乘以 2，3，5 就得到 4，6，10，6，9，15，10，15，25 九个丑数，我们发现这种方法得到重复的丑数，而且我们题目要求第 N 个丑数，这样的方法得到的丑数也是无序的。那么我们可以维护三个队列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">（1）丑数数组： 1</span><br><span class="line">乘以2的队列：2</span><br><span class="line">乘以3的队列：3</span><br><span class="line">乘以5的队列：5</span><br><span class="line">选择三个队列头最小的数2加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</span><br><span class="line">（2）丑数数组：1,2</span><br><span class="line">乘以2的队列：4</span><br><span class="line">乘以3的队列：3，6</span><br><span class="line">乘以5的队列：5，10</span><br><span class="line">选择三个队列头最小的数3加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</span><br><span class="line">（3）丑数数组：1,2,3</span><br><span class="line">乘以2的队列：4,6</span><br><span class="line">乘以3的队列：6,9</span><br><span class="line">乘以5的队列：5,10,15</span><br><span class="line">选择三个队列头里最小的数4加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</span><br><span class="line">（4）丑数数组：1,2,3,4</span><br><span class="line">乘以2的队列：6，8</span><br><span class="line">乘以3的队列：6,9,12</span><br><span class="line">乘以5的队列：5,10,15,20</span><br><span class="line">选择三个队列头里最小的数5加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</span><br><span class="line">（5）丑数数组：1,2,3,4,5</span><br><span class="line">乘以2的队列：6,8,10，</span><br><span class="line">乘以3的队列：6,9,12,15</span><br><span class="line">乘以5的队列：10,15,20,25</span><br><span class="line">选择三个队列头里最小的数6加入丑数数组，但我们发现，有两个队列头都为6，所以我们弹出两个队列头，同时将12,18,30放入三个队列；</span><br><span class="line">……………………</span><br></pre></td></tr></table></figure>
<p><strong>疑问：</strong></p>
<p>1.为什么分三个队列？</p>
<p>丑数数组里的数一定是有序的，因为我们是从丑数数组里的数乘以 2，3，5 选出的最小数，一定比以前未乘以 2，3，5 大，同时对于三个队列内部，按先后顺序乘以 2，3，5 分别放入，所以同一个队列内部也是有序的；</p>
<p>2.为什么比较三个队列头部最小的数放入丑数数组？</p>
<p>因为三个队列是有序的，所以取出三个头中最小的，等同于找到了三个队列所有数中最小的。</p>
<p><strong>实现思路：</strong></p>
<p>我们没有必要维护三个队列，只需要记录三个指针显示到达哪一步；“|” 表示指针，arr 表示丑数数组；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">（1）1</span><br><span class="line">|2</span><br><span class="line">|3</span><br><span class="line">|5</span><br><span class="line">目前指针指向0,0,0，队列头arr[0] * 2 = 2,  arr[0] * 3 = 3,  arr[0] * 5 = 5</span><br><span class="line">（2）1 2</span><br><span class="line">2 |4</span><br><span class="line">|3 6</span><br><span class="line">|5 10</span><br><span class="line">目前指针指向1,0,0，队列头arr[1] * 2 = 4,  arr[0] * 3 = 3, arr[0] * 5 = 5</span><br><span class="line">（3）1 2 3</span><br><span class="line">2| 4 6</span><br><span class="line">3 |6 9</span><br><span class="line">|5 10 15</span><br><span class="line">目前指针指向1,1,0，队列头arr[1] * 2 = 4,  arr[1] * 3 = 6, arr[0] * 5 = 5</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>, p3 = <span class="number">0</span>, p5 = <span class="number">0</span>; <span class="comment">// 三个潜在成为最小丑数的位置</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">            <span class="comment">// 找到该轮次最小的那个丑数</span></span><br><span class="line">            res[i] = Math.min(res[p2] * <span class="number">2</span>, Math.min(res[p3] * <span class="number">3</span>, res[p5] * <span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span> (res[i] == res[p2] * <span class="number">2</span>) &#123;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res[i] == res[p3] * <span class="number">3</span>) &#123;</span><br><span class="line">                p3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res[i] == res[p5] * <span class="number">5</span>) &#123;</span><br><span class="line">                p5++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[index - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz34-第一个只出现一次的字符位置"><a href="#JZ34-第一个只出现一次的字符位置" class="headerlink" title="JZ34 第一个只出现一次的字符位置"></a>JZ34 第一个只出现一次的字符位置</h3><p>题目大意：</p>
<p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）</p>
<p>思路：</p>
<p>已知 ASCII 码表字符一共有 128 个。那么我们可以维护一个 count[] 数组，用来记录字符串 str 中每个字符出现的次数。对于字符 ch 有：</p>
<ul>
<li><code>count[ch] == 0</code>，字符 ch 没有出现过；</li>
<li><code>count[ch] == 1</code>，字符 ch 出现过 1 次；</li>
<li><code>count[ch] &gt; 2</code>，字符 ch 出现过多次。</li>
</ul>
<p>于是我们在统计完字符串 str 中字符出现的次数后，在根据字符串 str 中字符出现的顺序去找到第一个只出现一次的字符的位置即可。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0：没出现 1：出现过1次 &gt;1：出现过多次</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            count[str.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[str.charAt(i)] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz35-数组中的逆序对"><a href="#▲JZ35-数组中的逆序对" class="headerlink" title="▲JZ35  数组中的逆序对"></a>▲JZ35  数组中的逆序对</h3><p>题目大意：</p>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。</p>
<p>思路：</p>
<p>利用归并排序的思想，递归划分整个区间为基本相等的左右区间。比如需要合并的两个有序区间为 [3, 4] 和 [1, 2]，在合并的过程中发现 $3 &gt; 1$，说明 3 后面的所有数都是大于 1 的，对于 2 来讲同理。所以我们在合并的时候可以利用这个规则，假设合并有序区间 A 和有序区间 B，长度分别为 n 和 m，有：</p>
<ul>
<li><code>A[i] &lt; B[j]</code>，说明没有逆序对发生。</li>
<li><code>A[i] &gt; B[j]</code>，说明 <code>A[i...n]</code> 都大于 <code>B[j]</code>，构成逆序对，数量为 <code>n - i + 1</code>。</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(array, start, mid);</span><br><span class="line">        mergeSort(array, mid + <span class="number">1</span>, end);</span><br><span class="line">        merge(array, start, end, mid);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p1 = start, p2 = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[p1] &lt;= array[p2]) &#123;</span><br><span class="line">                <span class="comment">// 前面的元素小于后面的元素，不能构成逆序对</span></span><br><span class="line">                temp[k++] = array[p1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 前面的元素大于后面的元素</span></span><br><span class="line">                <span class="comment">// 那么前面的元素以及之后的元素（[p1, mid]）都能和p2构成逆序对</span></span><br><span class="line">                temp[k++] = array[p2++];</span><br><span class="line">                count = (count + (mid - p1 + <span class="number">1</span>)) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">            temp[k++] = array[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= end) &#123;</span><br><span class="line">            temp[k++] = array[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            array[i + start] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz36-两个链表的第一个公共结点"><a href="#JZ36-两个链表的第一个公共结点" class="headerlink" title="JZ36  两个链表的第一个公共结点"></a>JZ36  两个链表的第一个公共结点</h3><p>题目大意：</p>
<p>输入两个无环的单链表，找出它们的第一个公共结点。</p>
<p>思路：</p>
<p>指针 p1 走 a 步到达第一个公共节点，指针 p2 走 b 步到达公共节点，那么如果我们能够让 p1 到第一个公共节点的距离等于 p2 到公共节点的距离，就能够用简单的比较判断来找到第一个公共节点。</p>
<p>所以我们可以利用 <code>a+b=b+a</code> 来构建相同的距离，两个链表变为 pHead1+pHead2 和 pHead2+pHead1，这样当走到他们的第一个公共节点时，都经过了 <code>a+b+公共节点长度</code> 的距离。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = pHead1;</span><br><span class="line">        ListNode p2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">            p1 = p1 == <span class="keyword">null</span> ? pHead2 : p1.next;</span><br><span class="line">            p2 = p2 == <span class="keyword">null</span> ? pHead1 : p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz37-数字在排序数组中出现的次数"><a href="#JZ37-数字在排序数组中出现的次数" class="headerlink" title="JZ37 数字在排序数组中出现的次数"></a>JZ37 数字在排序数组中出现的次数</h3><p>题目大意：</p>
<p>统计一个数字在升序数组中出现的次数。</p>
<p>思路：</p>
<p>二分查找，找到指定数字后，分别向前和向后统计出现的次数。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (k == array[mid]) &#123;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="comment">// 往左</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = mid - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(k == array[i]) &#123;</span><br><span class="line">                        num++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 往右</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(k == array[i]) &#123;</span><br><span class="line">                        num++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; array[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz38-二叉树的深度"><a href="#JZ38-二叉树的深度" class="headerlink" title="JZ38 二叉树的深度"></a>JZ38 二叉树的深度</h3><p>题目大意：</p>
<p>输入一棵二叉树，求该树的深度。</p>
<p>思路：</p>
<p>max(左子树的深度，右子树的深度) + 1 = 当前节点为根节点的深度</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = TreeDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = TreeDepth(root.right);</span><br><span class="line">        <span class="keyword">int</span> result = (left &gt; right ? left : right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/如何优雅地“退出”一个线程/" data-toggle="tooltip" data-placement="top" title="如何优雅地退出一个线程">&larr; 上一篇</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/子集树和排列树/" data-toggle="tooltip" data-placement="top" title="子集树和排列树">下一篇 &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">目录</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz1-二维数组中的查找"><span class="toc-nav-number">1.</span> <span class="toc-nav-text"><a href="#JZ1-&#x4E8C;&#x7EF4;&#x6570;&#x7EC4;&#x4E2D;&#x7684;&#x67E5;&#x627E;" class="headerlink" title="JZ1 &#x4E8C;&#x7EF4;&#x6570;&#x7EC4;&#x4E2D;&#x7684;&#x67E5;&#x627E;"></a>JZ1 &#x4E8C;&#x7EF4;&#x6570;&#x7EC4;&#x4E2D;&#x7684;&#x67E5;&#x627E;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz2-替换空格"><span class="toc-nav-number">2.</span> <span class="toc-nav-text"><a href="#JZ2-&#x66FF;&#x6362;&#x7A7A;&#x683C;" class="headerlink" title="JZ2 &#x66FF;&#x6362;&#x7A7A;&#x683C;"></a>JZ2 &#x66FF;&#x6362;&#x7A7A;&#x683C;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz3-从尾到头打印链表"><span class="toc-nav-number">3.</span> <span class="toc-nav-text"><a href="#JZ3-&#x4ECE;&#x5C3E;&#x5230;&#x5934;&#x6253;&#x5370;&#x94FE;&#x8868;" class="headerlink" title="JZ3 &#x4ECE;&#x5C3E;&#x5230;&#x5934;&#x6253;&#x5370;&#x94FE;&#x8868;"></a>JZ3 &#x4ECE;&#x5C3E;&#x5230;&#x5934;&#x6253;&#x5370;&#x94FE;&#x8868;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz4-重建二叉树"><span class="toc-nav-number">4.</span> <span class="toc-nav-text"><a href="#JZ4-&#x91CD;&#x5EFA;&#x4E8C;&#x53C9;&#x6811;" class="headerlink" title="JZ4 &#x91CD;&#x5EFA;&#x4E8C;&#x53C9;&#x6811;"></a>JZ4 &#x91CD;&#x5EFA;&#x4E8C;&#x53C9;&#x6811;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz5-用两个栈实现队列"><span class="toc-nav-number">5.</span> <span class="toc-nav-text"><a href="#JZ5-&#x7528;&#x4E24;&#x4E2A;&#x6808;&#x5B9E;&#x73B0;&#x961F;&#x5217;" class="headerlink" title="JZ5 &#x7528;&#x4E24;&#x4E2A;&#x6808;&#x5B9E;&#x73B0;&#x961F;&#x5217;"></a>JZ5 &#x7528;&#x4E24;&#x4E2A;&#x6808;&#x5B9E;&#x73B0;&#x961F;&#x5217;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz6-旋转数组的最小数字"><span class="toc-nav-number">6.</span> <span class="toc-nav-text"><a href="#JZ6-&#x65CB;&#x8F6C;&#x6570;&#x7EC4;&#x7684;&#x6700;&#x5C0F;&#x6570;&#x5B57;" class="headerlink" title="JZ6 &#x65CB;&#x8F6C;&#x6570;&#x7EC4;&#x7684;&#x6700;&#x5C0F;&#x6570;&#x5B57;"></a>JZ6 &#x65CB;&#x8F6C;&#x6570;&#x7EC4;&#x7684;&#x6700;&#x5C0F;&#x6570;&#x5B57;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz7-斐波那契数列"><span class="toc-nav-number">7.</span> <span class="toc-nav-text"><a href="#JZ7-&#x6590;&#x6CE2;&#x90A3;&#x5951;&#x6570;&#x5217;" class="headerlink" title="JZ7 &#x6590;&#x6CE2;&#x90A3;&#x5951;&#x6570;&#x5217;"></a>JZ7 &#x6590;&#x6CE2;&#x90A3;&#x5951;&#x6570;&#x5217;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz8-跳台阶"><span class="toc-nav-number">8.</span> <span class="toc-nav-text"><a href="#JZ8-&#x8DF3;&#x53F0;&#x9636;" class="headerlink" title="JZ8  &#x8DF3;&#x53F0;&#x9636;"></a>JZ8  &#x8DF3;&#x53F0;&#x9636;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz9-变态跳台阶"><span class="toc-nav-number">9.</span> <span class="toc-nav-text"><a href="#JZ9-&#x53D8;&#x6001;&#x8DF3;&#x53F0;&#x9636;" class="headerlink" title="JZ9 &#x53D8;&#x6001;&#x8DF3;&#x53F0;&#x9636;"></a>JZ9 &#x53D8;&#x6001;&#x8DF3;&#x53F0;&#x9636;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz10-矩形覆盖"><span class="toc-nav-number">10.</span> <span class="toc-nav-text"><a href="#JZ10-&#x77E9;&#x5F62;&#x8986;&#x76D6;" class="headerlink" title="JZ10 &#x77E9;&#x5F62;&#x8986;&#x76D6;"></a>JZ10 &#x77E9;&#x5F62;&#x8986;&#x76D6;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz11-二进制中1的个数"><span class="toc-nav-number">11.</span> <span class="toc-nav-text"><a href="#JZ11-&#x4E8C;&#x8FDB;&#x5236;&#x4E2D;1&#x7684;&#x4E2A;&#x6570;" class="headerlink" title="JZ11 &#x4E8C;&#x8FDB;&#x5236;&#x4E2D;1&#x7684;&#x4E2A;&#x6570;"></a>JZ11 &#x4E8C;&#x8FDB;&#x5236;&#x4E2D;1&#x7684;&#x4E2A;&#x6570;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz12-数值的整数次方"><span class="toc-nav-number">12.</span> <span class="toc-nav-text"><a href="#JZ12-&#x6570;&#x503C;&#x7684;&#x6574;&#x6570;&#x6B21;&#x65B9;" class="headerlink" title="JZ12 &#x6570;&#x503C;&#x7684;&#x6574;&#x6570;&#x6B21;&#x65B9;"></a>JZ12 &#x6570;&#x503C;&#x7684;&#x6574;&#x6570;&#x6B21;&#x65B9;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz13-调整数组顺序使奇数位于偶数前面"><span class="toc-nav-number">13.</span> <span class="toc-nav-text"><a href="#JZ13-&#x8C03;&#x6574;&#x6570;&#x7EC4;&#x987A;&#x5E8F;&#x4F7F;&#x5947;&#x6570;&#x4F4D;&#x4E8E;&#x5076;&#x6570;&#x524D;&#x9762;" class="headerlink" title="JZ13 &#x8C03;&#x6574;&#x6570;&#x7EC4;&#x987A;&#x5E8F;&#x4F7F;&#x5947;&#x6570;&#x4F4D;&#x4E8E;&#x5076;&#x6570;&#x524D;&#x9762;"></a>JZ13 &#x8C03;&#x6574;&#x6570;&#x7EC4;&#x987A;&#x5E8F;&#x4F7F;&#x5947;&#x6570;&#x4F4D;&#x4E8E;&#x5076;&#x6570;&#x524D;&#x9762;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz14-链表中倒数第k个结点"><span class="toc-nav-number">14.</span> <span class="toc-nav-text"><a href="#JZ14-&#x94FE;&#x8868;&#x4E2D;&#x5012;&#x6570;&#x7B2C;k&#x4E2A;&#x7ED3;&#x70B9;" class="headerlink" title="JZ14 &#x94FE;&#x8868;&#x4E2D;&#x5012;&#x6570;&#x7B2C;k&#x4E2A;&#x7ED3;&#x70B9;"></a>JZ14 &#x94FE;&#x8868;&#x4E2D;&#x5012;&#x6570;&#x7B2C;k&#x4E2A;&#x7ED3;&#x70B9;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz15-反转链表"><span class="toc-nav-number">15.</span> <span class="toc-nav-text"><a href="#JZ15-&#x53CD;&#x8F6C;&#x94FE;&#x8868;" class="headerlink" title="JZ15 &#x53CD;&#x8F6C;&#x94FE;&#x8868;"></a>JZ15 &#x53CD;&#x8F6C;&#x94FE;&#x8868;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz16-合并两个排序的链表"><span class="toc-nav-number">16.</span> <span class="toc-nav-text"><a href="#JZ16-&#x5408;&#x5E76;&#x4E24;&#x4E2A;&#x6392;&#x5E8F;&#x7684;&#x94FE;&#x8868;" class="headerlink" title="JZ16 &#x5408;&#x5E76;&#x4E24;&#x4E2A;&#x6392;&#x5E8F;&#x7684;&#x94FE;&#x8868;"></a>JZ16 &#x5408;&#x5E76;&#x4E24;&#x4E2A;&#x6392;&#x5E8F;&#x7684;&#x94FE;&#x8868;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz17-树的子结构"><span class="toc-nav-number">17.</span> <span class="toc-nav-text"><a href="#JZ17-&#x6811;&#x7684;&#x5B50;&#x7ED3;&#x6784;" class="headerlink" title="JZ17 &#x6811;&#x7684;&#x5B50;&#x7ED3;&#x6784;"></a>JZ17 &#x6811;&#x7684;&#x5B50;&#x7ED3;&#x6784;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz18-二叉树的镜像"><span class="toc-nav-number">18.</span> <span class="toc-nav-text"><a href="#JZ18-&#x4E8C;&#x53C9;&#x6811;&#x7684;&#x955C;&#x50CF;" class="headerlink" title="JZ18 &#x4E8C;&#x53C9;&#x6811;&#x7684;&#x955C;&#x50CF;"></a>JZ18 &#x4E8C;&#x53C9;&#x6811;&#x7684;&#x955C;&#x50CF;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz19-顺时针打印矩阵"><span class="toc-nav-number">19.</span> <span class="toc-nav-text"><a href="#JZ19-&#x987A;&#x65F6;&#x9488;&#x6253;&#x5370;&#x77E9;&#x9635;" class="headerlink" title="JZ19  &#x987A;&#x65F6;&#x9488;&#x6253;&#x5370;&#x77E9;&#x9635;"></a>JZ19  &#x987A;&#x65F6;&#x9488;&#x6253;&#x5370;&#x77E9;&#x9635;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz20-包含min函数的栈"><span class="toc-nav-number">20.</span> <span class="toc-nav-text"><a href="#JZ20-&#x5305;&#x542B;min&#x51FD;&#x6570;&#x7684;&#x6808;" class="headerlink" title="JZ20  &#x5305;&#x542B;min&#x51FD;&#x6570;&#x7684;&#x6808;"></a>JZ20  &#x5305;&#x542B;min&#x51FD;&#x6570;&#x7684;&#x6808;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz21-栈的压入-弹出序列"><span class="toc-nav-number">21.</span> <span class="toc-nav-text"><a href="#JZ21-&#x6808;&#x7684;&#x538B;&#x5165;&#x3001;&#x5F39;&#x51FA;&#x5E8F;&#x5217;" class="headerlink" title="JZ21 &#x6808;&#x7684;&#x538B;&#x5165;&#x3001;&#x5F39;&#x51FA;&#x5E8F;&#x5217;"></a>JZ21 &#x6808;&#x7684;&#x538B;&#x5165;&#x3001;&#x5F39;&#x51FA;&#x5E8F;&#x5217;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz22-从上往下打印二叉树"><span class="toc-nav-number">22.</span> <span class="toc-nav-text"><a href="#JZ22-&#x4ECE;&#x4E0A;&#x5F80;&#x4E0B;&#x6253;&#x5370;&#x4E8C;&#x53C9;&#x6811;" class="headerlink" title="JZ22 &#x4ECE;&#x4E0A;&#x5F80;&#x4E0B;&#x6253;&#x5370;&#x4E8C;&#x53C9;&#x6811;"></a>JZ22 &#x4ECE;&#x4E0A;&#x5F80;&#x4E0B;&#x6253;&#x5370;&#x4E8C;&#x53C9;&#x6811;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz23-二叉搜索树的后序遍历序列"><span class="toc-nav-number">23.</span> <span class="toc-nav-text"><a href="#JZ23-&#x4E8C;&#x53C9;&#x641C;&#x7D22;&#x6811;&#x7684;&#x540E;&#x5E8F;&#x904D;&#x5386;&#x5E8F;&#x5217;" class="headerlink" title="JZ23 &#x4E8C;&#x53C9;&#x641C;&#x7D22;&#x6811;&#x7684;&#x540E;&#x5E8F;&#x904D;&#x5386;&#x5E8F;&#x5217;"></a>JZ23 &#x4E8C;&#x53C9;&#x641C;&#x7D22;&#x6811;&#x7684;&#x540E;&#x5E8F;&#x904D;&#x5386;&#x5E8F;&#x5217;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz24-二叉树中和为某一值的路径"><span class="toc-nav-number">24.</span> <span class="toc-nav-text"><a href="#JZ24-&#x4E8C;&#x53C9;&#x6811;&#x4E2D;&#x548C;&#x4E3A;&#x67D0;&#x4E00;&#x503C;&#x7684;&#x8DEF;&#x5F84;" class="headerlink" title="JZ24 &#x4E8C;&#x53C9;&#x6811;&#x4E2D;&#x548C;&#x4E3A;&#x67D0;&#x4E00;&#x503C;&#x7684;&#x8DEF;&#x5F84;"></a>JZ24 &#x4E8C;&#x53C9;&#x6811;&#x4E2D;&#x548C;&#x4E3A;&#x67D0;&#x4E00;&#x503C;&#x7684;&#x8DEF;&#x5F84;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz25-复杂链表的复制"><span class="toc-nav-number">25.</span> <span class="toc-nav-text"><a href="#JZ25-&#x590D;&#x6742;&#x94FE;&#x8868;&#x7684;&#x590D;&#x5236;" class="headerlink" title="JZ25 &#x590D;&#x6742;&#x94FE;&#x8868;&#x7684;&#x590D;&#x5236;"></a>JZ25 &#x590D;&#x6742;&#x94FE;&#x8868;&#x7684;&#x590D;&#x5236;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz26-二叉搜索树与双向链表"><span class="toc-nav-number">26.</span> <span class="toc-nav-text"><a href="#JZ26-&#x4E8C;&#x53C9;&#x641C;&#x7D22;&#x6811;&#x4E0E;&#x53CC;&#x5411;&#x94FE;&#x8868;" class="headerlink" title="JZ26  &#x4E8C;&#x53C9;&#x641C;&#x7D22;&#x6811;&#x4E0E;&#x53CC;&#x5411;&#x94FE;&#x8868;"></a>JZ26  &#x4E8C;&#x53C9;&#x641C;&#x7D22;&#x6811;&#x4E0E;&#x53CC;&#x5411;&#x94FE;&#x8868;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz27-字符串的排列"><span class="toc-nav-number">27.</span> <span class="toc-nav-text"><a href="#JZ27-&#x5B57;&#x7B26;&#x4E32;&#x7684;&#x6392;&#x5217;" class="headerlink" title="JZ27  &#x5B57;&#x7B26;&#x4E32;&#x7684;&#x6392;&#x5217;"></a>JZ27  &#x5B57;&#x7B26;&#x4E32;&#x7684;&#x6392;&#x5217;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz28-数组中出现次数超过一半的数字"><span class="toc-nav-number">28.</span> <span class="toc-nav-text"><a href="#JZ28-&#x6570;&#x7EC4;&#x4E2D;&#x51FA;&#x73B0;&#x6B21;&#x6570;&#x8D85;&#x8FC7;&#x4E00;&#x534A;&#x7684;&#x6570;&#x5B57;" class="headerlink" title="JZ28  &#x6570;&#x7EC4;&#x4E2D;&#x51FA;&#x73B0;&#x6B21;&#x6570;&#x8D85;&#x8FC7;&#x4E00;&#x534A;&#x7684;&#x6570;&#x5B57;"></a>JZ28  &#x6570;&#x7EC4;&#x4E2D;&#x51FA;&#x73B0;&#x6B21;&#x6570;&#x8D85;&#x8FC7;&#x4E00;&#x534A;&#x7684;&#x6570;&#x5B57;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz29-最小的k个数"><span class="toc-nav-number">29.</span> <span class="toc-nav-text"><a href="#&#x25B2;JZ29-&#x6700;&#x5C0F;&#x7684;k&#x4E2A;&#x6570;" class="headerlink" title="&#x25B2;JZ29 &#x6700;&#x5C0F;&#x7684;k&#x4E2A;&#x6570;"></a>&#x25B2;JZ29 &#x6700;&#x5C0F;&#x7684;k&#x4E2A;&#x6570;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz30-连续子数组的最大和"><span class="toc-nav-number">30.</span> <span class="toc-nav-text"><a href="#JZ30-&#x8FDE;&#x7EED;&#x5B50;&#x6570;&#x7EC4;&#x7684;&#x6700;&#x5927;&#x548C;" class="headerlink" title="JZ30 &#x8FDE;&#x7EED;&#x5B50;&#x6570;&#x7EC4;&#x7684;&#x6700;&#x5927;&#x548C;"></a>JZ30 &#x8FDE;&#x7EED;&#x5B50;&#x6570;&#x7EC4;&#x7684;&#x6700;&#x5927;&#x548C;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz31-整数中1出现的次数从1到n整数中1出现的次数"><span class="toc-nav-number">31.</span> <span class="toc-nav-text"><a href="#JZ31-&#x6574;&#x6570;&#x4E2D;1&#x51FA;&#x73B0;&#x7684;&#x6B21;&#x6570;&#xFF08;&#x4ECE;1&#x5230;n&#x6574;&#x6570;&#x4E2D;1&#x51FA;&#x73B0;&#x7684;&#x6B21;&#x6570;&#xFF09;" class="headerlink" title="JZ31 &#x6574;&#x6570;&#x4E2D;1&#x51FA;&#x73B0;&#x7684;&#x6B21;&#x6570;&#xFF08;&#x4ECE;1&#x5230;n&#x6574;&#x6570;&#x4E2D;1&#x51FA;&#x73B0;&#x7684;&#x6B21;&#x6570;&#xFF09;"></a>JZ31 &#x6574;&#x6570;&#x4E2D;1&#x51FA;&#x73B0;&#x7684;&#x6B21;&#x6570;&#xFF08;&#x4ECE;1&#x5230;n&#x6574;&#x6570;&#x4E2D;1&#x51FA;&#x73B0;&#x7684;&#x6B21;&#x6570;&#xFF09;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz32-把数组排成最小的数"><span class="toc-nav-number">32.</span> <span class="toc-nav-text"><a href="#JZ32-&#x628A;&#x6570;&#x7EC4;&#x6392;&#x6210;&#x6700;&#x5C0F;&#x7684;&#x6570;" class="headerlink" title="JZ32  &#x628A;&#x6570;&#x7EC4;&#x6392;&#x6210;&#x6700;&#x5C0F;&#x7684;&#x6570;"></a>JZ32  &#x628A;&#x6570;&#x7EC4;&#x6392;&#x6210;&#x6700;&#x5C0F;&#x7684;&#x6570;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz33-丑数"><span class="toc-nav-number">33.</span> <span class="toc-nav-text"><a href="#&#x25B2;JZ33-&#x4E11;&#x6570;" class="headerlink" title="&#x25B2;JZ33  &#x4E11;&#x6570;"></a>&#x25B2;JZ33  &#x4E11;&#x6570;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz34-第一个只出现一次的字符位置"><span class="toc-nav-number">34.</span> <span class="toc-nav-text"><a href="#JZ34-&#x7B2C;&#x4E00;&#x4E2A;&#x53EA;&#x51FA;&#x73B0;&#x4E00;&#x6B21;&#x7684;&#x5B57;&#x7B26;&#x4F4D;&#x7F6E;" class="headerlink" title="JZ34 &#x7B2C;&#x4E00;&#x4E2A;&#x53EA;&#x51FA;&#x73B0;&#x4E00;&#x6B21;&#x7684;&#x5B57;&#x7B26;&#x4F4D;&#x7F6E;"></a>JZ34 &#x7B2C;&#x4E00;&#x4E2A;&#x53EA;&#x51FA;&#x73B0;&#x4E00;&#x6B21;&#x7684;&#x5B57;&#x7B26;&#x4F4D;&#x7F6E;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz35-数组中的逆序对"><span class="toc-nav-number">35.</span> <span class="toc-nav-text"><a href="#&#x25B2;JZ35-&#x6570;&#x7EC4;&#x4E2D;&#x7684;&#x9006;&#x5E8F;&#x5BF9;" class="headerlink" title="&#x25B2;JZ35  &#x6570;&#x7EC4;&#x4E2D;&#x7684;&#x9006;&#x5E8F;&#x5BF9;"></a>&#x25B2;JZ35  &#x6570;&#x7EC4;&#x4E2D;&#x7684;&#x9006;&#x5E8F;&#x5BF9;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz36-两个链表的第一个公共结点"><span class="toc-nav-number">36.</span> <span class="toc-nav-text"><a href="#JZ36-&#x4E24;&#x4E2A;&#x94FE;&#x8868;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x516C;&#x5171;&#x7ED3;&#x70B9;" class="headerlink" title="JZ36  &#x4E24;&#x4E2A;&#x94FE;&#x8868;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x516C;&#x5171;&#x7ED3;&#x70B9;"></a>JZ36  &#x4E24;&#x4E2A;&#x94FE;&#x8868;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x516C;&#x5171;&#x7ED3;&#x70B9;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz37-数字在排序数组中出现的次数"><span class="toc-nav-number">37.</span> <span class="toc-nav-text"><a href="#JZ37-&#x6570;&#x5B57;&#x5728;&#x6392;&#x5E8F;&#x6570;&#x7EC4;&#x4E2D;&#x51FA;&#x73B0;&#x7684;&#x6B21;&#x6570;" class="headerlink" title="JZ37 &#x6570;&#x5B57;&#x5728;&#x6392;&#x5E8F;&#x6570;&#x7EC4;&#x4E2D;&#x51FA;&#x73B0;&#x7684;&#x6B21;&#x6570;"></a>JZ37 &#x6570;&#x5B57;&#x5728;&#x6392;&#x5E8F;&#x6570;&#x7EC4;&#x4E2D;&#x51FA;&#x73B0;&#x7684;&#x6B21;&#x6570;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz38-二叉树的深度"><span class="toc-nav-number">38.</span> <span class="toc-nav-text"><a href="#JZ38-&#x4E8C;&#x53C9;&#x6811;&#x7684;&#x6DF1;&#x5EA6;" class="headerlink" title="JZ38 &#x4E8C;&#x53C9;&#x6811;&#x7684;&#x6DF1;&#x5EA6;"></a>JZ38 &#x4E8C;&#x53C9;&#x6811;&#x7684;&#x6DF1;&#x5EA6;</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">标签</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#algorithm" title="algorithm">algorithm</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
				<!--
                
                <hr>
                <h5>朋友们</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://tyzhang.top/" target="_blank">ztygalaxy</a></li>
                    
                        <li><a href="http://www.tangyincheng.com/" target="_blank">yctang</a></li>
                    
                        <li><a href="https://dolnw.github.io" target="_blank">JCWang</a></li>
                    
                </ul>
                
				-->
            </div>
        </div>
    </div>
</article>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: ''
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


<!-- chrome Firefox 中文锚点定位失效-->
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<!-- smooth scroll behavior polyfill  -->
<script type="text/javascript" src="/js/smoothscroll.js"></script>
<script>
        $('#toc').on('click','a',function(a){
            // var isChrome = window.navigator.userAgent.indexOf("Chrome") !== -1;
            // console.log(window.navigator.userAgent,isChrome)
                // if(isChrome) {
                    // console.log(a.currentTarget.outerHTML);
                    // console.log($(a.currentTarget).attr("href"));
                    //跳转到指定锚点
                    // document.getElementById(a.target.innerText.toLowerCase()).scrollIntoView(true);
                    document.getElementById($(a.currentTarget).attr("href").replace("#","")).scrollIntoView({behavior: 'smooth' });
                // }
        })  
</script>


    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                
				
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/songzblink">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 宋正兵 2021 
                    <br>
                    Theme by <a href="http://www.huweihuang.com">Huwei Huang</a>
                    re-Ported by <a href="https://github.com/ztygalaxy">ztygalaxy</a>
					
					<br>
                    <a href="http://www.beian.miit.gov.cn/" style="color: gray">浙ICP备2021018896号</a>
					<br>
					<!-- <p class="copyright text-muted" style="margin-top: 5px"> -->
						<img src="../../img/备案图标.png"/>
						<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=undefined" style="color: gray">undefined</a>
					<!-- </p> -->
					
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("zbsong.top/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="zbsong.top/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>

</html>
