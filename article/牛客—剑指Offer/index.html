<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/logo.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          牛客—剑指Offer - 宋正兵的博客 | zbsong Blog
        
    </title>

    <link rel="canonical" href="zbsong.top/article/牛客—剑指Offer/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('https://api.dujin.org/bing/1920.php')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#algorithm" title="algorithm">algorithm</a>
                            
                        </div>
                        <h1>牛客—剑指Offer</h1>
                        <!-- <h2 class="subheading">记录了在牛客刷题的答案</h2> -->
                        <span class="meta">
                            宋正兵 更新 on
                            2021-08-25
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">songzblink</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">主页</a>
                    </li>
					<li>
                        <a href="/archive/">归档</a>
                    </li>
					<li>
                        <a href="/tags/">标签</a>
                    </li>
					<li>
                        <a href="/about/">关于</a>
                    </li>
					<!--
					修改about在前面的问题
                    
                        
                    
                        
                        <li>
                            <a href="/about/">关于</a>
                        </li>
                        
                    
                        
                        <li>
                            <a href="/tags/">标签</a>
                        </li>
                        
                    
                        
                        <li>
                            <a href="/archive/">归档</a>
                        </li>
                        
                    
                    -->
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
	// querySelector 获取文档中 id="demo" 的元素
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				
                <blockquote>
<p><font id="qusnum"></font></p>
<script src="/js/jquery.min.js"></script>
<script language="javascript" type="text/javascript">
$(document).ready(function(){
    var i=$('h3').size();
    var years = {};
 var myDate = new Date(); 
 var year = myDate.getFullYear();
 var month = myDate.getMonth()+1;
 var day = myDate.getDate();
 var newDay = year + "年" + month + "月" + day + "日";
    var str = '截至' + newDay +  '，已收录' + i + '道题目。';
    document.getElementById('qusnum').innerHTML = str;
});
</script>
</blockquote>
<p><a href="https://www.nowcoder.com/ta/coding-interviews" target="_blank" rel="noopener">剑指Offer_在线编程+题解_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="jz1-二维数组中的查找">JZ1 二维数组中的查找</h3>
<p>题目大意：</p>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>思路：</p>
<p>左下开始找，对于左下角的元素 m，m 已经是该行的最小值，该列的最大值</p>
<ul>
<li>target &gt; m ==》 m 是该列最大的元素，想要更大只能考虑右边一列</li>
<li>target &lt; m ==》 m 是该行最小的元素，想要更小只能考虑上边一行</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = array.length - <span class="number">1</span>, n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || target &gt; array[m][array[<span class="number">0</span>].length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左下开始找，对于左下角的元素m，m已经是该行的最小值，该列的最大值</span></span><br><span class="line">        <span class="comment">// target &gt; m ==》 m是该列最大的元素，想要更大只能考虑右边一列</span></span><br><span class="line">        <span class="comment">// target &lt; m ==》 m是该行最小的元素，想要更小只能考虑上边一行</span></span><br><span class="line">        <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &lt; array[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == array[m][n]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; array[m][n]) &#123;</span><br><span class="line">                n++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                m--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz2-替换空格">JZ2 替换空格</h3>
<p>题目大意：</p>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p>思路：</p>
<p>利用 StringBuffer 来拼接，遇上空格就替换成 “%20”。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : s.toCharArray()) &#123;</span><br><span class="line">            sb.append(ch == <span class="string">' '</span>? <span class="string">"%20"</span> : ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz3-从尾到头打印链表">JZ3 从尾到头打印链表</h3>
<p>题目大意：</p>
<p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<p>思路：</p>
<p>翻转链表 + List 插入：翻转链表然后再插入到 ArrayList 当中。之所以不用 list.add(0, listNode) 是因为 ArrayList 插入的时间复杂度是 $O(n)$，n 个元素插入就是 $O(n^{2})$，翻转链表后再插入会快些。</p>
<p>方法二：类似于二叉树的中序遍历时找到第一个节点，进行递归。</p>
<p>代码：</p>
<p>方法一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        listNode = reverse(listNode);</span><br><span class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ListNode headNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode nextNode = listNode.next;</span><br><span class="line">            listNode.next = headNode.next;</span><br><span class="line">            headNode.next = listNode;</span><br><span class="line">            listNode = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            printListFromTailToHead(listNode.next);</span><br><span class="line">            resList.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz4-重建二叉树">JZ4 重建二叉树</h3>
<p>题目大意：</p>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p>思路：</p>
<p>模拟我们根据前序和中序构建二叉树的过程。</p>
<p>根据前序遍历和中序遍历重建二叉树：<br>
1、根据前序序列第一个结点确定根结点<br>
2、根据根结点在中序序列中的位置分割出左右两个子序列<br>
3、对左子树和右子树分别递归使用同样的方法继续分解</p>
<p>前序遍历的顺序就是我们从中序遍历中每次找到当前子树根节点的顺序 1-&gt;2-&gt;3…<br>
中序遍历中被我们每次选择的根节点划分为 [左子树, root, 右子树]<br>
同样的 左子树 和 右子树 当中也符合上述规则<br>
于是递归的进行</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre.length == <span class="number">0</span> || in.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 在中序中找到前序的根</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[<span class="number">0</span>] == in[i]) &#123;</span><br><span class="line">                <span class="comment">// 左子树</span></span><br><span class="line">                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, <span class="number">1</span>, i + <span class="number">1</span>), Arrays.copyOfRange(in, <span class="number">0</span>, i));</span><br><span class="line">                <span class="comment">// 右子树</span></span><br><span class="line">                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + <span class="number">1</span>, pre.length), Arrays.copyOfRange(in, i + <span class="number">1</span>, in.length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz5-用两个栈实现队列">JZ5 用两个栈实现队列</h3>
<p>题目大意：</p>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<p>思路：</p>
<ul>
<li>入队：都往 stack1 中入栈</li>
<li>出队：
<ul>
<li>如果 stack2 不为空，从 stack2 中出栈</li>
<li>如果 stack2 为空，将 stack1 全部迁移到 stack2，再从 stack2 出栈</li>
</ul>
</li>
</ul>
<p>即最先入队的元素一定会放在 stack2 的栈顶或者 stack1 的栈底，最后入队的元素一定会在 stack1 的栈顶或者是 stack2 的栈底。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz6-旋转数组的最小数字">JZ6 旋转数组的最小数字</h3>
<p>题目大意：</p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>思路：</p>
<p>二分。我们要找最小的数字，且数组是升序的，左边小右边大，所以选择和右边的边界比较，当然左边也行，只不过右边方便些。</p>
<ul>
<li><code>array[mid] &gt; array[right]</code>：最小值在 <code>(mid,right]</code> 内出现，所以 <code>left = mid + 1</code>；</li>
<li><code>array[mid] &lt; array[right]</code>：最小值在 <code>[left,mid]</code> 内出现，注意这里的 <code>array[mid]</code> 也有可能是最小值，所以 <code>right = mid</code>；</li>
<li><code>array[mid] == array[right]</code>：因为是升序的，右边的会大一些，所以直接去掉 <code>array[right]</code> 来排除一个可能的选项，继续进行二分查找。</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>, left = <span class="number">0</span>, right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &gt; array[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; array[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz7-斐波那契数列">JZ7 斐波那契数列</h3>
<p>没什么好说的。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz8-跳台阶">JZ8  跳台阶</h3>
<p>题目大意：</p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// f(n) = f(n-1) + f(n-2)</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span> || target == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jumpFloor(target - <span class="number">1</span>) + jumpFloor(target - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化：因为只用到了上一个状态 f(n-1) 和上上一个状态 f(n-2)，所以可以把递归修改为空间复杂度为 $O(1)$ 的递推。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// f(n) = f(n-1) + f(n-2)</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="comment">// f(i) = f(i-1) + f(i-2)</span></span><br><span class="line">            a = a + b;</span><br><span class="line">            <span class="comment">// f(i-1) = f(i) - f(i-2)</span></span><br><span class="line">            b = a - b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz9-变态跳台阶">JZ9 变态跳台阶</h3>
<p>题目大意：</p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p>思路：</p>
<p>对于第 n 级的台阶，跳法有 n+1 种，即从第 0 阶跳 n 级台阶，从第 1 阶跳 n-1 级台阶……，于是就有 $f(n) = \sum\limits_{i = 0}^{n-1}f(i)$ ，如代码一所示。</p>
<p><strong>优化</strong> $f(0)=1$，$f(1)=f(0)=1$，$f(2)=f(0)+f(1)=2$，$f(3)=f(0)+f(1)+f(2)=2*f(2)=4$……列出多项后发现，这其实是一个等比数列，有 $f(n)=2^{n-1}$，于是可以优化为代码二。</p>
<p>代码：</p>
<p>代码一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码二</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (target - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz10-矩形覆盖">JZ10 矩形覆盖</h3>
<p>题目大意：</p>
<p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<p>思路：</p>
<p>扩充矩形的方法一共有两种，1）竖着摆放一个，矩形增加 2*1；2）横着摆放两个，矩形增加 2*2。假设我们现在要覆盖一个 2*n 的矩形，有多少种方法？</p>
<p>对于第一种扩充方法，需要从 2*(n-1) 的矩形增加一个竖着摆放的小矩形；对于第二种扩充方法，需要从 2*(n-2) 的矩形增加两个横着摆放的小矩形。</p>
<p>于是覆盖一个 2*n 的矩形的方法数 $f(n)=f(n-1) + f(n-2)$</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rectCover(target - <span class="number">1</span>) + rectCover(target - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz11-二进制中1的个数">JZ11 二进制中1的个数</h3>
<p>题目大意：</p>
<p>输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p>
<p>思路：</p>
<p>每次都通过位运算移除末尾的最后一个 0，统计操作的次数，直到这个数为 0，操作的次数就是 1 的个数。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz12-数值的整数次方">JZ12 数值的整数次方</h3>
<p>题目大意：</p>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p>保证base和exponent不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面0的位数。</p>
<p>思路：</p>
<p>快速幂的思路。先将 exponent 转换为正数，并记录原始的正负状态 isNegative。然后快速幂的思想是：如果指数是偶数 2n，那么就分解成 $num^{n} * num^{n}$，如果指数是奇数，那么就分解成 $num^{n-1}*num$，转换为偶数的情况处理。最后根据 isNegative 的值判断是否需要把结果写成 $\frac{1}{res}$。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快速幂</span></span><br><span class="line">        <span class="keyword">boolean</span> isNegative = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// exponent 转换为正数的原因为：</span></span><br><span class="line">        <span class="comment">// 在 exponent 为奇数时，负数减1，越减越小了</span></span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            isNegative = <span class="keyword">true</span>;</span><br><span class="line">            exponent = - exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> res = getPower(base, exponent);</span><br><span class="line">        <span class="keyword">return</span> isNegative ? <span class="number">1</span> / res : res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPower</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (exponent == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> temp = getPower(base, exponent / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> temp * temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getPower(base, exponent - <span class="number">1</span>) * base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz13-调整数组顺序使奇数位于偶数前面">JZ13 调整数组顺序使奇数位于偶数前面</h3>
<p>题目大意：</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>思路：</p>
<p>冒泡排序，将判断条件从大小换成奇偶</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reOrderArray (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// 冒泡</span></span><br><span class="line">        <span class="keyword">int</span> n = array.length;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; changed; i--) &#123;</span><br><span class="line">            changed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; array[j + <span class="number">1</span>] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    changed = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                    array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>狗日的牛客改判题条件了，冒泡过不了，换成将奇数往前移，偶数放到新建数组 odd[] 中，然后再将 odd[] 数组中的内容复制到 array[] 中奇数序列的后面。</p>
</blockquote>
<h3 id="jz14-链表中倒数第k个结点">JZ14 链表中倒数第k个结点</h3>
<p>题目大意：</p>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
<p>如果该链表长度小于k，请返回空。</p>
<p>思路：</p>
<p>快慢指针。如果输出倒数第 1 个结点，则快指针应该比慢指针快一个结点，这样当快指针指向 null 的时候，慢指针刚好指向最后一个结点。那么可以划分为以下几步：</p>
<ul>
<li>快指针先走 k 步</li>
<li>快慢指针同时往后走，直到快指针为 null</li>
<li>返回慢指针</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode slowNode = pHead, fastNode = pHead;</span><br><span class="line">        <span class="keyword">while</span> (fastNode != <span class="keyword">null</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            k--;</span><br><span class="line">            fastNode = fastNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fastNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fastNode = fastNode.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k &gt; <span class="number">0</span> ? <span class="keyword">null</span> : slowNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz15-反转链表">JZ15 反转链表</h3>
<p>题目大意：</p>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
<p>思路：</p>
<p>头插，没啥好说的。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummyNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 头插</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = dummyNode.next;</span><br><span class="line">            dummyNode.next = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz16-合并两个排序的链表">JZ16 合并两个排序的链表</h3>
<p>题目大意：</p>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        ListNode dummyNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curNode = dummyNode;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">                curNode.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curNode.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curNode.next = (list1 == <span class="keyword">null</span> ? list2 : list1);</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz17-树的子结构">JZ17 树的子结构</h3>
<p>题目大意：</p>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p>思路：</p>
<p>遍历二叉树 A，以每一个节点作为子树的根节点和二叉树 B 进行比较 <code>isSubTree(root1, root2)</code>，判断以当前节点为根节点的子树和二叉树 B 是否相同。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 空树不是任意一个树的子结构 || root1为空那么肯定不包含root2结构</span></span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="keyword">null</span> || root1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSubTree(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubTree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// root2遍历到了空节点，不用管root1此时空不空</span></span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// root1为空，root2不为空，肯定不是</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root1.val == root2.val &amp;&amp;</span><br><span class="line">            isSubTree(root1.left, root2.left) &amp;&amp;</span><br><span class="line">            isSubTree(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz18-二叉树的镜像">JZ18 二叉树的镜像</h3>
<p>题目大意：</p>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Mirror</span> <span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode tempNode = pRoot.left;</span><br><span class="line">            pRoot.left = pRoot.right;</span><br><span class="line">            pRoot.right = tempNode;</span><br><span class="line">            Mirror(pRoot.left);</span><br><span class="line">            Mirror(pRoot.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz19-顺时针打印矩阵">JZ19  顺时针打印矩阵</h3>
<p>题目大意：</p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字.</p>
<p>思路：</p>
<p>设置上下左右边界，按照顺序去打印，没打印一行或者一列则把相应的边界挪动一位。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].length - <span class="number">1</span>, up = <span class="number">0</span>, down = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 顶部那行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">                resList.add(matrix[up][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            up++;</span><br><span class="line">            <span class="keyword">if</span> (up &gt; down) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右边那列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = up; i &lt;= down; i++) &#123;</span><br><span class="line">                resList.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下边那行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = right;i &gt;= left; i--) &#123;</span><br><span class="line">                resList.add(matrix[down][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            down--;</span><br><span class="line">            <span class="keyword">if</span> (up &gt; down) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左边那列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = down; i &gt;= up; i--) &#123;</span><br><span class="line">                resList.add(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz20-包含min函数的栈">JZ20  包含min函数的栈</h3>
<p>题目大意：</p>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数。</p>
<p>思路：</p>
<p>stack1 正常入栈出栈，stack2 在 stack1 入栈的时候陪着入栈最小元素。这样在同样深度的时候就能直接从 stack2 中拿到最小元素。</p>
<p>也可以用内部类 Node (int val, int minVal)，让每一个元素不仅存储原来的值，还存储从自己到最先入队的元素中的最小值。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty()) &#123;</span><br><span class="line">            stack2.push(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node &lt; stack2.peek()) &#123;</span><br><span class="line">                stack2.push(node);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack2.push(stack2.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1.pop();</span><br><span class="line">        stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz21-栈的压入-弹出序列">JZ21 栈的压入、弹出序列</h3>
<p>题目大意：</p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。</p>
<p>思路：</p>
<p>直接新建一个栈去模拟这个过程，如果栈不为空且栈顶元素等于要出栈的元素，那么出栈。最后判断栈是否为空即可。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : pushA) &#123;</span><br><span class="line">            stack.push(num);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popA[i]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz22-从上往下打印二叉树">JZ22 从上往下打印二叉树</h3>
<p>题目大意：</p>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p>思路：</p>
<p>层序遍历。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resList;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode curNode = queue.poll();</span><br><span class="line">            resList.add(curNode.val);</span><br><span class="line">            <span class="keyword">if</span> (curNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(curNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(curNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz23-二叉搜索树的后序遍历序列">JZ23 二叉搜索树的后序遍历序列</h3>
<p>题目大意：</p>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。</p>
<p>思路：</p>
<p>后序遍历的顺序是左右根，反映到二叉搜索树中会有左子树的所有节点小于根节点小于右子树的所有节点。所以我们可以根据这个性质，将后序遍历序列根据根节点的值划分为左子树的后序序列和右子树的后序序列，满足左子树的后序序列小于根节点，右子树的后序序列大于根节点。递归这个判断的过程。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence == <span class="keyword">null</span> || sequence.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isBST(sequence, <span class="number">0</span>, sequence.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">(<span class="keyword">int</span>[] seq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root = seq[end];</span><br><span class="line">        <span class="keyword">int</span> split = start;</span><br><span class="line">        <span class="comment">// 找到左右子树分界</span></span><br><span class="line">        <span class="keyword">for</span> (; split &lt; end &amp;&amp; seq[split] &lt; root; split++);</span><br><span class="line">        <span class="comment">// 右子树中若有小于根节点的，直接返回false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = split; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq[i] &lt; root) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isBST(seq, start, split - <span class="number">1</span>) &amp;&amp; isBST(seq, split, end - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz24-二叉树中和为某一值的路径">JZ24 二叉树中和为某一值的路径</h3>
<p>题目大意：</p>
<p>输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p>思路：</p>
<p>DFS 思想，从根节点开始往下搜索，每遍历一个节点就将其加入路径当中。如果当前节点是叶子节点，则检查当前路径和是否和 targer 相等，相等则找到一条路径。</p>
<blockquote>
<p>需要注意的地方：如果按照 <code>if (root == null)</code> 的时候再去检查路径和是否和 target 相等，不能及时的从当前叶子节点退出，会进入叶子节点的左右子节点，造成两次判断生效加入 resList 路径集合操作，导致答案重复。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; tempList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        checkPath(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPath</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + root.val == target) &#123;</span><br><span class="line">                tempList.add(root.val);</span><br><span class="line">                resList.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">                tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剪枝，还没走到叶子节点就大于targer，继续走只会让sum更大</span></span><br><span class="line">        <span class="keyword">if</span> (sum + root.val &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tempList.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkPath(root.left, sum + root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkPath(root.right, sum + root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz25-复杂链表的复制">JZ25 复杂链表的复制</h3>
<p>题目大意：</p>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点</p>
<p>思路：</p>
<p>分为两步：</p>
<ol>
<li>
<p>【复制】为所有节点创建备份，存到 map 中，此时复制出来的节点的 next 和 random 字段都为 null</p>
</li>
<li>
<p>【完善链表结构】根据原始链表的结构，构建复制出来的新链表的结构。</p>
<p>比如原始链表的节点 A，对应复制出来的节点 A*。A 的next是 B，random 是 C，那么对应的 A* 的 next 是 B*，random 是 C*。如何找到 B* 和 C* 呢，就是通过 map 来获取，因为在第一步的时候就把每个节点对应的复制节点存放到了 map 当中。</p>
</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        RandomListNode curNode = pHead;</span><br><span class="line">        <span class="comment">// 将所有值都存入map，每一个结点都被new了【复制】</span></span><br><span class="line">        <span class="keyword">while</span> (curNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(curNode, <span class="keyword">new</span> RandomListNode(curNode.label));</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完善链表的结构</span></span><br><span class="line">        RandomListNode target = <span class="keyword">new</span> RandomListNode(pHead.label);</span><br><span class="line">        curNode = pHead;</span><br><span class="line">        RandomListNode p = target;</span><br><span class="line">        <span class="comment">// 移动 p 和 curNode 来完善链表的结构</span></span><br><span class="line">        <span class="keyword">while</span> (curNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.next = map.get(curNode.next);</span><br><span class="line">            p.random = map.get(curNode.random);</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz26-二叉搜索树与双向链表">JZ26  二叉搜索树与双向链表</h3>
<p>题目大意：</p>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p>思路：</p>
<p>二叉搜索树的一个性质之一是：中序遍历的顺序是有序的，所以我们可以明确的是这道题目需要用到中序遍历。将节点的左指针指向中序遍历的前一个节点，右指针指向中序遍历的后一个节点。</p>
<p>我们可以利用一个 preNode 节点来完成这件事情。当我们遍历到某个节点的时候，它的左指针应该指向它的前一个节点 preNode，同时将 preNode 节点的右指针指向当前节点，完成前一个节点的左右指针调整。等遍历下一个节点的时候，再来完善当前节点的右指针。所以需要把当前节点左右 preNode 节点，去处理下一个节点。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode targetNode = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode preNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRootOfTree == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        <span class="keyword">if</span> (targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            targetNode = pRootOfTree;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            preNode.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = preNode;</span><br><span class="line">        &#125;</span><br><span class="line">        preNode = pRootOfTree;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> targetNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz27-字符串的排列">JZ27  字符串的排列</h3>
<p>题目大意：</p>
<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列</p>
<p>思路：【排列树】</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20200427/284295_1587983313815_36EC2C8836C9F164B867402474E0DC4E" alt=""></p>
<p>从上图可以看到，如果我们先固定 A 不懂，然后交换 B 与 C，可以得到 ABC 和 ACB，同样的对于 B、C 是同样的道理。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;String&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] arr = str.toCharArray();</span><br><span class="line">            backtrace(arr, <span class="number">0</span>, resList);</span><br><span class="line">            Collections.sort(resList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> t, ArrayList&lt;String&gt; resList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t &gt;= arr.length) &#123;</span><br><span class="line">            String tempStr = String.copyValueOf(arr);</span><br><span class="line">            <span class="keyword">if</span> (!resList.contains(tempStr)) &#123;</span><br><span class="line">                resList.add(tempStr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt; arr.length; i++) &#123;</span><br><span class="line">            swap(arr, t, i);</span><br><span class="line">            backtrace(arr, t + <span class="number">1</span>, resList);</span><br><span class="line">            swap(arr, t, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz28-数组中出现次数超过一半的数字">JZ28  数组中出现次数超过一半的数字</h3>
<p>题目大意：</p>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>思路：</p>
<ul>
<li>从前往后遍历，记录当前候选数字 condition 出现的次数 count，相同则出现次数 +1，不相同则 -1。</li>
<li>当次数 count 被减到 0 时，表示从 0 到当前元素的区间内，候选数字 condition 不是众数。</li>
<li>最后留下来的候选数字 condition 有可能是众数，进行验证</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 该方法是基于如果存在众数，那么遍历数组之后众数k出现的次数一定是大于数组长度一半的</span></span><br><span class="line">        <span class="comment">// 从前往后遍历，记录当前候选数字condition出现的次数count</span></span><br><span class="line">        <span class="comment">// 相同则出现次数+1，不相同则-1</span></span><br><span class="line">        <span class="comment">// 当次数count被减到0时，表示从0到当前元素的区间内，候选数字condition不是众数</span></span><br><span class="line">        <span class="comment">// 最后留下来的候选数字condition有可能是众数，进行验证</span></span><br><span class="line">        <span class="keyword">int</span> condition = -<span class="number">1</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                condition = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num == condition) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验证</span></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == condition) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt; array.length / <span class="number">2</span> ? condition : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz29-最小的k个数">▲JZ29 最小的k个数</h3>
<p>题目大意：</p>
<p>给定一个数组，找出其中最小的K个数。</p>
<p>思路：</p>
<p>堆排序。构建好堆后，每次将最小的元素交换到数组的末尾，同时加入到结果集合中。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= input.length) &#123;</span><br><span class="line">        	heapSort(input, k, resList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, ArrayList&lt;Integer&gt; resList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建堆，从第一个非叶子节点开始，从下到上，从右往左</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length / <span class="number">2</span> -<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调整堆结构，并加入结果集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            resList.add(arr[<span class="number">0</span>]);</span><br><span class="line">            swap(arr, <span class="number">0</span>, arr.length - i - <span class="number">1</span>);</span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, arr.length - i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取出当前元素</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="comment">// 从第i个节点的左孩子节点开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span> * i + <span class="number">1</span>; k &lt; length; k = <span class="number">2</span> * k + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 右孩子更小则指向右孩子节点</span></span><br><span class="line">            <span class="keyword">if</span> (k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &gt; arr[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果子节点小于父节点（当前元素），则将子节点赋值给父节点</span></span><br><span class="line">            <span class="comment">// 子节点最后由temp来填充</span></span><br><span class="line">            <span class="comment">// 【从这里能看出来是小根堆】</span></span><br><span class="line">            <span class="keyword">if</span> (arr[k] &lt; temp) &#123;</span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将temp放置到最终的位置</span></span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz30-连续子数组的最大和">JZ30 连续子数组的最大和</h3>
<p>题目大意：</p>
<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>思路：</p>
<p>正数负数都有的情况下，连续子数组相加小于零的时候，一定不会是最大子数组。此时可以直接将 sum 清零，开始重新计算子数组的和。</p>
<p>但是当数组元素全是负数的时候该方法就存在问题，得到的结果为 0。解决的办法是 0 + 当前数字，然后先与最大子数组和比较，再去判断小于零则清零。这样做能够在求和的同时，把当前为负数的元素拎出来单独比较。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, maxSum = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; maxSum) &#123;</span><br><span class="line">                maxSum = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz31-整数中1出现的次数从1到n整数中1出现的次数">JZ31 整数中1出现的次数（从1到n整数中1出现的次数）</h3>
<p>题目大意：</p>
<p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数</p>
<p>思路：</p>
<p><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/" target="_blank" rel="noopener">面试题43. 1～n 整数中 1 出现的次数（清晰图解） - 1～n 整数中 1 出现的次数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/</span></span><br><span class="line">        <span class="keyword">int</span> oneFreq = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> digit = <span class="number">1</span>; digit &lt;= n; digit *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = n / digit % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> high = n / digit / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> low = n % digit;</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">0</span>) &#123;</span><br><span class="line">                oneFreq += high * digit;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">                oneFreq += high * digit + low + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                oneFreq += (high + <span class="number">1</span>) * digit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oneFreq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz32-把数组排成最小的数">JZ32  把数组排成最小的数</h3>
<p>题目大意：</p>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p>思路：</p>
<p>把问题转化为：如何给这个数组排序，使其看做一个数字的时候最小。</p>
<p>两个字符串 s1, s2，将它们拼接起来看 s1+s2 和 s2+s1 哪个大，如果 s1+s2 大，那么说明 s2 应该放前面。按照我们定义的标准排好序，然后依次拼接起来就是答案。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numbers.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> s1 = Integer.valueOf(numbers[i]+ <span class="string">""</span> +numbers[j]);</span><br><span class="line">                <span class="keyword">int</span> s2 = Integer.valueOf(numbers[j]+ <span class="string">""</span> +numbers[i]);</span><br><span class="line">                <span class="keyword">if</span> (s1 &gt; s2) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">                    numbers[i] = numbers[j];</span><br><span class="line">                    numbers[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拼接</span></span><br><span class="line">        String res = <span class="keyword">new</span> String(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : numbers) &#123;</span><br><span class="line">            res += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz33-丑数">▲JZ33  丑数</h3>
<p>题目大意：</p>
<p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<p>思路：</p>
<p>首先从丑数的定义我们知道，一个丑数的因子只有 2，3，5，那么丑数 $p = 2 ^ x * 3 ^ y * 5 ^ z$，换句话说一个丑数一定由另一个丑数乘以 2 或者乘以 3 或者乘以 5 得到，那么我们从 1 开始乘以 2，3，5，就得到 2，3，5 三个丑数，在从这三个丑数出发乘以 2，3，5 就得到 4，6，10，6，9，15，10，15，25 九个丑数，我们发现这种方法得到重复的丑数，而且我们题目要求第 N 个丑数，这样的方法得到的丑数也是无序的。那么我们可以维护三个队列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">（1）丑数数组： 1</span><br><span class="line">乘以2的队列：2</span><br><span class="line">乘以3的队列：3</span><br><span class="line">乘以5的队列：5</span><br><span class="line">选择三个队列头最小的数2加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</span><br><span class="line">（2）丑数数组：1,2</span><br><span class="line">乘以2的队列：4</span><br><span class="line">乘以3的队列：3，6</span><br><span class="line">乘以5的队列：5，10</span><br><span class="line">选择三个队列头最小的数3加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</span><br><span class="line">（3）丑数数组：1,2,3</span><br><span class="line">乘以2的队列：4,6</span><br><span class="line">乘以3的队列：6,9</span><br><span class="line">乘以5的队列：5,10,15</span><br><span class="line">选择三个队列头里最小的数4加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</span><br><span class="line">（4）丑数数组：1,2,3,4</span><br><span class="line">乘以2的队列：6，8</span><br><span class="line">乘以3的队列：6,9,12</span><br><span class="line">乘以5的队列：5,10,15,20</span><br><span class="line">选择三个队列头里最小的数5加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</span><br><span class="line">（5）丑数数组：1,2,3,4,5</span><br><span class="line">乘以2的队列：6,8,10，</span><br><span class="line">乘以3的队列：6,9,12,15</span><br><span class="line">乘以5的队列：10,15,20,25</span><br><span class="line">选择三个队列头里最小的数6加入丑数数组，但我们发现，有两个队列头都为6，所以我们弹出两个队列头，同时将12,18,30放入三个队列；</span><br><span class="line">……………………</span><br></pre></td></tr></table></figure>
<p><strong>疑问：</strong></p>
<p>1.为什么分三个队列？</p>
<p>丑数数组里的数一定是有序的，因为我们是从丑数数组里的数乘以 2，3，5 选出的最小数，一定比以前未乘以 2，3，5 大，同时对于三个队列内部，按先后顺序乘以 2，3，5 分别放入，所以同一个队列内部也是有序的；</p>
<p>2.为什么比较三个队列头部最小的数放入丑数数组？</p>
<p>因为三个队列是有序的，所以取出三个头中最小的，等同于找到了三个队列所有数中最小的。</p>
<p><strong>实现思路：</strong></p>
<p>我们没有必要维护三个队列，只需要记录三个指针显示到达哪一步；“|” 表示指针，arr 表示丑数数组；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">（1）1</span><br><span class="line">|2</span><br><span class="line">|3</span><br><span class="line">|5</span><br><span class="line">目前指针指向0,0,0，队列头arr[0] * 2 = 2,  arr[0] * 3 = 3,  arr[0] * 5 = 5</span><br><span class="line">（2）1 2</span><br><span class="line">2 |4</span><br><span class="line">|3 6</span><br><span class="line">|5 10</span><br><span class="line">目前指针指向1,0,0，队列头arr[1] * 2 = 4,  arr[0] * 3 = 3, arr[0] * 5 = 5</span><br><span class="line">（3）1 2 3</span><br><span class="line">2| 4 6</span><br><span class="line">3 |6 9</span><br><span class="line">|5 10 15</span><br><span class="line">目前指针指向1,1,0，队列头arr[1] * 2 = 4,  arr[1] * 3 = 6, arr[0] * 5 = 5</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>, p3 = <span class="number">0</span>, p5 = <span class="number">0</span>; <span class="comment">// 三个潜在成为最小丑数的位置</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">            <span class="comment">// 找到该轮次最小的那个丑数</span></span><br><span class="line">            res[i] = Math.min(res[p2] * <span class="number">2</span>, Math.min(res[p3] * <span class="number">3</span>, res[p5] * <span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span> (res[i] == res[p2] * <span class="number">2</span>) &#123;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res[i] == res[p3] * <span class="number">3</span>) &#123;</span><br><span class="line">                p3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res[i] == res[p5] * <span class="number">5</span>) &#123;</span><br><span class="line">                p5++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[index - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz34-第一个只出现一次的字符位置">JZ34 第一个只出现一次的字符位置</h3>
<p>题目大意：</p>
<p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）</p>
<p>思路：</p>
<p>已知 ASCII 码表字符一共有 128 个。那么我们可以维护一个 count[] 数组，用来记录字符串 str 中每个字符出现的次数。对于字符 ch 有：</p>
<ul>
<li><code>count[ch] == 0</code>，字符 ch 没有出现过；</li>
<li><code>count[ch] == 1</code>，字符 ch 出现过 1 次；</li>
<li><code>count[ch] &gt; 2</code>，字符 ch 出现过多次。</li>
</ul>
<p>于是我们在统计完字符串 str 中字符出现的次数后，在根据字符串 str 中字符出现的顺序去找到第一个只出现一次的字符的位置即可。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0：没出现 1：出现过1次 &gt;1：出现过多次</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            count[str.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[str.charAt(i)] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz35-数组中的逆序对">▲JZ35  数组中的逆序对</h3>
<p>题目大意：</p>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。</p>
<p>思路：</p>
<p>利用归并排序的思想，递归划分整个区间为基本相等的左右区间。比如需要合并的两个有序区间为 [3, 4] 和 [1, 2]，在合并的过程中发现 $3 &gt; 1$，说明 3 后面的所有数都是大于 1 的，对于 2 来讲同理。所以我们在合并的时候可以利用这个规则，假设合并有序区间 A 和有序区间 B，长度分别为 n 和 m，有：</p>
<ul>
<li><code>A[i] &lt; B[j]</code>，说明没有逆序对发生。</li>
<li><code>A[i] &gt; B[j]</code>，说明 <code>A[i...n]</code> 都大于 <code>B[j]</code>，构成逆序对，数量为 <code>n - i + 1</code>。</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(array, start, mid);</span><br><span class="line">        mergeSort(array, mid + <span class="number">1</span>, end);</span><br><span class="line">        merge(array, start, end, mid);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p1 = start, p2 = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[p1] &lt;= array[p2]) &#123;</span><br><span class="line">                <span class="comment">// 前面的元素小于后面的元素，不能构成逆序对</span></span><br><span class="line">                temp[k++] = array[p1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 前面的元素大于后面的元素</span></span><br><span class="line">                <span class="comment">// 那么前面的元素以及之后的元素（[p1, mid]）都能和p2构成逆序对</span></span><br><span class="line">                temp[k++] = array[p2++];</span><br><span class="line">                count = (count + (mid - p1 + <span class="number">1</span>)) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">            temp[k++] = array[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= end) &#123;</span><br><span class="line">            temp[k++] = array[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            array[i + start] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz36-两个链表的第一个公共结点">JZ36  两个链表的第一个公共结点</h3>
<p>题目大意：</p>
<p>输入两个无环的单链表，找出它们的第一个公共结点。</p>
<p>思路：</p>
<p>指针 p1 走 a 步到达第一个公共节点，指针 p2 走 b 步到达公共节点，那么如果我们能够让 p1 到第一个公共节点的距离等于 p2 到公共节点的距离，就能够用简单的比较判断来找到第一个公共节点。</p>
<p>所以我们可以利用 <code>a+b=b+a</code> 来构建相同的距离，两个链表变为 pHead1+pHead2 和 pHead2+pHead1，这样当走到他们的第一个公共节点时，都经过了 <code>a+b+公共节点长度</code> 的距离。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = pHead1;</span><br><span class="line">        ListNode p2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">            p1 = p1 == <span class="keyword">null</span> ? pHead2 : p1.next;</span><br><span class="line">            p2 = p2 == <span class="keyword">null</span> ? pHead1 : p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz37-数字在排序数组中出现的次数">JZ37 数字在排序数组中出现的次数</h3>
<p>题目大意：</p>
<p>统计一个数字在升序数组中出现的次数。</p>
<p>思路：</p>
<p>二分查找，找到指定数字后，分别向前和向后统计出现的次数。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (k == array[mid]) &#123;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="comment">// 往左</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = mid - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(k == array[i]) &#123;</span><br><span class="line">                        num++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 往右</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(k == array[i]) &#123;</span><br><span class="line">                        num++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; array[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz38-二叉树的深度">JZ38 二叉树的深度</h3>
<p>题目大意：</p>
<p>输入一棵二叉树，求该树的深度。</p>
<p>思路：</p>
<p>max(左子树的深度，右子树的深度) + 1 = 当前节点为根节点的深度</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = TreeDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = TreeDepth(root.right);</span><br><span class="line">        <span class="keyword">int</span> result = (left &gt; right ? left : right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz39-平衡二叉树">JZ39 平衡二叉树</h3>
<p>题目大意：</p>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<p>思路：</p>
<p>以每个节点为根，判断当前子树的左右字数的高度差是否大于1。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> treeDepth(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = treeDepth(root.left);</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = treeDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span> (right == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left - right &gt; <span class="number">1</span> || left - right &lt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + (left &gt; right ? left : right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz40-数组中只出现一次的数字">JZ40 数组中只出现一次的数字</h3>
<p>题目大意：</p>
<p>一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<p>思路：将该问题拆分为一个数组里只有一个数字出现了一次的子问题。那么如何做到呢？</p>
<p>可以通过第一遍异或求得异或结果 xor 为只出现一次的两个数字 a，b 之和。然后取出 xor 的最后一位 1，因为是异或得到的结果，所以 a，b 在这一位上不同，令其为 mask。于是可以通过数字在该位上是 1 还是 0 来分为两组。</p>
<p>这样问题转换成为“有一个数组每个数字都出现两次，有一个数字只出现了一次，求出该数字”</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] FindNumsAppearOnce (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// 异或结果 xor 为只出现一次的两个数字a，b之和</span></span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">            xor ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取 xor 最后一位 1，因为是异或得到的结果，所以a和b在这一位上不同</span></span><br><span class="line">        <span class="keyword">int</span> mask = (xor &amp; (xor - <span class="number">1</span>)) ^ xor;</span><br><span class="line">        <span class="comment">// 将数组分为两个部分，一个包含 a，一个包含 b，且数组中其他数字都是成对出现</span></span><br><span class="line">        <span class="comment">// 如何保证其他数字都是在同一个数组中成对出现？</span></span><br><span class="line">        <span class="comment">// 相同的数字一定在同一位上是相同的，那么在 mask 位上同为1或者同为0</span></span><br><span class="line">        <span class="comment">// 一个被分到了某组上，另一个一定会分到同一个组上</span></span><br><span class="line">        <span class="comment">// 问题转换成为“有一个数组每个数字都出现两次，有一个数字只出现了一次，求出该数字”</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; mask) == <span class="number">0</span>) &#123;</span><br><span class="line">                result[<span class="number">0</span>] ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// xor 为两数之和，xor 异或上其他一个就能得到另外一个</span></span><br><span class="line">        result[<span class="number">1</span>] = xor ^ result[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (result[<span class="number">0</span>] &gt; result[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = result[<span class="number">0</span>];</span><br><span class="line">            result[<span class="number">0</span>] = result[<span class="number">1</span>];</span><br><span class="line">            result[<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz41-和为s的连续正数序列">JZ41  和为S的连续正数序列</h3>
<p>题目大意：</p>
<p>找到所有和为S的连续正数序列。</p>
<p>思路：</p>
<p>连续正数序列，可以看作是一个区间的和，求一个区间的和可以利用前缀和来解决。</p>
<p>维护一个变量的值代表当前区间的和，区间和小于 sum 则需要扩大右边界，区间和大于 sum 则需要缩小左边界，等于则记录当前序列。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">2</span>, temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= sum / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; sum) &#123;</span><br><span class="line">                temp += right;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp &gt; sum) &#123;</span><br><span class="line">                temp -= left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; tempList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">                    tempList.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                resList.add(tempList);</span><br><span class="line">                temp -= left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz42-和为s的两个数字">JZ42 和为S的两个数字</h3>
<p>题目大意：</p>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，返回两个数的乘积最小的，如果无法找出这样的数字，返回一个空数组即可。</p>
<p>思路：</p>
<p>二分查找。因为序列是递增有序的，所以可以使用二分查找的思想。当左右边界的和等于 <code>sum</code> 时去比较乘积，来判断用不用更新答案。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = array.length - <span class="number">1</span>, product = Integer.MAX_VALUE;</span><br><span class="line">        ArrayList&lt;Integer&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = array[left] + array[right];</span><br><span class="line">            <span class="keyword">if</span> (temp == sum &amp;&amp; array[left] * array[right] &lt; product) &#123;</span><br><span class="line">                res[<span class="number">0</span>] = array[left];</span><br><span class="line">                res[<span class="number">1</span>] = array[right];</span><br><span class="line">                product = array[left] * array[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp &gt; sum) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (product != Integer.MAX_VALUE) &#123;</span><br><span class="line">            resultList.add(res[<span class="number">0</span>]);</span><br><span class="line">            resultList.add(res[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz43-左旋转字符串">JZ43 左旋转字符串</h3>
<p>题目大意：</p>
<p>对于一个给定的字符序列 S，请你把其循环左移 K 位后的序列输出（保证 K 小于等于 S 的长度）</p>
<p>思路：</p>
<p>找到旋转后字符串的第一位，然后直接利用 substring 把前面的部分截取放到后面去就好了。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.substring(n, str.length()) + str.substring(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz44-翻转单词序列">JZ44 翻转单词序列</h3>
<p>题目大意：</p>
<p>“nowcoder. a am I”翻转成“I am a nowcoder.”</p>
<p>思路：</p>
<p>两种思路。</p>
<p><strong>思路一</strong> 翻转整个字符串变为 “I ma a .redocwon”，然后再翻转每一个单词成为正常顺序，两次翻转。</p>
<p><strong>思路二</strong> 利用栈，按照空格将字符串分割，然后存入栈中。全部存入后再从栈中取出即为正常顺序。</p>
<p>代码：</p>
<p><strong>思路一</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">char</span>[] array = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">2</span>];</span><br><span class="line">        array[<span class="number">0</span>] = <span class="string">' '</span>;</span><br><span class="line">        array[array.length - <span class="number">1</span>] = <span class="string">' '</span>;</span><br><span class="line">        <span class="comment">// 翻转第一次，整个翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            array[<span class="number">1</span> + i] = str.charAt(len - <span class="number">1</span> - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, start = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                <span class="comment">// 翻转第二次，单词翻转</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (i - start - <span class="number">1</span>) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">char</span> ch = array[start + <span class="number">1</span> + j];</span><br><span class="line">                    array[start + <span class="number">1</span> + j] = array[i - <span class="number">1</span> - j];</span><br><span class="line">                    array[i - <span class="number">1</span> - j] = ch;</span><br><span class="line">                &#125;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(array).substring(<span class="number">1</span>,array.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思路二</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">// 按照空格分割字符串</span></span><br><span class="line">        String[] temp = str.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">// 全是空格的清空</span></span><br><span class="line">        <span class="keyword">if</span> (temp.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : temp) &#123;</span><br><span class="line">            stack.push(s);</span><br><span class="line">            stack.push(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉多余的空格</span></span><br><span class="line">        stack.pop();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            sb.append(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz45-扑克牌顺子">JZ45 扑克牌顺子</h3>
<p>题目大意：</p>
<p>给一个长度为 5 的序列，判断是不是顺子，数字范围是 [0, 13]，0 是癞子牌。</p>
<p>思路：</p>
<p><strong>思路1</strong> 0 作为癞子牌可以充当任意数值的牌。将序列排序之后，从后往前遍历：</p>
<ul>
<li>相邻的两个元素之间差值为 1，符合顺子的定义</li>
<li>相邻的两个元素之间差值为 0，说明出现了重复，直接返回 false</li>
<li>相邻的两个元素之间差值大于 1，说明不连续，需要用癞子牌来填充</li>
</ul>
<p>在遍历的过程中记录需要的癞子牌数量以及序列中已有的癞子牌数量，最后判断癞子牌的数量是否大于等于 0，大于等于 0 说明可以组成顺子，如果小于 0 说明癞子牌不够不能组成顺子。</p>
<p><strong>思路2</strong> 利用 set 来保证不重复，出现重复就表示不是顺子。将非零的元素添加到 set 当中，并且记录最大值和最小值，如果最大值和最小值之差大于等于 5 说明无论怎样都不可能是顺子。</p>
<p>代码：</p>
<p><strong>思路1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	    Arrays.sort(numbers);</span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = numbers.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 下一个是0，则添加一张癞子</span></span><br><span class="line">                zero++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = numbers[i] - numbers[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 差值-1 即代表两张牌中间差几张牌</span></span><br><span class="line">                    zero = zero - (temp - <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 两张牌相等一定不是顺子</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zero &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思路2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, min = <span class="number">14</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!set.add(num)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(max, num);</span><br><span class="line">                min = Math.min(min, num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max - min &lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz46-孩子们的游戏圆圈中最后剩下的数">JZ46 孩子们的游戏（圆圈中最后剩下的数）</h3>
<p>题目大意：</p>
<p>随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的出列，并且不再回来。从他的下一个小朋友开始,继续0…m-1报数，直到剩下最后一个小朋友，确定最后一个小朋友的编号。</p>
<p>思路：</p>
<blockquote>
<p>另外一个思路就是去模拟，用一个 List 去存放序列，模拟报数，喊到 <code>m-1</code> 的就删除，最后一个就是答案。</p>
</blockquote>
<p>假设 <code>f(n,m)</code> 表示最终留下元素的序号。长度为 <code>n</code> 的序列会先删除第 <code>m % n</code>  个元素，然后剩下一个长度为 <code>n-1</code>  的序列。递归的去求解 <code>f(n-1,m)</code>，得到最终留下的元素是第 <code>x</code> 个元素。由于是删除了第 <code>m % n</code> 个元素得到的长度为 <code>n-1</code> 的序列，那么长度为 <code>n</code> 的序列最终留下元素应该是从 <code>m % n</code> 开始的第 <code>x</code> 个元素。</p>
<p>所以 <code>f(n,m) = (m % n + f(n-1,m)) % n = (m + f(n-1,m)) % n</code>。</p>
<p>当 <code>n=1</code> 时，<code>f(1,m)=0</code>。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//         int k = m % n;</span></span><br><span class="line"><span class="comment">//         return (LastRemaining_Solution(n - 1, m) + k) % n;</span></span><br><span class="line">        <span class="comment">// 优化算式</span></span><br><span class="line">        <span class="keyword">return</span> (LastRemaining_Solution(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz47-求123n">JZ47 求1+2+3+…+n</h3>
<p>题目大意：</p>
<p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>思路：</p>
<p>求和公式什么的肯定不能用了，考虑递归，但是需要找到如何实现终止条件。正好 &amp;&amp; 操作具有短路的作用，让 n&gt;1 的情况下才会接着往下递归求和，n==1 的情况就直接返回。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> x = (n &gt; <span class="number">1</span> &amp;&amp; ((n += Sum_Solution(n - <span class="number">1</span>)) &gt; <span class="number">0</span>); <span class="comment">// boolean x只是为了不报错</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz48-不用加减乘除做加法">JZ48 不用加减乘除做加法</h3>
<p>题目大意：</p>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<p>思路：</p>
<p>异或操作对应不进位的加法，与操作对应进位的结果。于是我们先按照不带进位的加法求出一个结果，然后如果需要进位的话，把进位结果继续用不带进位的加法加上去，再来看当前操作还需不需要进位，直到不需要进位为止。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//不带进位的加法</span></span><br><span class="line">            result = num1 ^ num2;</span><br><span class="line">             <span class="comment">//进位</span></span><br><span class="line">            carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 进位不为0则继续执行加法处理进位</span></span><br><span class="line">            num1 = result;</span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125; <span class="keyword">while</span>(carry != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz49-把字符串转换成整数">JZ49 把字符串转换成整数</h3>
<p>题目大意：</p>
<p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p>
<p>思理：</p>
<p>参考 JDK 的 <code>Integer.parseInt()</code> 源码</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转换成负数处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> symbol = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] arr = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 处理开头的符号位</span></span><br><span class="line">        <span class="keyword">if</span> (arr[index] == <span class="string">'+'</span> || arr[index] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[index] == <span class="string">'-'</span>) &#123;</span><br><span class="line">                symbol = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, radix = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; arr.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = arr[index];</span><br><span class="line">            <span class="comment">// 非法数值</span></span><br><span class="line">            <span class="keyword">if</span> (!Character.isDigit(ch)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = ch - <span class="string">'0'</span>;</span><br><span class="line">            <span class="comment">// 溢出，表明*10后就会溢出</span></span><br><span class="line">            <span class="keyword">if</span> (ans &lt; Integer.MIN_VALUE / <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans *= radix;</span><br><span class="line">            <span class="comment">// 溢出，表明减去temp就会溢出</span></span><br><span class="line">            <span class="keyword">if</span> (ans &lt; Integer.MIN_VALUE + temp) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans -= temp;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans * symbol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz50-数组中重复的数字">JZ50 <strong>数组中重复的数字</strong></h3>
<p>题目大意：</p>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 请找出数组中任一一个重复的数字，存在不合法的输入的话输出-1。</p>
<p>思路：</p>
<p>因为数字内的所有数字都在 0 到 n-1 的范围内，所以定义一个长度为 n 的数组用来记录数字是否出现过一定不会越界。遍历数组。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">duplicate</span> <span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] table = <span class="keyword">new</span> <span class="keyword">boolean</span>[numbers.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table[num] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">            table[num] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz51-构建乘积数组">JZ51 构建乘积数组</h3>
<p>题目大意：</p>
<p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素 <code>B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]</code>。不能使用除法。</p>
<p>思路：</p>
<p>分为两部分来计算，先计算 <code>A[0]*A[1]**...*A[i-1]</code> 再计算 <code>A[i+1]*...*A[n-1]</code>，将它们乘起来就是最终结果，这样通过两次遍历就能求的结果。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="comment">// 计算 A[i] 左边的乘积</span></span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            B[i] = B[i - <span class="number">1</span>] * A[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 补全右边的乘积，就可以得到最终结果</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            temp *= A[i + <span class="number">1</span>];</span><br><span class="line">            B[i] *= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz52-正则表达式匹配">JZ52 正则表达式匹配</h3>
<p>题目大意：</p>
<p>请实现一个函数用来匹配包括’.‘和’<em>‘的正则表达式。模式中的字符’.‘表示任意一个字符，而’</em>'表示它前面的字符可以出现任意次（包含0次）。</p>
<p>思路：</p>
<p>见注释，记一记这种类型。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span> <span class="params">(String str, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.isEmpty() &amp;&amp; pattern.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!str.isEmpty() &amp;&amp; pattern.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一个是否匹配上</span></span><br><span class="line">        <span class="keyword">boolean</span> firstMatch = (!str.isEmpty()) &amp;&amp; (str.charAt(<span class="number">0</span>) == pattern.charAt(<span class="number">0</span>) || pattern.charAt(<span class="number">0</span>) == <span class="string">'.'</span>);</span><br><span class="line">        <span class="comment">// 下一个pattern为*</span></span><br><span class="line">        <span class="keyword">if</span> (pattern.length() &gt; <span class="number">1</span> &amp;&amp; pattern.charAt(<span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                   <span class="comment">// 匹配0个</span></span><br><span class="line">            <span class="keyword">return</span> match(str, pattern.substring(<span class="number">2</span>))</span><br><span class="line">                   <span class="comment">// 匹配多个</span></span><br><span class="line">                || (firstMatch &amp;&amp; match(str.substring(<span class="number">1</span>), pattern));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 下一个pattern不为*</span></span><br><span class="line">            <span class="keyword">return</span> firstMatch &amp;&amp; match(str.substring(<span class="number">1</span>), pattern.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz53-表示数值的字符串">JZ53 表示数值的字符串</h3>
<p>题目大意：</p>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</p>
<p>思路：</p>
<p>确保几点：</p>
<ul>
<li>小数点只能有一个，并且必须在e前面</li>
<li>e只能有一个，并且不能在首位和末位</li>
<li>e左边运算符只能有一个，并且只能在第一位</li>
<li>e右边运算符只能有一个，并且只能紧挨e后面</li>
<li>不能出现.±eE和数字以外的字符</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">boolean</span> point = <span class="keyword">false</span>;<span class="comment">//表示小数点是否已存在</span></span><br><span class="line">        <span class="keyword">boolean</span> e = <span class="keyword">false</span>;<span class="comment">//表示e是否已存在</span></span><br><span class="line">        <span class="keyword">boolean</span> lOperator = <span class="keyword">false</span>;<span class="comment">//表示e左边运算符是否已存在</span></span><br><span class="line">        <span class="keyword">boolean</span> rOperator = <span class="keyword">false</span>;<span class="comment">//表示e右边运算符是否已存在</span></span><br><span class="line">        <span class="keyword">int</span> len = chars.length;</span><br><span class="line">        <span class="keyword">int</span> eIndex = len;<span class="comment">//e出现的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (point || i &gt; eIndex) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//小数点只能有一个，并且必须在e前面</span></span><br><span class="line">                point = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (chars[i] == <span class="string">'e'</span> || chars[i] == <span class="string">'E'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (e || i == <span class="number">0</span> || i == len-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//e只能有一个，并且不能在首位和末位</span></span><br><span class="line">                eIndex = i;</span><br><span class="line">                e = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (chars[i] == <span class="string">'+'</span> || chars[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; eIndex)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (lOperator || i != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//e左边运算符只能有一个，并且只能在第一位</span></span><br><span class="line">                    lOperator = <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (rOperator || i - eIndex != <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//e右边运算符只能有一个,并且只能紧挨e后面</span></span><br><span class="line">                    rOperator = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (chars[i] &gt;= <span class="string">'0'</span> &amp;&amp; chars[i] &lt;= <span class="string">'9'</span>)&#123;<span class="comment">//数字出现在哪都可以</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//不能出现.+-eE和数字以外的字符</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz54-字符流中第一个不重复的字符">JZ54 字符流中第一个不重复的字符</h3>
<p>题目大意：</p>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。</p>
<p>思路：</p>
<p>利用一个队列来存储当前轮次，第一个只出现一次的字符；一个数组用来统计出现的次数。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] table = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次出现</span></span><br><span class="line">        <span class="keyword">if</span> (++table[ch] == <span class="number">1</span>) &#123;</span><br><span class="line">            queue.offer(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = queue.peek();</span><br><span class="line">            <span class="keyword">if</span> (table[ch] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ch;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 说明队列头出现了不止一次，出队</span></span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 队列为空说明不存在出现一次的字符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz55-链表中环的入口节点">JZ55 链表中环的入口节点</h3>
<p>题目大意：</p>
<p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。</p>
<p>思路：</p>
<p>利用快慢指针的思想。如果存在环，假设头结点为 A，环的入口节点为 B，当快慢指针相遇的时候，相遇在节点 C。由快指针比慢指针多走了一倍的距离，有：$2(AB + BC) = AB + BC + CB + BC$，化简后得到 $AB = CB$。由此可以推出，此时我们新建一个入口节点，从头结点开始往后遍历，慢节点也继续往后遍历。</p>
<p>当慢节点从 C 走到 B后，入口节点也从 A 走到了 B，此时它们在入口节点相遇。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        ListNode fast = pHead, slow = pHead;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode entryNode = pHead;</span><br><span class="line">                <span class="keyword">while</span> (entryNode != slow) &#123;</span><br><span class="line">                    entryNode = entryNode.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> entryNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz56-删除链表中重复的结点">JZ56 删除链表中重复的结点</h3>
<p>题目大意：</p>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。</p>
<p>思路：</p>
<p>为了方便处理头结点重复的情况，添加哑元节点 dummyNode。需要删除结点，所以为了保证链表连续，肯定需要一个 preNode 来记录上一个结点。外加一个当前结点 curNode，所以一共需要定义两个结点变量。</p>
<p>判断 curNode 和 curNode.next 的值是否一样，一样的话删除 curNode，然后一直找到值不等于的结点，再将 preNode.next 置为该节点。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        ListNode outputNode = <span class="keyword">new</span> ListNode(Integer.MAX_VALUE);</span><br><span class="line">        ListNode preNode = outputNode, curNode = pHead;</span><br><span class="line">        preNode.next = curNode;</span><br><span class="line">        <span class="keyword">while</span> (curNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = curNode.val;</span><br><span class="line">            <span class="keyword">boolean</span> isRepeat = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 存在下一个节点，且节点值重复，删掉</span></span><br><span class="line">            <span class="keyword">while</span> (curNode.next != <span class="keyword">null</span> &amp;&amp; curNode.next.val == val) &#123;</span><br><span class="line">                isRepeat = <span class="keyword">true</span>;</span><br><span class="line">                ListNode tempNode = curNode.next.next;</span><br><span class="line">                curNode.next.next = <span class="keyword">null</span>;</span><br><span class="line">                curNode.next = tempNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 节点重复了，删掉</span></span><br><span class="line">            <span class="keyword">if</span> (isRepeat) &#123;</span><br><span class="line">                ListNode tempNode = curNode.next;</span><br><span class="line">                curNode.next = <span class="keyword">null</span>;</span><br><span class="line">                curNode = tempNode;</span><br><span class="line">                preNode.next = curNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                preNode = preNode.next;</span><br><span class="line">                curNode = curNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outputNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz57-二叉树的下一个结点">JZ57 二叉树的下一个结点</h3>
<p>题目大意：</p>
<p>给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。</p>
<p>思路：</p>
<p>这类问题需要根据二叉树的性值，分情况讨论。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 有右子树，下一个节点就是右子树中的最左节点</span></span><br><span class="line">        <span class="keyword">if</span> (pNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pNode = pNode.right;</span><br><span class="line">            <span class="keyword">while</span> (pNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pNode = pNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 无右子树，当前节点是父节点的左子树，下一个节点就是其父节点</span></span><br><span class="line">        <span class="keyword">if</span> (pNode.next != <span class="keyword">null</span> &amp;&amp; pNode.next.left == pNode) &#123;</span><br><span class="line">            <span class="keyword">return</span> pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 无右子树，当前节点是父节点的右节点，则沿着父节点追溯</span></span><br><span class="line">        <span class="comment">//    直到某个节点是其父节点的左子树</span></span><br><span class="line">        <span class="keyword">if</span> (pNode.next != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">while</span> (pNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pNode.next.left == pNode) &#123;</span><br><span class="line">                    <span class="keyword">return</span> pNode.next;</span><br><span class="line">                &#125;</span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 4. 没有找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz58-对称的二叉树">JZ58 对称的二叉树</h3>
<p>题目大意：</p>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p>思路：</p>
<p>镜像相同，说明需要满足：</p>
<ol>
<li><code>p1.val == p2.val</code></li>
<li><code>p1.left == p2.right</code></li>
<li><code>p1.right == p2.left</code></li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> judgeTree(pRoot, pRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">judgeTree</span><span class="params">(TreeNode p1, TreeNode p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="keyword">null</span> &amp;&amp; p2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="keyword">null</span> || p2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1.val == p2.val &amp;&amp; judgeTree(p1.left, p2.right) &amp;&amp; judgeTree(p1.right, p2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz59-按之字形顺序打印二叉树">JZ59 按之字形顺序打印二叉树</h3>
<p>题目大意：</p>
<p>给定一颗二叉树，假设根节点为第一层，按照奇数层，从左到右打印，偶数层，从右到左打印。</p>
<p>思路：</p>
<p>层次遍历打印二叉树，用队列实现。这道题是层次遍历二叉树+确定当前遍历到哪一层两种模板的结合。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resList;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(pRoot);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            level++;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            ArrayList&lt;Integer&gt; tempList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                size--;</span><br><span class="line">                TreeNode tempNode = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (level % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    tempList.add(<span class="number">0</span>, tempNode.val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tempList.add(tempNode.val);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (tempNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(tempNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (tempNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(tempNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            resList.add(tempList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz60-把二叉树打印成多行">JZ60 把二叉树打印成多行</h3>
<p>题目大意：</p>
<p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<p>思路：</p>
<p>确定当前遍历到哪层的模板，每一层加入到集合中。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resList;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(pRoot);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            ArrayList&lt;Integer&gt; tempList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (; size &gt; <span class="number">0</span>; size--) &#123;</span><br><span class="line">                TreeNode tempNode = queue.poll();</span><br><span class="line">                tempList.add(tempNode.val);</span><br><span class="line">                <span class="keyword">if</span> (tempNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(tempNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (tempNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(tempNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            resList.add(tempList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz61-序列化二叉树">JZ61 序列化二叉树</h3>
<p>题目大意：</p>
<p>请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
<p>思路：</p>
<p><strong>序列化</strong>主要就是通过将这颗树以一种方式进行顺序化。我们就将这颗二叉树进行先序遍历，得到访问这颗二叉树的一个访问顺序。</p>
<p><strong>反序列化</strong>时，根据 str 提供的先序访问顺序，遍历 str 去构建各个二叉树结点，然后根据先序的顺序来构建结点之间的关系。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    String[] list = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//序列化主要就是通过将这颗树以一种方式进行顺序化。我们就将这颗二叉树进行先序遍历，得到访问这颗二叉树的一个访问顺序</span></span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">"#,"</span>);</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(root.val + <span class="string">","</span>);</span><br><span class="line">        sb.append(Serialize(root.left));</span><br><span class="line">        sb.append(Serialize(root.right));</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">            list = str.split(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= list.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list[index].equals(<span class="string">"#"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(list[index]));</span><br><span class="line">        root.left = Deserialize(str);</span><br><span class="line">        root.right = Deserialize(str);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz62-二叉搜索树的第k个节点">JZ62 二叉搜索树的第k个节点</h3>
<p>题目大意：</p>
<p>给定一棵二叉搜索树，请找出其中的第k小的TreeNode结点。</p>
<p>思路：</p>
<p>二叉搜索树的中序遍历是有序的，所以利用中序遍历，找到第k个节点即可。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        TreeNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode tempNode = pRoot;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || tempNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (tempNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(tempNode);</span><br><span class="line">                tempNode = tempNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            tempNode = stack.pop();</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                resNode = tempNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tempNode = tempNode.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz63-数据流中的中位数">JZ63 数据流中的中位数</h3>
<p>题目大意：</p>
<p>得到一个数据流中的中位数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (list.get(mid) &lt; num) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(left, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        <span class="keyword">if</span> (size % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(list.get(size / <span class="number">2</span>) + list.get(size / <span class="number">2</span> - <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(list.get(size / <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz64-滑动窗口的最大值">JZ64 滑动窗口的最大值</h3>
<p>题目大意：</p>
<p>思路：</p>
<p>利用双端队列来保存窗口内的最大值的下标，最大值保存在头部。</p>
<p>每次插入的时候，从后往前依次弹出比当前 num 小的元素，因为当前 num 比栈中元素大，说明栈中元素和当前元素在同一区间内时，它们没有资格称为最大的元素，所以弹出。</p>
<p>当下标大于 size 时，找到第一个下标在区间内的元素即为当前区间内最大的元素。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// https://cuijiahua.com/blog/2018/02/basis_64.html</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; num.length || size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存下标，使用双端队列 缓存滑动窗口，最大值保存在头部</span></span><br><span class="line">        ArrayDeque&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 从后面依次弹出队列中比当前num值小的元素，同时也能保证队列首元素为当前窗口最大值下标</span></span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; num[queue.peekLast()] &lt; num[i]) &#123;</span><br><span class="line">                queue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当队首元素坐标对应的num不在窗口中，需要弹出</span></span><br><span class="line">            <span class="keyword">if</span> (!queue.isEmpty() &amp;&amp; i - queue.peekFirst() &gt;= size) &#123;</span><br><span class="line">                queue.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把每次滑动的num下标加入队列</span></span><br><span class="line">            queue.offerLast(i);</span><br><span class="line">            <span class="comment">// 当滑动窗口首地址i大于等于size时才开始写入窗口最大值</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= size) &#123;</span><br><span class="line">                resList.add(num[queue.peekFirst()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz65-矩阵中的路径">JZ65 矩阵中的路径</h3>
<p>题目大意：</p>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。</p>
<p>思路：</p>
<p>dfs 遍历图，类似孤岛问题。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span> <span class="params">(<span class="keyword">char</span>[][] matrix, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (judge(matrix, i, j, <span class="keyword">new</span> <span class="keyword">boolean</span>[n][m], word, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] visited, String word, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!inArea(matrix, i, j) || visited[i][j] || index &gt; word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == word.charAt(index)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            res = judge(matrix, i + <span class="number">1</span>, j, visited, word, index + <span class="number">1</span>)</span><br><span class="line">                       || judge(matrix, i, j + <span class="number">1</span>, visited, word, index + <span class="number">1</span>)</span><br><span class="line">                       || judge(matrix, i - <span class="number">1</span>, j, visited, word, index + <span class="number">1</span>)</span><br><span class="line">                       || judge(matrix, i, j - <span class="number">1</span>, visited, word, index + <span class="number">1</span>);</span><br><span class="line">            visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">char</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; matrix.length &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz66-机器人的运动范围">JZ66 机器人的运动范围</h3>
<p>题目大意：</p>
<p>地上有一个rows行和cols列的方格。坐标从 [0,0] 到 [rows-1,cols-1]。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于threshold的格子。 例如，当threshold为18时，机器人能够进入方格[35,37]，因为3+5+3+7 = 18。但是，它不能进入方格[35,38]，因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p>思路：</p>
<p>用一维数组去表示矩阵，每次通过 i、j 来计算在数组中的具体哪个位置。</p>
<p>然后类似海岛问题，dfs 去数个数。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows * cols];</span><br><span class="line">        <span class="keyword">return</span> count(visited, threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = i * cols + j;</span><br><span class="line">        <span class="keyword">if</span> (!judge(threshold, rows, cols, i, j) || visited[index]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[index] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            + count(visited, threshold, rows, cols, i + <span class="number">1</span>, j)</span><br><span class="line">            + count(visited, threshold, rows, cols, i - <span class="number">1</span>, j)</span><br><span class="line">            + count(visited, threshold, rows, cols, i, j + <span class="number">1</span>)</span><br><span class="line">            + count(visited, threshold, rows, cols, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += i % <span class="number">10</span>;</span><br><span class="line">            i /=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += j % <span class="number">10</span>;</span><br><span class="line">            j /=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &lt;= threshold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jz67-剪绳子">JZ67 剪绳子</h3>
<p>题目大意：</p>
<p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为k[1],…,k[m]。请问k[1]x…xk[m]可能的最大乘积是多少？</p>
<p>思路：</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">2</span> || target &gt; <span class="number">61</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数学规律：将 target 贪心分解，优先分解为3，其次是2能达到最大乘积</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> element = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span> (target &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 上一轮 target=4，4 应该被分解为 2+2</span></span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">1</span>) &#123;</span><br><span class="line">                result = result / element * <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">2</span>)&#123;</span><br><span class="line">                result *= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target -= element;</span><br><span class="line">            &#125;</span><br><span class="line">            result *= element;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/算法—表达式求值的通用解法/" data-toggle="tooltip" data-placement="top" title="表达式求值的通用解法">&larr; 上一篇</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/leetcode解题报告/" data-toggle="tooltip" data-placement="top" title="leetcode解题报告">下一篇 &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">目录</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz1-二维数组中的查找"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">JZ1 &#x4E8C;&#x7EF4;&#x6570;&#x7EC4;&#x4E2D;&#x7684;&#x67E5;&#x627E;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz2-替换空格"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">JZ2 &#x66FF;&#x6362;&#x7A7A;&#x683C;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz3-从尾到头打印链表"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">JZ3 &#x4ECE;&#x5C3E;&#x5230;&#x5934;&#x6253;&#x5370;&#x94FE;&#x8868;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz4-重建二叉树"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">JZ4 &#x91CD;&#x5EFA;&#x4E8C;&#x53C9;&#x6811;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz5-用两个栈实现队列"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">JZ5 &#x7528;&#x4E24;&#x4E2A;&#x6808;&#x5B9E;&#x73B0;&#x961F;&#x5217;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz6-旋转数组的最小数字"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">JZ6 &#x65CB;&#x8F6C;&#x6570;&#x7EC4;&#x7684;&#x6700;&#x5C0F;&#x6570;&#x5B57;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz7-斐波那契数列"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">JZ7 &#x6590;&#x6CE2;&#x90A3;&#x5951;&#x6570;&#x5217;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz8-跳台阶"><span class="toc-nav-number">8.</span> <span class="toc-nav-text">JZ8  &#x8DF3;&#x53F0;&#x9636;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz9-变态跳台阶"><span class="toc-nav-number">9.</span> <span class="toc-nav-text">JZ9 &#x53D8;&#x6001;&#x8DF3;&#x53F0;&#x9636;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz10-矩形覆盖"><span class="toc-nav-number">10.</span> <span class="toc-nav-text">JZ10 &#x77E9;&#x5F62;&#x8986;&#x76D6;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz11-二进制中1的个数"><span class="toc-nav-number">11.</span> <span class="toc-nav-text">JZ11 &#x4E8C;&#x8FDB;&#x5236;&#x4E2D;1&#x7684;&#x4E2A;&#x6570;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz12-数值的整数次方"><span class="toc-nav-number">12.</span> <span class="toc-nav-text">JZ12 &#x6570;&#x503C;&#x7684;&#x6574;&#x6570;&#x6B21;&#x65B9;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz13-调整数组顺序使奇数位于偶数前面"><span class="toc-nav-number">13.</span> <span class="toc-nav-text">JZ13 &#x8C03;&#x6574;&#x6570;&#x7EC4;&#x987A;&#x5E8F;&#x4F7F;&#x5947;&#x6570;&#x4F4D;&#x4E8E;&#x5076;&#x6570;&#x524D;&#x9762;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz14-链表中倒数第k个结点"><span class="toc-nav-number">14.</span> <span class="toc-nav-text">JZ14 &#x94FE;&#x8868;&#x4E2D;&#x5012;&#x6570;&#x7B2C;k&#x4E2A;&#x7ED3;&#x70B9;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz15-反转链表"><span class="toc-nav-number">15.</span> <span class="toc-nav-text">JZ15 &#x53CD;&#x8F6C;&#x94FE;&#x8868;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz16-合并两个排序的链表"><span class="toc-nav-number">16.</span> <span class="toc-nav-text">JZ16 &#x5408;&#x5E76;&#x4E24;&#x4E2A;&#x6392;&#x5E8F;&#x7684;&#x94FE;&#x8868;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz17-树的子结构"><span class="toc-nav-number">17.</span> <span class="toc-nav-text">JZ17 &#x6811;&#x7684;&#x5B50;&#x7ED3;&#x6784;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz18-二叉树的镜像"><span class="toc-nav-number">18.</span> <span class="toc-nav-text">JZ18 &#x4E8C;&#x53C9;&#x6811;&#x7684;&#x955C;&#x50CF;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz19-顺时针打印矩阵"><span class="toc-nav-number">19.</span> <span class="toc-nav-text">JZ19  &#x987A;&#x65F6;&#x9488;&#x6253;&#x5370;&#x77E9;&#x9635;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz20-包含min函数的栈"><span class="toc-nav-number">20.</span> <span class="toc-nav-text">JZ20  &#x5305;&#x542B;min&#x51FD;&#x6570;&#x7684;&#x6808;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz21-栈的压入-弹出序列"><span class="toc-nav-number">21.</span> <span class="toc-nav-text">JZ21 &#x6808;&#x7684;&#x538B;&#x5165;&#x3001;&#x5F39;&#x51FA;&#x5E8F;&#x5217;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz22-从上往下打印二叉树"><span class="toc-nav-number">22.</span> <span class="toc-nav-text">JZ22 &#x4ECE;&#x4E0A;&#x5F80;&#x4E0B;&#x6253;&#x5370;&#x4E8C;&#x53C9;&#x6811;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz23-二叉搜索树的后序遍历序列"><span class="toc-nav-number">23.</span> <span class="toc-nav-text">JZ23 &#x4E8C;&#x53C9;&#x641C;&#x7D22;&#x6811;&#x7684;&#x540E;&#x5E8F;&#x904D;&#x5386;&#x5E8F;&#x5217;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz24-二叉树中和为某一值的路径"><span class="toc-nav-number">24.</span> <span class="toc-nav-text">JZ24 &#x4E8C;&#x53C9;&#x6811;&#x4E2D;&#x548C;&#x4E3A;&#x67D0;&#x4E00;&#x503C;&#x7684;&#x8DEF;&#x5F84;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz25-复杂链表的复制"><span class="toc-nav-number">25.</span> <span class="toc-nav-text">JZ25 &#x590D;&#x6742;&#x94FE;&#x8868;&#x7684;&#x590D;&#x5236;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz26-二叉搜索树与双向链表"><span class="toc-nav-number">26.</span> <span class="toc-nav-text">JZ26  &#x4E8C;&#x53C9;&#x641C;&#x7D22;&#x6811;&#x4E0E;&#x53CC;&#x5411;&#x94FE;&#x8868;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz27-字符串的排列"><span class="toc-nav-number">27.</span> <span class="toc-nav-text">JZ27  &#x5B57;&#x7B26;&#x4E32;&#x7684;&#x6392;&#x5217;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz28-数组中出现次数超过一半的数字"><span class="toc-nav-number">28.</span> <span class="toc-nav-text">JZ28  &#x6570;&#x7EC4;&#x4E2D;&#x51FA;&#x73B0;&#x6B21;&#x6570;&#x8D85;&#x8FC7;&#x4E00;&#x534A;&#x7684;&#x6570;&#x5B57;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz29-最小的k个数"><span class="toc-nav-number">29.</span> <span class="toc-nav-text">&#x25B2;JZ29 &#x6700;&#x5C0F;&#x7684;k&#x4E2A;&#x6570;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz30-连续子数组的最大和"><span class="toc-nav-number">30.</span> <span class="toc-nav-text">JZ30 &#x8FDE;&#x7EED;&#x5B50;&#x6570;&#x7EC4;&#x7684;&#x6700;&#x5927;&#x548C;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz31-整数中1出现的次数从1到n整数中1出现的次数"><span class="toc-nav-number">31.</span> <span class="toc-nav-text">JZ31 &#x6574;&#x6570;&#x4E2D;1&#x51FA;&#x73B0;&#x7684;&#x6B21;&#x6570;&#xFF08;&#x4ECE;1&#x5230;n&#x6574;&#x6570;&#x4E2D;1&#x51FA;&#x73B0;&#x7684;&#x6B21;&#x6570;&#xFF09;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz32-把数组排成最小的数"><span class="toc-nav-number">32.</span> <span class="toc-nav-text">JZ32  &#x628A;&#x6570;&#x7EC4;&#x6392;&#x6210;&#x6700;&#x5C0F;&#x7684;&#x6570;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz33-丑数"><span class="toc-nav-number">33.</span> <span class="toc-nav-text">&#x25B2;JZ33  &#x4E11;&#x6570;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz34-第一个只出现一次的字符位置"><span class="toc-nav-number">34.</span> <span class="toc-nav-text">JZ34 &#x7B2C;&#x4E00;&#x4E2A;&#x53EA;&#x51FA;&#x73B0;&#x4E00;&#x6B21;&#x7684;&#x5B57;&#x7B26;&#x4F4D;&#x7F6E;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz35-数组中的逆序对"><span class="toc-nav-number">35.</span> <span class="toc-nav-text">&#x25B2;JZ35  &#x6570;&#x7EC4;&#x4E2D;&#x7684;&#x9006;&#x5E8F;&#x5BF9;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz36-两个链表的第一个公共结点"><span class="toc-nav-number">36.</span> <span class="toc-nav-text">JZ36  &#x4E24;&#x4E2A;&#x94FE;&#x8868;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x516C;&#x5171;&#x7ED3;&#x70B9;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz37-数字在排序数组中出现的次数"><span class="toc-nav-number">37.</span> <span class="toc-nav-text">JZ37 &#x6570;&#x5B57;&#x5728;&#x6392;&#x5E8F;&#x6570;&#x7EC4;&#x4E2D;&#x51FA;&#x73B0;&#x7684;&#x6B21;&#x6570;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz38-二叉树的深度"><span class="toc-nav-number">38.</span> <span class="toc-nav-text">JZ38 &#x4E8C;&#x53C9;&#x6811;&#x7684;&#x6DF1;&#x5EA6;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz39-平衡二叉树"><span class="toc-nav-number">39.</span> <span class="toc-nav-text">JZ39 &#x5E73;&#x8861;&#x4E8C;&#x53C9;&#x6811;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz40-数组中只出现一次的数字"><span class="toc-nav-number">40.</span> <span class="toc-nav-text">JZ40 &#x6570;&#x7EC4;&#x4E2D;&#x53EA;&#x51FA;&#x73B0;&#x4E00;&#x6B21;&#x7684;&#x6570;&#x5B57;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz41-和为s的连续正数序列"><span class="toc-nav-number">41.</span> <span class="toc-nav-text">JZ41  &#x548C;&#x4E3A;S&#x7684;&#x8FDE;&#x7EED;&#x6B63;&#x6570;&#x5E8F;&#x5217;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz42-和为s的两个数字"><span class="toc-nav-number">42.</span> <span class="toc-nav-text">JZ42 &#x548C;&#x4E3A;S&#x7684;&#x4E24;&#x4E2A;&#x6570;&#x5B57;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz43-左旋转字符串"><span class="toc-nav-number">43.</span> <span class="toc-nav-text">JZ43 &#x5DE6;&#x65CB;&#x8F6C;&#x5B57;&#x7B26;&#x4E32;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz44-翻转单词序列"><span class="toc-nav-number">44.</span> <span class="toc-nav-text">JZ44 &#x7FFB;&#x8F6C;&#x5355;&#x8BCD;&#x5E8F;&#x5217;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz45-扑克牌顺子"><span class="toc-nav-number">45.</span> <span class="toc-nav-text">JZ45 &#x6251;&#x514B;&#x724C;&#x987A;&#x5B50;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz46-孩子们的游戏圆圈中最后剩下的数"><span class="toc-nav-number">46.</span> <span class="toc-nav-text">JZ46 &#x5B69;&#x5B50;&#x4EEC;&#x7684;&#x6E38;&#x620F;&#xFF08;&#x5706;&#x5708;&#x4E2D;&#x6700;&#x540E;&#x5269;&#x4E0B;&#x7684;&#x6570;&#xFF09;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz47-求123n"><span class="toc-nav-number">47.</span> <span class="toc-nav-text">JZ47 &#x6C42;1+2+3+&#x2026;+n</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz48-不用加减乘除做加法"><span class="toc-nav-number">48.</span> <span class="toc-nav-text">JZ48 &#x4E0D;&#x7528;&#x52A0;&#x51CF;&#x4E58;&#x9664;&#x505A;&#x52A0;&#x6CD5;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz49-把字符串转换成整数"><span class="toc-nav-number">49.</span> <span class="toc-nav-text">JZ49 &#x628A;&#x5B57;&#x7B26;&#x4E32;&#x8F6C;&#x6362;&#x6210;&#x6574;&#x6570;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz50-数组中重复的数字"><span class="toc-nav-number">50.</span> <span class="toc-nav-text">JZ50 <strong>&#x6570;&#x7EC4;&#x4E2D;&#x91CD;&#x590D;&#x7684;&#x6570;&#x5B57;</strong></span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz51-构建乘积数组"><span class="toc-nav-number">51.</span> <span class="toc-nav-text">JZ51 &#x6784;&#x5EFA;&#x4E58;&#x79EF;&#x6570;&#x7EC4;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz52-正则表达式匹配"><span class="toc-nav-number">52.</span> <span class="toc-nav-text">JZ52 &#x6B63;&#x5219;&#x8868;&#x8FBE;&#x5F0F;&#x5339;&#x914D;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz53-表示数值的字符串"><span class="toc-nav-number">53.</span> <span class="toc-nav-text">JZ53 &#x8868;&#x793A;&#x6570;&#x503C;&#x7684;&#x5B57;&#x7B26;&#x4E32;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz54-字符流中第一个不重复的字符"><span class="toc-nav-number">54.</span> <span class="toc-nav-text">JZ54 &#x5B57;&#x7B26;&#x6D41;&#x4E2D;&#x7B2C;&#x4E00;&#x4E2A;&#x4E0D;&#x91CD;&#x590D;&#x7684;&#x5B57;&#x7B26;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz55-链表中环的入口节点"><span class="toc-nav-number">55.</span> <span class="toc-nav-text">JZ55 &#x94FE;&#x8868;&#x4E2D;&#x73AF;&#x7684;&#x5165;&#x53E3;&#x8282;&#x70B9;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz56-删除链表中重复的结点"><span class="toc-nav-number">56.</span> <span class="toc-nav-text">JZ56 &#x5220;&#x9664;&#x94FE;&#x8868;&#x4E2D;&#x91CD;&#x590D;&#x7684;&#x7ED3;&#x70B9;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz57-二叉树的下一个结点"><span class="toc-nav-number">57.</span> <span class="toc-nav-text">JZ57 &#x4E8C;&#x53C9;&#x6811;&#x7684;&#x4E0B;&#x4E00;&#x4E2A;&#x7ED3;&#x70B9;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz58-对称的二叉树"><span class="toc-nav-number">58.</span> <span class="toc-nav-text">JZ58 &#x5BF9;&#x79F0;&#x7684;&#x4E8C;&#x53C9;&#x6811;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz59-按之字形顺序打印二叉树"><span class="toc-nav-number">59.</span> <span class="toc-nav-text">JZ59 &#x6309;&#x4E4B;&#x5B57;&#x5F62;&#x987A;&#x5E8F;&#x6253;&#x5370;&#x4E8C;&#x53C9;&#x6811;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz60-把二叉树打印成多行"><span class="toc-nav-number">60.</span> <span class="toc-nav-text">JZ60 &#x628A;&#x4E8C;&#x53C9;&#x6811;&#x6253;&#x5370;&#x6210;&#x591A;&#x884C;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz61-序列化二叉树"><span class="toc-nav-number">61.</span> <span class="toc-nav-text">JZ61 &#x5E8F;&#x5217;&#x5316;&#x4E8C;&#x53C9;&#x6811;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz62-二叉搜索树的第k个节点"><span class="toc-nav-number">62.</span> <span class="toc-nav-text">JZ62 &#x4E8C;&#x53C9;&#x641C;&#x7D22;&#x6811;&#x7684;&#x7B2C;k&#x4E2A;&#x8282;&#x70B9;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz63-数据流中的中位数"><span class="toc-nav-number">63.</span> <span class="toc-nav-text">JZ63 &#x6570;&#x636E;&#x6D41;&#x4E2D;&#x7684;&#x4E2D;&#x4F4D;&#x6570;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz64-滑动窗口的最大值"><span class="toc-nav-number">64.</span> <span class="toc-nav-text">JZ64 &#x6ED1;&#x52A8;&#x7A97;&#x53E3;&#x7684;&#x6700;&#x5927;&#x503C;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz65-矩阵中的路径"><span class="toc-nav-number">65.</span> <span class="toc-nav-text">JZ65 &#x77E9;&#x9635;&#x4E2D;&#x7684;&#x8DEF;&#x5F84;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz66-机器人的运动范围"><span class="toc-nav-number">66.</span> <span class="toc-nav-text">JZ66 &#x673A;&#x5668;&#x4EBA;&#x7684;&#x8FD0;&#x52A8;&#x8303;&#x56F4;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jz67-剪绳子"><span class="toc-nav-number">67.</span> <span class="toc-nav-text">JZ67 &#x526A;&#x7EF3;&#x5B50;</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">标签</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#algorithm" title="algorithm">algorithm</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
				<!--
                
                <hr>
                <h5>朋友们</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://tyzhang.top/" target="_blank">ztygalaxy</a></li>
                    
                        <li><a href="http://www.tangyincheng.com/" target="_blank">yctang</a></li>
                    
                        <li><a href="https://dolnw.github.io" target="_blank">JCWang</a></li>
                    
                </ul>
                
				-->
            </div>
        </div>
    </div>
</article>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: ''
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


<!-- chrome Firefox 中文锚点定位失效-->
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<!-- smooth scroll behavior polyfill  -->
<script type="text/javascript" src="/js/smoothscroll.js"></script>
<script>
        $('#toc').on('click','a',function(a){
            // var isChrome = window.navigator.userAgent.indexOf("Chrome") !== -1;
            // console.log(window.navigator.userAgent,isChrome)
                // if(isChrome) {
                    // console.log(a.currentTarget.outerHTML);
                    // console.log($(a.currentTarget).attr("href"));
                    //跳转到指定锚点
                    // document.getElementById(a.target.innerText.toLowerCase()).scrollIntoView(true);
                    document.getElementById($(a.currentTarget).attr("href").replace("#","")).scrollIntoView({behavior: 'smooth' });
                // }
        })  
</script>


    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                
				
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/songzblink">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 宋正兵 2021 
                    <br>
                    Theme by <a href="http://www.huweihuang.com">Huwei Huang</a>
                    re-Ported by <a href="https://github.com/ztygalaxy">ztygalaxy</a>
					
					<br>
                    <a href="http://www.beian.miit.gov.cn/" style="color: gray">浙ICP备2021018896号</a>
					<br>
					<!-- <p class="copyright text-muted" style="margin-top: 5px"> -->
						<img src="../../img/备案图标.png"/>
						<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null" style="color: gray">null</a>
					<!-- </p> -->
					
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("zbsong.top/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="zbsong.top/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
