<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/logo.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          Java并发一文流 - 宋正兵的博客 | zbsong Blog
        
    </title>

    <link rel="canonical" href="zbsong.top/article/Java并发/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('https://api.dujin.org/bing/1920.php')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#note" title="note">note</a>
                            
                        </div>
                        <h1>Java并发一文流</h1>
                        <!-- <h2 class="subheading">基础概念、synchronized、cas、AQS</h2> -->
                        <span class="meta">
                            宋正兵 on
                            2021-06-27
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">songzblink</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">主页</a>
                    </li>
					<li>
                        <a href="/archive/">归档</a>
                    </li>
					<li>
                        <a href="/tags/">标签</a>
                    </li>
					<li>
                        <a href="/about/">关于</a>
                    </li>
					<!--
					修改about在前面的问题
                    
                        
                    
                        
                        <li>
                            <a href="/about/">关于</a>
                        </li>
                        
                    
                        
                        <li>
                            <a href="/archive/">归档</a>
                        </li>
                        
                    
                        
                        <li>
                            <a href="/tags/">标签</a>
                        </li>
                        
                    
                    -->
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
	// querySelector 获取文档中 id="demo" 的元素
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				
                <h3 id="1什么是线程和进程">1.什么是线程和进程？</h3>
<p>进程就是程序执行一次的过程，使系统运行程序的基本单位。系统运行一个程序就是一个进程从创建、运行到消亡的过程。</p>
<p>线程是一个比进程更小的执行单位。一个进程在其运行过程中可以产生多个线程。多个线程可以共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但是每个线程都有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。</p>
<blockquote>
<p>Java 程序中，main 线程执行 main 方法。<strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行</strong></p>
</blockquote>
<h3 id="2线程与进程的关系">2.线程与进程的关系</h3>
<p>一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但是每个线程都得有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。</p>
<p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</p>
<p>扩展：为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？为什么堆和方法区是线程共享的呢？</p>
<p><strong>程序计数器</strong>的作用是告诉当前线程下一行需要执行的代码在哪里，即告诉字节码解释器下一条指令的位置，应该保证每个线程所执行的内容相互独立，所以理所当然的是私有的。</p>
<blockquote>
<p>如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
</blockquote>
<p><strong>虚拟机栈</strong>它是描述了 Java 方法执行的模型，即线程每调用一次方法就会在虚拟机栈中创建一个栈帧，每个栈帧内包含局部变量表和操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。<strong>本地方法栈</strong>和 Java 虚拟机栈作用相同，只不过本地方法栈是为 native 方法服务的。为了保证线程中的局部变量不被别的线程访问，它们必须是私有的</p>
<p><strong>堆</strong>和<strong>方法区</strong>是所有线程共享的资源，其中堆是进程中最大的一块内存，用于存放新创建的对象，方法区主要用于保存已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h3 id="3并发和并行的区别">3.并发和并行的区别</h3>
<p>并发：同一时间段内，多个任务都在执行。</p>
<p>并行：单位时间内，多个任务同时执行。</p>
<h3 id="4为什么要使用多线程">4.为什么要使用多线程？</h3>
<p>为了充分利用CPU资源，采用多线程的方式去同时完成几件事情而不互相干扰。在处理大量的IO操作时或处理的情况需要花费大量的时间时利用多线程也可以提高程序运行效率。并且 现在的系统可能会出现并发量很高的情况，多线程编程时开发高并发系统的基础，利用好线程机制可以大大提高系统整体的并发能力及性能。</p>
<h3 id="5使用多线程可能带来的问题">5.使用多线程可能带来的问题？</h3>
<p>并发编程的目的是为了提高程序的执行效率，但并不总是能提高程序运行速度，可能会出现的问题比如：内存泄漏、死锁、线程不安全等等。</p>
<h3 id="6线程的生命周期和状态">6.线程的生命周期和状态</h3>
<p>Java 线程的生命周期包括：初始状态（New）、运行状态（RUNNABLE）、阻塞状态（BLOCKED）、等待状态（WAITING）、超时等待状态（TIME_WAITING)、终止状态（TERMINATED）。</p>
<p>线程创建之后它将处于 <strong>初始状态（New）</strong>，调用 <code>start()</code> 方法后开始运行，转换到 <strong>运行状态（RUNNABLE）</strong>（在操作系统中还会细分为可运行状态和运行状态，前者表示在等候被 CPU 调度运行，后者表示已经获取了时间片在运行中），当线程执行 <code>wait()</code> 方法之后，线程会进入 <strong>等待状态（WAITING）</strong>。进入等待状态的线程需要依靠其它线程的通知才能够返回到运行状态，而调用了 <code>sleep(long millis)</code> 方法或者 <code>wait(long millis)</code> 方法的线程会进入 <code>超时等待状态（TIME_WAITING)</code>，当超时时间到达后线程将会返回运行状态（RUNNABLE）。当线程调用同步方法的时候，如果没有获取到锁，那么会进入到 <strong>阻塞状态（BLOCKED）</strong>。线程在执行完所有代码后将会进入到<strong>终止状态（TERMINATED）</strong>。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt=""></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java+%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt=""></p>
<h3 id="7什么是上下文切换">7.什么是上下文切换？</h3>
<p>当前线程在执行完 CPU 时间片切换到另一个线程之前会先保存自己的状态，以便下次再切换回这个线程时，可以再加载这个线程的状态。<strong>一个线程被暂停剥夺使用权，另外一个线程被选中开始或者继续运行的过程就是一次上下文切换</strong>。</p>
<h3 id="8死锁">8.死锁</h3>
<p><strong>死锁的定义</strong>：多个线程同时被阻塞，它们都在等待某个资源被释放。由于线程被一直阻塞住，导致程序不能正常终止。</p>
<p><strong>产生死锁的四个必要条件</strong>：</p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<p>通过破坏死锁产生的必要条件：</p>
<ol>
<li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<p><strong>安全状态</strong>指的是系统能够按照某种进行推进顺序（P1、P2、P3…Pn）来为每个进程分配所需资源，直到满足每个进程对资源的最大需求，使每个进程都可顺利完成。</p>
<p>银行家算法就是计算系统目前的资源数量，通过先试探分配给进程资源，若能满足该进程执行的资源需求则表示安全，将该进程标记为可完成，然后回收资源数量并去找当前资源可以满足的下一个进程。若所有进程都可执行完毕，则系统处于安全状态，并根据可完成进程的分配顺序生成安全执行序列。</p>
<h3 id="9sleep方法和wait方法区别和共同点">9.sleep()方法和wait()方法区别和共同点？</h3>
<p><code>sleep()</code> 方法和 <code>wait()</code> 方法都可以暂停线程的执行。但是 <code>sleep()</code> 方法会让线程从 RUNNABLE 状态转换到 TIME_WAITING 状态，并且<strong>不会释放锁</strong>，当超过等待时间后，线程将会被自动唤醒；<code>wait()</code> 方法会让线程从 RUNNABLE 状态转换到 WAITING 状态，会<strong>释放锁</strong>，但是需要别的线程调用同一个锁对象上的 <code>notify()</code> 方法或者 <code>notifyAll()</code> 方法才会被唤醒。</p>
<h3 id="10-调用start方法时会执行run方法为什么不直接调用run方法">10. 调用start()方法时会执行run()方法，为什么不直接调用run()方法？</h3>
<p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code> 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。<code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，<code>run()</code> 方法的内容是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<blockquote>
<p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
</blockquote>
<h3 id="11synchronized关键字">11.synchronized关键字</h3>
<p>synchronized 关键字可以解决多个线程之间访问资源的同步性问题，保证它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<h4 id="synchronized关键字的使用方法">synchronized关键字的使用方法</h4>
<ul>
<li>修饰方法：对当前对象实例加锁</li>
<li>修饰静态方法：对当前类加锁，即当前 class 的锁</li>
<li>修饰代码块：对指定对象加锁</li>
</ul>
<p>双重校验锁实现单例模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造方法可以使用synchronized关键字修饰吗">构造方法可以使用synchronized关键字修饰吗？</h4>
<p>不能，构造方法本身属于线程安全的，不存在同步的构造方法一说。</p>
<h4 id="synchronized关键字的底层原理">synchronized关键字的底层原理</h4>
<p>字节码层面。</p>
<p>synchronized 修饰代码块时使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<p>synchronized 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>
<blockquote>
<p><code>monitorenter</code> — 将 lock 对象的 MarkWord 置为 Monitor 指针；<br>
<code>monitorexit</code> — 将 lock 对象的 MarkWord 重置，唤醒 EntryList。</p>
</blockquote>
<h3 id="jdk16之后对synchronized关键字底层做了哪些优化">JDK1.6之后对synchronized关键字底层做了哪些优化？</h3>
<p>JDK 1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除等技术来减少锁操作的开销。</p>
<p><a href="https://www.cnblogs.com/wuqinglong/p/9945618.html#5%E4%BC%98%E5%8C%96%E5%90%8Esynchronized%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB" target="_blank" rel="noopener">Java6及以上版本对synchronized的优化 - 蜗牛大师 - 博客园 (cnblogs.com)</a></p>
<p>级别从低到高分别是：无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p>
<p><a href="https://www.jianshu.com/p/36eedeb3f912" target="_blank" rel="noopener">浅谈偏向锁、轻量级锁、重量级锁 - 简书 (jianshu.com)</a></p>
<h5 id="偏向锁">偏向锁</h5>
<p>适用于只有一个线程访问同步块的场景，它的目的是减少无竞争且只有一个线程使用锁的情况下，轻量级锁每次加锁、释放锁都需要 CAS 操作的性能消耗。</p>
<p><strong>偏向锁加锁</strong> ：第一次加锁时会用 CAS 操作将自己的线程 ID 设置到锁对象的 MarkWord，之后每次加锁都会检查锁对象的 MarkWord 中有没有保存自己的线程 ID，是自己的线程 ID 则表示没有竞争，不用重新 CAS。</p>
<p><strong>偏向锁撤销</strong> ：当另一个线程用 CAS 操作尝试去替换锁对象的 MarkWord 中保存的线程 ID 时，如果失败则会将偏向锁撤销，并且原持有偏向锁的线程如果还未退出同步代码块，则表明发生了锁竞争，会将锁膨胀为轻量级锁。</p>
<h5 id="轻量级锁">轻量级锁</h5>
<p>当出现有两个线程来竞争锁的话，那么偏向锁就失效了，此时锁就会膨胀升级为轻量级锁。</p>
<p><strong>轻量级锁加锁</strong> ：在当前线程的栈帧中创建一个锁记录 Lock Record，并且用 CAS 操作替换锁记录指针以及锁对象的 MarkWord，如果成功则表示获得锁，失败则表示其它线程竞争，当前线程尝试自旋来获取锁。</p>
<p><strong>轻量级锁解锁</strong> ：用 CAS 操作替换当前线程的锁记录指针和锁对象的 MarkWord，如果成功则正常解锁，如果失败就会锁膨胀升级为重量级锁解锁流程。</p>
<p><strong>自旋</strong> ：如果线程自旋获取锁超过了一定次数还没有获得锁，那么就会锁膨胀，尝试加重量级锁。</p>
<p><strong>可重入：</strong> 发生重入则在栈帧中再创建一条锁记录用于重入计数，解锁时每次重置一条锁记录。</p>
<h5 id="重量级锁">重量级锁</h5>
<p><strong>重量级锁加锁</strong> ：将 Monitor 的 Owner 设置为当前线程，其他线程再来发现已经 Owner 不为空则会被加入到 EntryList BLOCKED 阻塞队列中。</p>
<p><strong>重量级锁解锁</strong> ：将 Owner 设置为 null，并且唤醒阻塞队列中的线程来竞争锁。</p>
<p>如果持有锁的线程调用 <code>wait()</code> 方法，则会被加入 WaitSet 中同时唤醒阻塞队列中的线程来竞争锁，等待被其他线程调用 <code>notify()</code> 方法或者 <code>notifyAll()</code> 方法唤醒，唤醒后被加入阻塞队列去竞争锁。</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程使用自旋会消耗CPU</td>
<td>追求响应时间，锁占用时间很短</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量，锁占用时间较长</td>
</tr>
</tbody>
</table>
<h3 id="12synchronized和reentrantlock的区别">12.synchronized和ReentrantLock的区别</h3>
<p><strong>相同点</strong></p>
<p>都是可重入锁，同一个线程每次获取锁，锁的计数器都自增 1，需要等到锁的计数器为 0 时才能真正的释放锁。</p>
<p><strong>不同点</strong></p>
<ul>
<li>synchronized 依赖于 JVM 实现；ReentrantLock 是 JDK 层面实现的，需要 <code>lock()</code> 和 <code>unlock()</code> 方法配合 try/finally 语句块来完成。</li>
<li>ReentrantLock 更加灵活：
<ul>
<li>支持响应中断：让正在等待的线程放弃等待，改为处理其它事情</li>
<li>可实现公平锁：让先等待的线程先获得锁（默认是非公平锁）</li>
<li>条件变量实现选择性通知：借助 Condition 接口来实现，且一个锁可以实现多个条件（synchronized 只能实现一个默认的条件队列）</li>
</ul>
</li>
</ul>
<h3 id="13-volatile关键字">13. volatile关键字</h3>
<h4 id="并发编程的三个重要特性">并发编程的三个重要特性</h4>
<p><strong>原子性</strong> ：一个操作或者多次操作，要么所有的操作全部成功，要么所有的操作都不执行。</p>
<p>synchronized 关键字可以保证代码片段的原子性。</p>
<p><strong>可见性</strong> ：一个线程对共享变量进行了修改，其他的线程立即能够看到该变量的这种修改。</p>
<p>volatile 关键字可以让改变量在被读写时强制刷新到主内存中。synchronized 关键字和 Lock 接口也可以实现可见性，加锁时会从主存中刷新共享变量的值，解锁时会将工作内存中的值同步到主内存当中。</p>
<p><strong>有序性</strong> ：单线程中代码的执行是从前往后依次执行的，但是在多线程并发时，程序的执行可能是无序的。无序有可能是因为发生了指令重排序、工作内存和主内存同步延迟现象。</p>
<p>volatile 关键字可以禁止指令重排序，但是想要保证有序性，需要再加上 synchronized 关键字通过加锁来允许同一时间只有一个线程对共享变量进行操作。</p>
<h4 id="synchronized关键字和volatile关键字的区别">synchronized关键字和volatile关键字的区别</h4>
<p>它们是互补的存在。</p>
<ul>
<li>volatile 关键字只能用于变量，synchronized 关键字可以修饰方法及代码块。</li>
<li>volatile 关键字可以保证数据的可见性，但不能保证原子性，synchronized 关键字两者都可以保证</li>
<li>volatile 关键字主要用于解决变量在多个线程之间的可见性，synchronized 关键字解决的是多个线程之间访问资源的同步问题。</li>
</ul>
<h3 id="14threadlocal">14.ThreadLocal</h3>
<p>如果创建了一个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的本地副本。调用 <code>get()</code> 和 <code>set()</code> 方法时操作的是自己本地内存中的变量，从而规避了线程安全问题。</p>
<p>Thread 类中有 threadLocals 变量，它是 ThreadLocalMap 类型的变量，可以把 ThreadLocalMap 理解成 ThreadLocal  类实现的定制化 HashMap，key 为当前线程的 this 引用，value 为本地变量值。默认情况下两个变量都是 null，只有当前线程调用 ThreadLocal 类的 <code>set()</code> 和 <code>get()</code>  方法时才创建它们，实际上调用这两个方法的时候，调用的是 ThreadLocalMap 类对应的 <code>set()</code> 和 <code>get()</code>  方法。</p>
<p>每个线程的本地变量不是存放在 ThreadLocal 实例中，而是放在调用线程的 ThreadLocals 变量里面。如果调用线程一直不终止，那么这个本地变量将会一直存放在它的 threadLocals 中，所以不使用本地变量的时候需要调用 <code>remove()</code> 方法将其删除，防止可能出现的内存溢出情况。</p>
<p><strong>ThreadLocal的内存泄漏问题</strong></p>
<p>在 ThreadLocalMap 中，使用的 key 为弱引用，而 value 是强引用。在发生 GC 的时候，key 会被清理掉，而 value 不会被清理掉。这样一来就会出现 key 为 null 的 Entry。假如不做任何措施，value 将永远无法被 GC 回收，就有可能会产生内存泄漏。所以使用完 ThreadLocal 方法后最好手动调用 <code>remove()</code> 方法。</p>
<h3 id="15线程池">15.线程池</h3>
<h4 id="为什么要用线程池">为什么要用线程池？</h4>
<p>线程池就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁而是放回池中，从而达到降低资源消耗、提高响应速度和提高线程的可管理型。</p>
<h4 id="实现runnable接口和callable接口的区别">实现Runnable接口和Callable接口的区别</h4>
<p>Runnable 接口不会返回结果或抛出检查异常，Callable 接口可以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行-execute方法和-submit方法的区别是什么呢">执行 execute()方法和 submit()方法的区别是什么呢？</h4>
<p><code>execute()</code> 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功；</p>
<p><code>submit()</code> 方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个对象的 <code>get()</code> 方法可以获取返回值，<code>get()</code> 方法会阻塞当前线程直到任务完成，可以传入参数设置等待时间。</p>
<h4 id="如何创建线程池">如何创建线程池</h4>
<p><strong>1 通过构造方法实现</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ThreadPoolExecutor%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png" alt=""></p>
<p><strong>2 通过 Executor 框架的工具类 Executors 来实现</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB.png" alt=""></p>
<ul>
<li>FixedThreadPool：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li>SingleThreadExecutor：方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li>CachedThreadPool：该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
</ul>
<p>推荐通过 ThreadPoolExecutor 的方式创建线程池，原因如下：</p>
<p>Executors 创建线程时的默认实现固定了队列长度和线程数量。</p>
<ul>
<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
<h4 id="threadpoolexecutor类分析">ThreadPoolExecutor类分析</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<p>ThreadPoolExecutor 类共提供了四个构造方法。其余三个都是在这个构造方法上提供了默认参数，只需要看这个最长的就好了。</p>
<p><strong>参数分析</strong></p>
<p>最重要的 3 个参数：</p>
<ul>
<li>corePoolSize：<strong>核心线程数</strong>定义了最小可以同时运行的线程数量。</li>
<li>maximumPoolSize：当队列中存放的任务达到队列最大容量的时候，可以同时运行的线程数量变为<strong>最大线程数</strong>。</li>
<li>workQueue：当新任务来的时候会先判断当前运行的线程数量是否达到了核心线程数，如果达到的话新任务就会被放入<strong>任务队列</strong>中。</li>
</ul>
<p>其他参数：</p>
<ul>
<li>keepAliveTime：当线程池中的线程数量大于 corePoolSize 的时候，如果这个时候没有新的任务提交，核心线程之外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime 才会被回收销毁。</li>
<li>unit：keepAliveTime 参数的时间单位。</li>
<li>threadFactory：executor 创建新线程的时候会用到。</li>
<li>handler：拒绝策略。</li>
</ul>
<h4 id="threadpoolexecutor拒绝策略">ThreadPoolExecutor拒绝策略</h4>
<p>拒绝策略的定义：如果当前同时运行的线程数量达到最大线程数量，并且队列也已经被满了，ThreadPoolExecutor 定义了一些拒绝策略：</p>
<ul>
<li><code>ThreadPoolExecutor.AbortPolicy</code>：拒绝执行，抛出 RejectedExecutionException 来拒绝新任务的处理。【默认】</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：让调用者自己执行任务。</li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>：直接丢弃。</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：丢弃最早的未处理的任务请求。</li>
</ul>
<h4 id="手撕线程池">手撕线程池</h4>
<p><img src="https://pic.tyzhang.top/images/2020/06/23/866bf38c4fd1f818e4d20ab95999d74f.jpg" alt=""></p>
<ol>
<li>
<p>自定义任务队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拒绝策略</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RejectPolicy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue, T task)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// 锁</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 生产者条件变量，添加线程，满的时候等待</span></span><br><span class="line">    <span class="keyword">private</span> Condition fullWaitSet = lock.newCondition();</span><br><span class="line">    <span class="comment">// 消费者条件变量，执行线程，空的时候等待</span></span><br><span class="line">    <span class="keyword">private</span> Condition emptyWaitSet = lock.newCondition();</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capcity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// while 是为了防止被虚假唤醒，即唤醒过后资源已经被其他线程取走了。</span></span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            		e.printStackTrace();</span><br><span class="line">        		&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            <span class="comment">// 生产者干活啦！</span></span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 带超时的阻塞获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = emptyWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            <span class="comment">// 生产者干活啦！</span></span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T task)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                    log.debug(<span class="string">"等待任务加入队列&#123;&#125;"</span>, task);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">"加入任务队列&#123;&#125;"</span>, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            <span class="comment">// 消费者来开饭啦！</span></span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 带超时的阻塞添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(T task, <span class="keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> nanos = timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    log.debug(<span class="string">"等待加入队列&#123;&#125;"</span>, task);</span><br><span class="line">                    nanos = fullWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">"加入任务队列&#123;&#125;"</span>, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 带拒绝策略的添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.size() == capcity) &#123;</span><br><span class="line">                rejectPolicy.reject(<span class="keyword">this</span>, task);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"加入任务队列&#123;&#125;"</span>, task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyWaitSet.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回队列长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>自定义线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">	<span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line">    <span class="comment">// 线程集合</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> coreSize;</span><br><span class="line">    <span class="comment">// 获取任务时的超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">long</span> timeout, TimeUnit timeUnit, RejectPolicy&lt;Runnable&gt; rejectPolicy, <span class="keyword">int</span> queueCapcity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="keyword">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">        <span class="keyword">this</span>.taskQueue = <span class="keyword">new</span> BlockingQueue&lt;&gt;(queueCapcity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workers.size() &lt; coreSize) &#123;</span><br><span class="line">                Worker worker = <span class="keyword">new</span> Worker(task);</span><br><span class="line">                log.debug(<span class="string">"新增worker&#123;&#125;"</span>, worker);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                taskQueue.tryPut(rejectPolicy, task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 当task不为空，执行任务；当task执行完毕，从任务队列中获取任务并执行</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">"正在执行&#123;&#125;"</span>, task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">                log.debug(<span class="string">"worker被移除&#123;&#125;"</span>, <span class="keyword">this</span>);</span><br><span class="line">                workers.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool threadPool = <span class="keyword">new</span> ThreadPool(<span class="number">1</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                       <span class="comment">// 行为化参数，指定拒绝策略</span></span><br><span class="line">                                       (queue, task) -&gt; &#123;</span><br><span class="line">                                           <span class="comment">// 1. 死等</span></span><br><span class="line">                                           <span class="comment">// queue.put(task);</span></span><br><span class="line">                                           <span class="comment">// 2) 带超时等待</span></span><br><span class="line">                                           queue.offer(task, <span class="number">1500</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                                           <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line">                                           <span class="comment">// log.debug("放弃&#123;&#125;", task);</span></span><br><span class="line">                                           <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line">                                           <span class="comment">// throw new RuntimeException("任务执行失败 " + task);</span></span><br><span class="line">                                           <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">                                           <span class="comment">// task.run();</span></span><br><span class="line">                                       &#125;, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = i;</span><br><span class="line">    threadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">"&#123;&#125;"</span>, j);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="线程池原理">线程池原理</h4>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt=""></p>
<h4 id="线程池的工作工程">线程池的工作工程</h4>
<ol>
<li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li>
<li>当调用 <code>execute()</code> 方法添加一个任务时，线程池会做如下判断：
<ol>
<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li>
<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li>
<li>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li>
<li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。</li>
</ol>
</li>
<li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li>
<li>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li>
</ol>
<h3 id="16atomic原子类">16.Atomic原子类</h3>
<p>Atomic 类在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
<h4 id="juc-包中的原子类包括哪4类">JUC 包中的原子类包括哪4类</h4>
<ul>
<li>基本类型：使用原子的方式更新基本类型
<ul>
<li>AtomicInteger：整型原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean：布尔型原子类</li>
</ul>
</li>
<li>数组类型：使用原子的方式更新数组里的某个元素
<ul>
<li>AtomicIntegerArray：整型数组原子类</li>
<li>AtomicLongArray：长整型原子类</li>
<li>AtomicReferenceArray：引用类型数组原子类</li>
</ul>
</li>
<li>引用类型
<ul>
<li>AtomicReference：引用类型原子类</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。可以解决 CAS 中的 ABA 问题。</li>
<li>AtomicMarkableReference：原子更新带有标记位的引用类型。</li>
</ul>
</li>
<li>对象的属性修改类型
<ul>
<li>AtomicIntegerFieldUpdater：原子更新整型字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器</li>
<li>AtomicReferenceFieldUpdater：原子更新引用类型字段的更新器</li>
</ul>
</li>
</ul>
<h4 id="atomicinteger的使用">AtomicInteger的使用</h4>
<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure>
<p>也有 <code>addAndGet()</code>、<code>decrementAndGet()</code>、<code>incrementAndGet()</code> 等方法。</p>
<p>使用 AtomicInteger 之后，不用对 <code>increment()</code> 方法加锁也可以保证线程安全。</p>
<h4 id="atomicinteger类的原理">AtomicInteger类的原理</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 本地方法，这个方法是用来拿到“原来的值”的内存地址</span></span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure>
<p>AtomicInteger 类主要利用 CAS + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率比较高。</p>
<p>拿 <code>getAndIncrement()</code> 方法举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AtomicInteger.getAndIncrement()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unsafe.getAndAddInt()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="comment">// CAS</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = <span class="keyword">this</span>.getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="keyword">this</span>.compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17aqs">17.AQS</h3>
<p>AQS 抽象的队列式的同步器，是阻塞式锁和相关的同步器工具的框架，许多同步类实现都依赖于它，如常用的 Lock、Semaphore、ReentrantLock等。</p>
<ul>
<li>
<p>用 <code>volatile int state</code> 属性来表示资源的状态（分独占模式和共享模式），独占模式（Exclusive）是只有一个线程能够访问资源（如 ReentrantLock），而共享模式（Share）可以允许多个线程访问资源（如 Semaphore / CountDownLatch）。</p>
<p>state 的访问方式有三种：</p>
<ol>
<li><code>getState()</code>——获取 state 状态</li>
<li><code>setState()</code>——设置 state 状态</li>
<li><code>compareAndSetState()</code>——CAS 机制设置 state 状态</li>
</ol>
</li>
<li>
<p>提供了一个 FIFO 的线程等待队列，类似于 Monitor 的 EntryList</p>
</li>
<li>
<p>条件变量来实现等待唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</p>
</li>
</ul>
<h4 id="aqs的自定义同步器实现">AQS的自定义同步器实现</h4>
<p><strong>自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可</strong>，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。</p>
<p>自定义同步器实现时主要实现以下几种方法：</p>
<ul>
<li><code>tryAcquire(int)</code>：独占方式。尝试获取资源，成功返回 true，失败则返回 false。</li>
<li><code>tryRelease(int)</code>：独占方式。尝试释放资源，成功返回 true，失败则返回 false。</li>
<li><code>tryAcquireShared(int)</code>：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待节点返回 true，否则返回 false。</li>
<li><code>isHeldExclusively()</code>：该线程是否正独占资源。只有用到 condition 才需要去实现它。</li>
</ul>
<h4 id="aqs的原理">AQS的原理</h4>
<p>其核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求资源被占用，则把它放到一个双端队列中，等候被唤醒。</p>
<p>拿 ReentranLock 的工作流程举例：</p>
<p><strong>加锁</strong></p>
<p>如果当前没有线程持有锁并且没有竞争，那么线程 t0 调用 <code>lock()</code> 方法加锁，先尝试用 CAS 操作将锁的状态 state 由 0 改为 1，成功后将 owner 设置为当前线程。</p>
<p><img src="https://pic.tyzhang.top/images/2020/07/03/meiyoujingzheng.jpg" alt=""></p>
<p>此时来了第二个线程 t1，调用 <code>lock()</code> 方法加锁，先调用 <code>tryAcquire()</code> 方法尝试用 CAS 操作将锁的状态 state 由 0 改为 1，失败，进入 <code>acquire()</code> 方法进行下一步处理：</p>
<ul>
<li>再次调用 <code>tryAcquire()</code> 方法将锁的状态 state 由 0 改为 1，结果失败</li>
<li>调用 <code>addWaiter()</code> 方法，将当前线程 t1 以 Node 的形式加入队列当中，进入 <code>acquireQueued()</code> 方法尝试为队列中排队的线程获取锁</li>
<li><code>acquireQueued()</code> 方法会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞
<ul>
<li>如果当前线程 t1 所在的节点紧邻着 head （即排在第二位），那么再次调用 <code>tryAcquire()</code> 方法尝试获取锁，结果失败</li>
<li>进入 <code>shouldParkAfterFailedAcquire()</code> 方法，将前驱 Node，此时将 head 的 waitStatus 改为 -1，表示它有责任唤醒它的后继节点，第一次调用返回 false，再次进入循环调用 <code>tryAcquire()</code> 方法，结果失败</li>
<li>此时再次进入 <code>shouldParkAfterFailedAcquire()</code> 方法，因为前驱 Node 的 waitStatus 已经是 -1，这次返回 true</li>
<li>进入 <code>parkAndCheckInterupt()</code> 方法，将当前线程 t1 park</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>acquireQueued()</code> 方法的逻辑：一个线程获取锁失败了，被放入等待队列，acquireQueued 会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。</p>
</blockquote>
<p><img src="https://pic.tyzhang.top/images/2020/07/04/10f75e333a3e5cc05fabfe28ec4b4470.jpg" alt=""></p>
<p><strong>解锁</strong></p>
<p>t0 线程释放锁，进入 <code>tryRelease()</code> 方法，如果成功设置 exclusiveOwnerThread 为 null，state 设置为 0。</p>
<p>如果当前的队列不为 null，并且 head 的 waitStatus 为 -1，进入 <code>unparkSuccessor()</code> 方法，找到队列中离 head 最近的一个没有被取消的 Node，unpark 恢复其运行。</p>
<h4 id="aqs对资源的共享方式">AQS对资源的共享方式</h4>
<ul>
<li>Exclusive（独占）：只有一个线程能执行，如 ReentrantLock。又分为公平锁和非公平锁
<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到的先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去竞争锁</li>
</ul>
</li>
</ul>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/Java基础/" data-toggle="tooltip" data-placement="top" title="Java基础一文流">&larr; 上一篇</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/http和https的区别/" data-toggle="tooltip" data-placement="top" title="HTTP和HTTPS的区别">下一篇 &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">目录</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1什么是线程和进程"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">1.&#x4EC0;&#x4E48;&#x662F;&#x7EBF;&#x7A0B;&#x548C;&#x8FDB;&#x7A0B;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2线程与进程的关系"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">2.&#x7EBF;&#x7A0B;&#x4E0E;&#x8FDB;&#x7A0B;&#x7684;&#x5173;&#x7CFB;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3并发和并行的区别"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">3.&#x5E76;&#x53D1;&#x548C;&#x5E76;&#x884C;&#x7684;&#x533A;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4为什么要使用多线程"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">4.&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x4F7F;&#x7528;&#x591A;&#x7EBF;&#x7A0B;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5使用多线程可能带来的问题"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">5.&#x4F7F;&#x7528;&#x591A;&#x7EBF;&#x7A0B;&#x53EF;&#x80FD;&#x5E26;&#x6765;&#x7684;&#x95EE;&#x9898;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6线程的生命周期和状态"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">6.&#x7EBF;&#x7A0B;&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;&#x548C;&#x72B6;&#x6001;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7什么是上下文切换"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">7.&#x4EC0;&#x4E48;&#x662F;&#x4E0A;&#x4E0B;&#x6587;&#x5207;&#x6362;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8死锁"><span class="toc-nav-number">8.</span> <span class="toc-nav-text">8.&#x6B7B;&#x9501;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#9sleep方法和wait方法区别和共同点"><span class="toc-nav-number">9.</span> <span class="toc-nav-text">9.sleep()&#x65B9;&#x6CD5;&#x548C;wait()&#x65B9;&#x6CD5;&#x533A;&#x522B;&#x548C;&#x5171;&#x540C;&#x70B9;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#10-调用start方法时会执行run方法为什么不直接调用run方法"><span class="toc-nav-number">10.</span> <span class="toc-nav-text">10. &#x8C03;&#x7528;start()&#x65B9;&#x6CD5;&#x65F6;&#x4F1A;&#x6267;&#x884C;run()&#x65B9;&#x6CD5;&#xFF0C;&#x4E3A;&#x4EC0;&#x4E48;&#x4E0D;&#x76F4;&#x63A5;&#x8C03;&#x7528;run()&#x65B9;&#x6CD5;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#11synchronized关键字"><span class="toc-nav-number">11.</span> <span class="toc-nav-text">11.synchronized&#x5173;&#x952E;&#x5B57;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#synchronized关键字的使用方法"><span class="toc-nav-number">11.1.</span> <span class="toc-nav-text">synchronized&#x5173;&#x952E;&#x5B57;&#x7684;&#x4F7F;&#x7528;&#x65B9;&#x6CD5;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#构造方法可以使用synchronized关键字修饰吗"><span class="toc-nav-number">11.2.</span> <span class="toc-nav-text">&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;synchronized&#x5173;&#x952E;&#x5B57;&#x4FEE;&#x9970;&#x5417;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#synchronized关键字的底层原理"><span class="toc-nav-number">11.3.</span> <span class="toc-nav-text">synchronized&#x5173;&#x952E;&#x5B57;&#x7684;&#x5E95;&#x5C42;&#x539F;&#x7406;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jdk16之后对synchronized关键字底层做了哪些优化"><span class="toc-nav-number">12.</span> <span class="toc-nav-text">JDK1.6&#x4E4B;&#x540E;&#x5BF9;synchronized&#x5173;&#x952E;&#x5B57;&#x5E95;&#x5C42;&#x505A;&#x4E86;&#x54EA;&#x4E9B;&#x4F18;&#x5316;&#xFF1F;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#偏向锁"><span class="toc-nav-number">12.0.1.</span> <span class="toc-nav-text">&#x504F;&#x5411;&#x9501;</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#轻量级锁"><span class="toc-nav-number">12.0.2.</span> <span class="toc-nav-text">&#x8F7B;&#x91CF;&#x7EA7;&#x9501;</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#重量级锁"><span class="toc-nav-number">12.0.3.</span> <span class="toc-nav-text">&#x91CD;&#x91CF;&#x7EA7;&#x9501;</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#12synchronized和reentrantlock的区别"><span class="toc-nav-number">13.</span> <span class="toc-nav-text">12.synchronized&#x548C;ReentrantLock&#x7684;&#x533A;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#13-volatile关键字"><span class="toc-nav-number">14.</span> <span class="toc-nav-text">13. volatile&#x5173;&#x952E;&#x5B57;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#并发编程的三个重要特性"><span class="toc-nav-number">14.1.</span> <span class="toc-nav-text">&#x5E76;&#x53D1;&#x7F16;&#x7A0B;&#x7684;&#x4E09;&#x4E2A;&#x91CD;&#x8981;&#x7279;&#x6027;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#synchronized关键字和volatile关键字的区别"><span class="toc-nav-number">14.2.</span> <span class="toc-nav-text">synchronized&#x5173;&#x952E;&#x5B57;&#x548C;volatile&#x5173;&#x952E;&#x5B57;&#x7684;&#x533A;&#x522B;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#14threadlocal"><span class="toc-nav-number">15.</span> <span class="toc-nav-text">14.ThreadLocal</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#15线程池"><span class="toc-nav-number">16.</span> <span class="toc-nav-text">15.&#x7EBF;&#x7A0B;&#x6C60;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#为什么要用线程池"><span class="toc-nav-number">16.1.</span> <span class="toc-nav-text">&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x7528;&#x7EBF;&#x7A0B;&#x6C60;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#实现runnable接口和callable接口的区别"><span class="toc-nav-number">16.2.</span> <span class="toc-nav-text">&#x5B9E;&#x73B0;Runnable&#x63A5;&#x53E3;&#x548C;Callable&#x63A5;&#x53E3;&#x7684;&#x533A;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#执行-execute方法和-submit方法的区别是什么呢"><span class="toc-nav-number">16.3.</span> <span class="toc-nav-text">&#x6267;&#x884C; execute()&#x65B9;&#x6CD5;&#x548C; submit()&#x65B9;&#x6CD5;&#x7684;&#x533A;&#x522B;&#x662F;&#x4EC0;&#x4E48;&#x5462;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#如何创建线程池"><span class="toc-nav-number">16.4.</span> <span class="toc-nav-text">&#x5982;&#x4F55;&#x521B;&#x5EFA;&#x7EBF;&#x7A0B;&#x6C60;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#threadpoolexecutor类分析"><span class="toc-nav-number">16.5.</span> <span class="toc-nav-text">ThreadPoolExecutor&#x7C7B;&#x5206;&#x6790;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#threadpoolexecutor拒绝策略"><span class="toc-nav-number">16.6.</span> <span class="toc-nav-text">ThreadPoolExecutor&#x62D2;&#x7EDD;&#x7B56;&#x7565;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#手撕线程池"><span class="toc-nav-number">16.7.</span> <span class="toc-nav-text">&#x624B;&#x6495;&#x7EBF;&#x7A0B;&#x6C60;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#线程池原理"><span class="toc-nav-number">16.8.</span> <span class="toc-nav-text">&#x7EBF;&#x7A0B;&#x6C60;&#x539F;&#x7406;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#线程池的工作工程"><span class="toc-nav-number">16.9.</span> <span class="toc-nav-text">&#x7EBF;&#x7A0B;&#x6C60;&#x7684;&#x5DE5;&#x4F5C;&#x5DE5;&#x7A0B;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#16atomic原子类"><span class="toc-nav-number">17.</span> <span class="toc-nav-text">16.Atomic&#x539F;&#x5B50;&#x7C7B;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#juc-包中的原子类包括哪4类"><span class="toc-nav-number">17.1.</span> <span class="toc-nav-text">JUC &#x5305;&#x4E2D;&#x7684;&#x539F;&#x5B50;&#x7C7B;&#x5305;&#x62EC;&#x54EA;4&#x7C7B;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#atomicinteger的使用"><span class="toc-nav-number">17.2.</span> <span class="toc-nav-text">AtomicInteger&#x7684;&#x4F7F;&#x7528;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#atomicinteger类的原理"><span class="toc-nav-number">17.3.</span> <span class="toc-nav-text">AtomicInteger&#x7C7B;&#x7684;&#x539F;&#x7406;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#17aqs"><span class="toc-nav-number">18.</span> <span class="toc-nav-text">17.AQS</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#aqs的自定义同步器实现"><span class="toc-nav-number">18.1.</span> <span class="toc-nav-text">AQS&#x7684;&#x81EA;&#x5B9A;&#x4E49;&#x540C;&#x6B65;&#x5668;&#x5B9E;&#x73B0;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#aqs的原理"><span class="toc-nav-number">18.2.</span> <span class="toc-nav-text">AQS&#x7684;&#x539F;&#x7406;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#aqs对资源的共享方式"><span class="toc-nav-number">18.3.</span> <span class="toc-nav-text">AQS&#x5BF9;&#x8D44;&#x6E90;&#x7684;&#x5171;&#x4EAB;&#x65B9;&#x5F0F;</span></a></li></ol></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">标签</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#note" title="note">note</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
				<!--
                
                <hr>
                <h5>朋友们</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://tyzhang.top/" target="_blank">ztygalaxy</a></li>
                    
                        <li><a href="http://www.tangyincheng.com/" target="_blank">yctang</a></li>
                    
                        <li><a href="https://dolnw.github.io" target="_blank">JCWang</a></li>
                    
                </ul>
                
				-->
            </div>
        </div>
    </div>
</article>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: ''
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


<!-- chrome Firefox 中文锚点定位失效-->
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<!-- smooth scroll behavior polyfill  -->
<script type="text/javascript" src="/js/smoothscroll.js"></script>
<script>
        $('#toc').on('click','a',function(a){
            // var isChrome = window.navigator.userAgent.indexOf("Chrome") !== -1;
            // console.log(window.navigator.userAgent,isChrome)
                // if(isChrome) {
                    // console.log(a.currentTarget.outerHTML);
                    // console.log($(a.currentTarget).attr("href"));
                    //跳转到指定锚点
                    // document.getElementById(a.target.innerText.toLowerCase()).scrollIntoView(true);
                    document.getElementById($(a.currentTarget).attr("href").replace("#","")).scrollIntoView({behavior: 'smooth' });
                // }
        })  
</script>


    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                
				
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/songzblink">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 宋正兵 2021 
                    <br>
                    Theme by <a href="http://www.huweihuang.com">Huwei Huang</a>
                    re-Ported by <a href="https://github.com/ztygalaxy">ztygalaxy</a>
					
					<br>
                    <a href="http://www.beian.miit.gov.cn/" style="color: gray">浙ICP备2021018896号</a>
					<br>
					<!-- <p class="copyright text-muted" style="margin-top: 5px"> -->
						<img src="../../img/备案图标.png"/>
						<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null" style="color: gray">null</a>
					<!-- </p> -->
					
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("zbsong.top/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="zbsong.top/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>

</html>
