<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/logo.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          Spring - 宋正兵的博客 | zbsong Blog
        
    </title>

    <link rel="canonical" href="zbsong.top/article/Spring学习/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('https://api.dujin.org/bing/1920.php')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#java" title="java">java</a>
                            
                        </div>
                        <h1>Spring</h1>
                        <!-- <h2 class="subheading">Spring框架知识点整理，包含MyBatis</h2> -->
                        <span class="meta">
                            宋正兵 on
                            2021-06-22
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">songzblink</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">主页</a>
                    </li>
					<li>
                        <a href="/archive/">归档</a>
                    </li>
					<li>
                        <a href="/tags/">标签</a>
                    </li>
					<li>
                        <a href="/about/">关于</a>
                    </li>
					<!--
					修改about在前面的问题
                    
                        
                    
                        
                        <li>
                            <a href="/about/">关于</a>
                        </li>
                        
                    
                        
                        <li>
                            <a href="/archive/">归档</a>
                        </li>
                        
                    
                        
                        <li>
                            <a href="/tags/">标签</a>
                        </li>
                        
                    
                    -->
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
	// querySelector 获取文档中 id="demo" 的元素
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				
                <h1 id="spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="spring框架概述"><a href="#Spring框架概述" class="headerlink" title="Spring框架概述"></a>Spring框架概述</h2><p>Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。我们一般讲的 Spring 框架指的是 Spring Framework，它是很多模块的集合，这些模块可以很方便地协助我们进行开发。</p>
<p>包括：核心模块、数据访问、Web、AOP、工具、消息和测试模块。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>核心技术：依赖注入（DI）、AOP</li>
<li>测试：模拟对象</li>
<li>数据访问：事务、DAO支持、JDBC</li>
<li>Web支持：Spring MVC</li>
</ul>
<h3 id="列举一些重要的模块"><a href="#列举一些重要的模块" class="headerlink" title="列举一些重要的模块"></a>列举一些重要的模块</h3><ul>
<li><strong>Spring Core：</strong> 基础，可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。</li>
<li><strong>Spring Aspects</strong> ： 该模块为与 AspectJ 的集成提供支持。</li>
<li><strong>Spring AOP</strong> ：提供了面向切面的编程实现。</li>
<li><strong>Spring JDBC</strong> : Java 数据库连接。</li>
<li><strong>Spring JMS</strong> ：Java 消息服务。</li>
<li><strong>Spring ORM</strong> : 用于支持 Hibernate 等 ORM 工具。</li>
<li><strong>Spring Web</strong> : 为创建 Web 应用程序提供支持。</li>
<li><strong>Spring Test</strong> : 提供了对 JUnit 和 TestNG 测试的支持。</li>
</ul>
<h3 id="restcontroller和controller"><a href="#RestController和-Controller" class="headerlink" title="@RestController和@Controller"></a>@RestController和@Controller</h3><p>单独使用 @Controller 的话一般需要返回一个视图，属于比较传统的 Spring MVC 的应用，对应于前后端不分离的情况。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/SpringMVC%E4%BC%A0%E7%BB%9F%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt=""></p>
<p>@RestController 只返回对象，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应（Response）中，这种情况属于 RESTful Web 服务，也是目前比较常用的（前后端分离）。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/SpringMVCRestController.png" alt=""></p>
<p>@Controller + @ResponseBody 的效果和 @RestController 的效果一样。</p>
<h2 id="ioc和di"><a href="#IoC和DI" class="headerlink" title="IoC和DI"></a>IoC和DI</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="ioc"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h4><p><strong>IoC </strong> 是指“反转控制”，是 Spring 中的一种设计思想以及重要特性。控制反转是一种通过描述（XML 或注解）并通过第三方去生产或获取特定对象的方式。在 Spring 中实现控制反转的是 IoC 容器，其实现方法是依赖注入（Dependency Injection,DI）。</p>
<p>Spring 容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从 IoC 容器中取出需要的对象。</p>
<p><strong>控制</strong> 指的是 <strong>IoC 容器控制了对象</strong>。传统程序设计，我们直接在对象内部通过 new 进行创建对象，是程序主动去创建依赖对象；而 IoC 是有专门一个容器来创建这些对象，即由 Ioc 容器来控制对象的创建。</p>
<p><strong>反转</strong> 指的是<strong>由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象</strong>。传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象。</p>
<p>用图来说明，如下：</p>
<p>传统的程序设计</p>
<p><img src="https://images0.cnblogs.com/blog/289233/201501/261421378318292.jpg" alt=""></p>
<p>IOC 容器</p>
<p><img src="https://pic.tyzhang.top/images/2021/05/11/image.png" alt="image.png"></p>
<h4 id="di"><a href="#DI" class="headerlink" title="DI"></a>DI</h4><p><strong>DI</strong> 指依赖注入，组件之间依赖关系由容器在运行期决定，形象的说，即<strong>由容器动态的将某个依赖关系注入到组件之中</strong>。</p>
<p><strong>依赖注入的目的</strong> 并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<p><strong>依赖</strong> 指的是应用程序需要 IoC 容器来提供对象需要的外部资源。</p>
<p><strong>注入</strong> 指的是 IoC 容器注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>传统的开发过程中，我们要实现某个功能时如果需要两个或以上的对象协作来完成，在没有使用 Spring 的情况下，需要在对象内将它合作的对象通过 <code>new Object()</code> 这样的语法新建出来，这种创建的方式是主动的，创建的主动权和创建的时机都掌握在我们手上。但是这样会使得类之间的耦合度变高，比如 A 对象需要 B 对象合作完成一件任务，A 需要 B，那么 A 就产生了对 B 的依赖，也就是说 A、B 之间产生了耦合关系。</p>
<p>使用了 Spring 之后，创建合作对象 B 的工作由 Spring 来完成，Spring 创建好合作对象 B 后会将其存放到容器当中，当 A 对象需要使用 B 对象的时候，Spring 就会从容器中找到并取出 B 对象，然后交给 A 对象使用。至于 Spring 是如何创建以及什么时候创建好的 B 对象，A 对象不需要去关心这些细节，在 A 对象得到 B 对象之后完成工作即可。</p>
<p>参考博客：</p>
<p><a href="https://www.cnblogs.com/xdp-gacl/p/4249939.html" target="_blank" rel="noopener">谈谈对Spring IOC的理解 - 孤傲苍狼 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.zhihu.com/question/23277575/answer/169698662" target="_blank" rel="noopener">Spring IoC有什么好处呢？ - Mingqi的回答 - 知乎</a></p>
<h3 id="spring-ioc容器的初始化过程"><a href="#Spring-IoC容器的初始化过程" class="headerlink" title="Spring IoC容器的初始化过程"></a>Spring IoC容器的初始化过程</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/SpringIOC%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt=""></p>
<ol>
<li>设置容器的初始化状态，如：容器的启动时间，容器的激活状态</li>
<li>解析 bean.xml 配置文件，将配置文件中的信息解析封装为 BeanDefinition 对象</li>
<li>将 BeanDefinition 对象注册到 BeanFactory 容器中。此时还没有真正创建 bean 对象，只是解析封装 xml 配置文件的内容</li>
</ol>
<blockquote>
<p>BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。</p>
</blockquote>
<p>参考博客：</p>
<p><a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="noopener">Spring IOC 容器源码分析_Javadoop</a></p>
<h2 id="spring-aop"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><blockquote>
<p>下面的都是动态织入，静态织入使用 AspectJ 在编译器织入，在这个期间使用  AspectJ 的编译器把 Aspect 类变编译成 class 字节码，然后在目标类编译的时候进行静态织入。</p>
</blockquote>
<p>AOP 面向切面编程，<strong>动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程</strong>。</p>
<p>Spring AOP 是基于动态代理的，如果要代理的对象实现了某个接口（任意的），那么会使用 JDK Proxy 去实现 AOP，如果没有实现接口的对象，会使用 Cglib 去实现 AOP。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/SpringAOPProcess.jpg" alt=""></p>
<p>JDK 动态代理只能只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</p>
<h3 id="jdk-proxy"><a href="#JDK-Proxy" class="headerlink" title="JDK Proxy"></a>JDK Proxy</h3><p>首先定义一个发送短信的接口，并创建一个发送短信的服务类实现该接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"send message:"</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后定义一个 JDK 动态代理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 被代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态代理对象替我们去调用被代理对象的原生方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> throw Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"before method "</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"after method "</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建获取代理对象的工厂类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyFacotry</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取target的代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">        	target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载器</span></span><br><span class="line">            target.getClass().getInterfaces(),  <span class="comment">// 目标类所需要实现的接口，可以有多个</span></span><br><span class="line">            <span class="keyword">new</span> DemoInvocationHandler(target) 	<span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SmsService smsService = (SmsService) JdkProxyFacotry.getProxy(<span class="keyword">new</span> SmsServiceImpl());</span><br><span class="line">smsService.send(<span class="string">"java"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">before method send</span></span><br><span class="line"><span class="comment">send message:java</span></span><br><span class="line"><span class="comment">after method send</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>注意，如果用传入的类引用指向代理会报错，只能用接口引用指向代理。</strong>比如下面代码就会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SmsServiceImpl smsService = (SmsServiceImpl) JdkProxyFacotry.getProxy(<span class="keyword">new</span> SmsServiceImpl());</span><br><span class="line">smsService.send(<span class="string">"java"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.ClassCastException: class $Proxy0 cannot be cast to class SmsServiceImpl ($Proxy0 and SmsServiceImpl are in unnamed module of loader 'app')</span></span><br><span class="line"><span class="comment">	at Main.main(Main.java:11)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>JDK 动态代理的 <code>Proxy.newProxyInstance()</code> 方法就需要传递接口参数，猜测是因为 JDK 动态代理的原理是根据定义好的规则，用传入的接口创建一个新类。所以采用动态代理时只能用接口引用指向代理，而不能用传入的类引用指向代理。Cglib 不存在这种问题。</p>
<p><a href="https://blog.csdn.net/MagicianLiu/article/details/4107497" target="_blank" rel="noopener">JDK动态代理为什么必须用接口以及与CGLIB的对比_魔术师的专栏-CSDN博客_jdk动态代理为什么必须实现接口</a></p>
<h3 id="cglib"><a href="#CGLib" class="headerlink" title="CGLib"></a>CGLib</h3><p>JDK 动态代理只能代理实现了接口的类，如果想要代理没有实现接口的类，可以用 CGLib 动态代理机制来解决。CGLib 通过继承方式实现代理。</p>
<p>在 CGLib 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心，我们需要去自定义 MethodInterceptor 并重写 intercept 方法，intercept 方法用于拦截增强被代理类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Callback</span></span>&#123;</span><br><span class="line">    <span class="comment">// 拦截被代理类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">                               MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>obj</strong> :被代理的对象（需要增强的对象）</li>
<li><strong>method</strong> :被拦截的方法（需要增强的方法）</li>
<li><strong>args</strong> :方法入参</li>
<li><strong>methodProxy</strong> :用于调用原始方法</li>
</ol>
<p><strong>CGLib 动态代理的使用步骤</strong></p>
<ol>
<li>定义一个类</li>
<li>实现 MethodInteceptor 接口并自定义 <code>intercept()</code> 方法</li>
<li>通过 Enhancer 类的 <code>create()</code> 创建代理类</li>
</ol>
<p><strong>举例</strong></p>
<p>CGLib 是一个开源项目，需要引入相关依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>首先定义一个发送短信的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"send message:"</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后自定义 MethodInterceptor 方法拦截器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           被代理的对象（需要增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"before method "</span> + method.getName());</span><br><span class="line">        Object object = methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"after method "</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取代理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> DebugMethodInterceptor());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SmsService smsService = (SmsService) CglibProxyFactory.getProxy(smsService.class);</span><br><span class="line">smsService.send(<span class="string">"java"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">before method send</span></span><br><span class="line"><span class="comment">send message:java</span></span><br><span class="line"><span class="comment">after method send</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="aop的使用"><a href="#AOP的使用" class="headerlink" title="AOP的使用"></a>AOP的使用</h3><h4 id="基于xml的方式"><a href="#基于XML的方式" class="headerlink" title="基于XML的方式"></a>基于XML的方式</h4><p>首先需要用 <code>&lt;bean&gt;</code> 标签将目标类和切面对象类的创建权交给 Spring</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    目标对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"target"</span> <span class="attr">class</span>=<span class="string">"com.songzb.aop.Target"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    切面对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspect"</span> <span class="attr">class</span>=<span class="string">"com.songzb.aop.MyAspect"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后配置织入关系，告诉Spring框架 哪些方法（切点）需要进行哪些增强（前置、后置。。。）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置织入，告诉Spring框架 哪些方法（切点）需要进行哪些增强（前置、后置。。。）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        声明切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"myAspect"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            切面：切点+通知--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"before"</span> <span class="attr">pointcut</span>=<span class="string">"execution(public void com.songzb.aop.Target.save())"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="基于注解的方式"><a href="#基于注解的方式" class="headerlink" title="基于注解的方式"></a>基于注解的方式</h4><p><a href="https://www.cnblogs.com/yhtboke/p/5856405.html" target="_blank" rel="noopener">基于注解的Spring AOP的配置和使用 - Study_Work - 博客园 (cnblogs.com)</a></p>
<ol>
<li>利用 @Component 注解将目标类和切面类的对象创建权交给 Spring</li>
<li>使用 @Aspect 标注切面类</li>
<li>使用@通知注解【下边的】标注切面类的通知方法</li>
<li>在配置文件中开启 AOP 自动代理 <code>&lt;aop:aspectj-autoproxy/&gt;</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标类</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"target"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> <span class="keyword">implements</span> <span class="title">TargetInterface</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 切面类</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"myAspect"</span>)</span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 标注当前MyAspect是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 配置前置通知</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.songzb.anno.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置增强..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="aop-常用注解"><a href="#AOP-常用注解：" class="headerlink" title="AOP 常用注解："></a>AOP 常用注解：</h3><div class="table-container">
<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Before</td>
<td>前置通知：目标方法之前执行</td>
</tr>
<tr>
<td>@After</td>
<td>后置通知：目标方法之后执行（始终执行）</td>
</tr>
<tr>
<td>@AfterReturning</td>
<td>返回后通知：执行方法结束前执行（异常不执行）</td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td>异常通知：出现异常时执行</td>
</tr>
<tr>
<td>@Around</td>
<td>环绕通知：环绕目标方法执行</td>
</tr>
</tbody>
</table>
</div>
<h3 id="spring-aop和aspectj-aop有什么区别"><a href="#Spring-AOP和AspectJ-AOP有什么区别？" class="headerlink" title="Spring AOP和AspectJ AOP有什么区别？"></a>Spring AOP和AspectJ AOP有什么区别？</h3><p>Spring AOP 属于<strong>运行时增强</strong>，而 AspectJ 是<strong>编译时增强</strong>。Spring AOP 基于代理，而 AspectJ 基于字节码操作。</p>
<p>Spring AOP 已经集成了 AspectJ，AspectJ 比 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单。</p>
<p>如果切面少，两者性能差不多；如果切面太多，最好选择 AspectJ，它更快。</p>
<p>静态织入使用 AspectJ 在编译器织入，在这个期间使用 AspectJ 的编译器把 Aspect 类变编译成 class 字节码，然后在目标类编译的时候进行静态织入。</p>
<h2 id="spring-bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h2><p>Bean 就是由 IOC 实例化、组装、管理的一个对象。</p>
<h3 id="spring-如何管理-bean-的"><a href="#Spring-如何管理-Bean-的" class="headerlink" title="Spring 如何管理 Bean 的"></a>Spring 如何管理 Bean 的</h3><ul>
<li>通过读取 xml 文件，反射实例化对象，放在 FactoryBeanRegistrySupport 类的 factoryBeanObjectCache里面保存起来，该属性是一个 ConcurrentHashMap。</li>
<li>通过 BeanFactory 实例化的 Bean 会在第一次真正使用的时候才初始化。</li>
<li>通过 ApplicationContext 实例化的 Bean 会在创建的时候就初始化了。</li>
</ul>
<h3 id="bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h3><p>scope：指定对象的作用范围，取值如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">取值范围</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">singleton</td>
<td style="text-align:center">唯一 bean 实例，Spring 中的 bean 默认都是单例的。</td>
</tr>
<tr>
<td style="text-align:center">prototype</td>
<td style="text-align:center">每次请求都会创建一个新的 bean 实例。</td>
</tr>
<tr>
<td style="text-align:center">request</td>
<td style="text-align:center">每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</td>
</tr>
<tr>
<td style="text-align:center">session</td>
<td style="text-align:center">每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="spring中的单例bean的线程安全问题"><a href="#Spring中的单例bean的线程安全问题" class="headerlink" title="Spring中的单例bean的线程安全问题"></a>Spring中的单例bean的线程安全问题</h3><p>Spring 的容器本身没有提供 Bean 的线程安全策略，所以需要根据线程的作用域来分析 Bean 是否线程安全。</p>
<p>如果 Bean 是 prototype，那么不存在线程安全问题，因为每次请求 Bean 都是创建一个新的 Bean 对象，线程之间不存在 Bean 共享，所以是线程安全的。【前提是 Bean 里面没有类变量】</p>
<p>如果 Bean 是单例的，且我们给这个 Bean 赋予了状态，那么多线程环境下会产生线程安全问题。比如 Bean 中有一个 count 变量，并提供有 add 方法，在多线程环境下 不添加任何同步措施，count 的值将会是无法预测的。但如果这个 Bean 是无状态的，比如我们常用的 Controller、Service、Dao 这些 Bean 都是无状态的，它们不存在线程安全问题。</p>
<p>如果有需要保存数据的，可以在类中定义一个 ThreadLocal 成员变量，将数据保存在 ThreadLocal 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadLocal.set((<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable sharedRunnableInstance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">99</span></span><br><span class="line"><span class="comment">25</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到并没有出现线程安全问题“一个线程覆盖另一个线程设置的值”，而是各自存取的是不同的值。</p>
<h3 id="component和bean的区别是什么"><a href="#Component和-Bean的区别是什么？" class="headerlink" title="@Component和@Bean的区别是什么？"></a>@Component和@Bean的区别是什么？</h3><ol>
<li>作用对象不同，@Component 注解作用于类，@Bean 注解作用于方法。</li>
<li>@Component 注解表明一个类会作为组件类，并告知 Spring 要为这个类创建 bean（可以用 @ComponentScan 注解来指定要扫描的路径），@Bean 注解告诉 Spring 这个方法将会返回一个对象，这个对象要注册为 Spring 应用上下文中的 bean。通常方法体中包含了最终产生 bean 实例的逻辑。</li>
<li>如果想将第三方的类变成组件，你又没有源代码，也就没办法使用 @Component 进行自动配置，这种时候使用 @Bean 就比较合适了。不过同样的也可以通过xml方式来定义。</li>
</ol>
<p>@Bean 注解使用示例，一般配合 @Configuration 使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transferService"</span> <span class="attr">class</span>=<span class="string">"com.acme.TransferServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="将一个类声明为spring的bean的注解有哪些"><a href="#将一个类声明为Spring的bean的注解有哪些" class="headerlink" title="将一个类声明为Spring的bean的注解有哪些"></a>将一个类声明为Spring的bean的注解有哪些</h3><ul>
<li>@Component：通用注解，可标注任意类为 Spring 组件</li>
<li>@Repository：对应持久层即 Dao 层，主要用于数据库相关操作</li>
<li>@Service：对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层</li>
<li>@Controller：对应 Spring MVC 控制层，主要用于接收用户请求并调用 Service 层返回数据给前端页面</li>
</ul>
<p>被添加了上述四种注解的类可以被 @Autowired 注解自动装配。</p>
<h3 id="bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h3><p><img src="https://pic.tyzhang.top/images/2020/07/16/1159210-20190902212824321-1247257996.png" alt=""></p>
<p>Spring Bean 的完整生命周期从创建 Spring 容器开始，直到最终 Spring 容器销毁 Bean。</p>
<h4 id="一个-bean-的生命周期分为四个阶段"><a href="#一个-Bean-的生命周期分为四个阶段" class="headerlink" title="一个 Bean 的生命周期分为四个阶段"></a>一个 Bean 的生命周期分为四个阶段</h4><blockquote>
<p>如果熟悉过后，可以简单概括为：</p>
<p>Bean的生命周期可以概括为：<br>实例化 Bean对象并设置对象属性<br>检查 Aware 接口并设置相关依赖【Aware接口主要功能就是提醒容器将这个Bean需要依赖的对象注入】<br>BeanPostProcesser 前置处理<br>检查是否实现了 InitializingBean 接口以决定是否调用 afterPropertiesSet方法<br>检查是否配置了自定义的 init-method<br>BeanPostProcesser 后置处理<br>对象使用<br>检查是否实现 DisposableBean 以决定是否调用 destory 方法<br>检查是否配置了自定义的 destory-method</p>
<p><a href="https://blog.csdn.net/abc123lzf/article/details/82981382?ops_request_misc=%7B%22request%5Fid%22%3A%22162065805516780264013486%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&amp;request_id=162065805516780264013486&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-3-82981382.nonecase&amp;utm_term=spring框架" target="_blank" rel="noopener">Spring基础复习：BeanFactory的使用_APlus-CSDN博客</a></p>
</blockquote>
<p><strong>实例化 Instantiation</strong></p>
<ul>
<li>Bean 容器找到配置文件中 Spring Bean 的定义，利用反射机制创建一个 Bean 的实例。</li>
</ul>
<p><strong>属性设置 Populate</strong></p>
<ul>
<li>如果涉及到一些属性值，利用 <code>set()</code> 方法设置属性值。（依赖注入）</li>
<li>如果 Bean 实现了 <code>BeanNameAware</code> anNameAware 接口，将会调用 <code>setBeanName()</code> 方法，获取配置文件中 Bean 的名字，即 id。</li>
<li>如果 Bean 是实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code> 方法，获取 <code>BeanFactory</code> 对象的实例。</li>
<li>类似的如果 Bean 是实现了其他的 <code>*Aware</code> 接口，就调用相应的方法。</li>
</ul>
<p><strong>初始化 Initialization</strong></p>
<ul>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行它的初始化前处理方法。</li>
<li>如果 Bean 实现了<code>InitializingBean</code> 接口，执行 <code>afterPropertiesSet()</code> 方法。</li>
<li>如果 Bean 在配置文件中的定义包含有 init-method 属性，执行指定的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行它的初始化后处理方法。</li>
</ul>
<blockquote>
<p><code>BeanPostProcessor</code> 针对 Spring 上下文中的所有 Bean 都生效。</p>
</blockquote>
<p><strong>销毁 Destruction</strong></p>
<ul>
<li>如果实现了 <code>DiposibleBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>如果 Bean 在配置文件中的定义包含有 destory-method 属性，执行指定的方法。</li>
</ul>
<p><img src="https://pic.tyzhang.top/images/2020/07/16/1159210-20190902212936848-5968038.png" alt=""></p>
<h4 id="总结"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>详细理一理属性设置阶段和初始化阶段。</p>
<p><strong>属性设置阶段</strong></p>
<p>主要是配置文件中 Bean 的一个属性配置和 Bean 本身所实现了 <code>Aware</code> 接口，这些接口更多的是使用在 Spring 的框架代码中，实际开发环境不建议使用。</p>
<p><strong>初始化阶段</strong></p>
<p>如果有  <code>BeanPostProcessor</code> 对象并且 Bean 实现了<code>InitializingBean</code> 接口，那么初始化的顺序是：</p>
<p><code>BeanPostProcessor</code> 对象的初始化前处理方法 <code>postProcessBeforeInitialization()</code> <strong>-&gt;</strong>  <code>afterPropertiesSet()</code> 方法 <strong>-&gt;</strong> <code>init-method</code> 方法 <strong>-&gt;</strong> <code>BeanPostProcessor</code> 对象的初始化后处理方法。</p>
<p>参考博客：</p>
<p><a href="https://www.cnblogs.com/twelve-eleven/p/8080038.html" target="_blank" rel="noopener">Bean初始化之postProcessBeforeInitialization、afterPropertiesSet、init-method、postProcessAfterInitialization等方法的加载 - Twelve_Eleven - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.cnblogs.com/zrtqsk/p/3735273.html" target="_blank" rel="noopener">Spring Bean的生命周期（非常详细） - Chandler Qian - 博客园 (cnblogs.com)</a></p>
<p><a href="https://blog.csdn.net/abc123lzf/article/details/82981382?ops_request_misc=%7B%22request%5Fid%22%3A%22162065805516780264013486%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&amp;request_id=162065805516780264013486&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-3-82981382.nonecase&amp;utm_term=spring框架" target="_blank" rel="noopener">Spring基础复习：BeanFactory的使用_APlus-CSDN博客</a></p>
<h3 id="beanfactory接口"><a href="#BeanFactory接口" class="headerlink" title="BeanFactory接口"></a>BeanFactory接口</h3><p>BeanFactory 接口，是生产 Bean 的工厂，它负责生产和管理各个 Bean 实例。在 Spring 中，BeanFactory 是 IoC 容器的核心接口，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。Spring 提供了许多它的实现，比如 ClassPathXmlApplicationContext、FileSystemXmlApplicationContext、AnnotationConfigApplicationContext 等。</p>
<p>BeanFactory 提供了如下行为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getBean(String name)</td>
<td>根据 Bean 的名字，获取在 IoC 容器中的 Bean 实例</td>
</tr>
<tr>
<td>containsBean(String name)</td>
<td>根据 Bean 的名字进行检索，看看 IoC 容器中是否有这个 Bean</td>
</tr>
<tr>
<td>isSingleton(String name)</td>
<td>根据 Bean 的名字判断这个 Bean 是不是单例。相应的肯定有判断 prototype 等作用域的。</td>
</tr>
<tr>
<td>getType(String name)</td>
<td>得到 Bean 实例的 Class 类型</td>
</tr>
</tbody>
</table>
</div>
<h3 id="applicationcontext接口"><a href="#ApplicationContext接口" class="headerlink" title="ApplicationContext接口"></a>ApplicationContext接口</h3><p>ApplicationContext 是 Spring 继 BeanFactory 之外的另一个核心接口或容器，允许容器通过应用程序上下文环境创建、获取、管理 Bean。</p>
<p>它的实现类：</p>
<ul>
<li>FileSystemXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你需要提供给构造器 XML 文件的完整路径</li>
<li>ClassPathXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你不需要提供 XML 文件的完整路径，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。</li>
<li>WebXmlApplicationContext：该容器会在一个 web 应用程序的范围内加载在 XML 文件中已被定义的 bean。</li>
</ul>
<h3 id="spring-中-beanfactory-和-applicationcontext-的区别"><a href="#Spring-中-BeanFactory-和-ApplicationContext-的区别" class="headerlink" title="Spring 中 BeanFactory 和 ApplicationContext 的区别"></a>Spring 中 BeanFactory 和 ApplicationContext 的区别</h3><ul>
<li>BeanFactroy 采用的是<strong>延迟加载</strong>形式来注入 Bean 的，即只有在使用到某个 Bean 时(调用 getBean())，才对该 Bean 进行加载实例化，这样，我们就不能发现一些存在的 Spring 的配置问题。而 ApplicationContext 则相反，<strong>它是在容器启动时，一次性创建了所有的 Bean</strong>。这样，在容器启动时，我们就可以发现 Spring 中存在的配置错误。</li>
<li>BeanFactory 和 ApplicationContext 都支持 BeanPostProcessor、BeanFactoryPostProcessor 的使用，但两者之间的区别是： BeanFactory 需要手动注册，而 ApplicationContext 则是自动注册</li>
<li>ApplicationContext 包还提供了以下的功能：资源访问，如 URL 和文件；事件传播；载入多个（有继承关系）上下文；MessageSource，提供国际化的消息访问</li>
<li>前者不支持依赖注解，后者支持</li>
</ul>
<p>BeanFactory</p>
<ul>
<li>采用了工厂模式</li>
<li>负责读取 bean 配置文档</li>
<li>管理 bean 的加载，实例化，维护 bean 之间的依赖关系，负责 bean 的生命周期</li>
</ul>
<p>ApplicationContext</p>
<ul>
<li>除了提供上述 BeanFactory 所能提供的功能之外，还提供了更完整的框架功能：国际化支持、aop、事务等</li>
<li>BeanFactory 在解析配置文件时并不会初始化对象，只有在使用对象 getBean() 才会对该对象进行初始化</li>
<li>ApplicationContext 在解析配置文件时对配置文件中的所有对象都初始化了</li>
</ul>
<h3 id="factorybean接口"><a href="#FactoryBean接口" class="headerlink" title="FactoryBean接口"></a>FactoryBean接口</h3><p>FactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。实现了这个接口的类也是一个 Bean，但是这个 Bean 可以生产其他 Bean 的特类。通过对接口方法的实现，这个 Bean 被附加了工厂行为和装饰器行为，而具有了生产能力。</p>
<p>FactoryBean 接口中的主要方法如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getObject()</td>
<td>获取对象</td>
</tr>
<tr>
<td>getObjectType()</td>
<td>获取对象类型</td>
</tr>
<tr>
<td>isSingleton()</td>
<td>是否是单例，如果要获取 FactoryBean 本身这个 Bean 的话，需要在根据名字传参时加一个前缀 &amp;</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>对于实现了 FactoryBean 接口的类来讲，假设有 Person 类依赖一个很复杂的 Car 类。由于 Car 类的实例创建起来很麻烦，所以可以将这个复杂的创建过程包装起来，让 Car 类去实现 FactoryBean 接口，将这个复杂的实例化过程写到 getObject() 方法中，然后我们可以配置 Person 类的 Bean 直接依赖于这个 FactoryBean 即 Car 类就可以了，中间的过程 Spring 已经封装好了。</p>
</blockquote>
<h3 id="beandefinition接口"><a href="#BeanDefinition接口" class="headerlink" title="BeanDefinition接口"></a>BeanDefinition接口</h3><p>BeanDefinition 就是我们所说的 Spring 的 Bean，我们定义的各个 Bean 会转换成一个个的 BeanDefinition 存在于 Spring 的 BeanFactory 中。BeanDefinition 保存了 Bean 的信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。</p>
<h2 id="spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><h3 id="spring管理事务的方式有几种"><a href="#Spring管理事务的方式有几种？" class="headerlink" title="Spring管理事务的方式有几种？"></a>Spring管理事务的方式有几种？</h3><p>2 种，编程式事务和声明式事务。</p>
<p>编程式事务管理使用 TransactionTemplate 来完成；声明式事务通过配置文件来进行配置，可以基于 XML 的声明，也可以基于注解的声明。</p>
<h3 id="spring事务的隔离级别有几种"><a href="#Spring事务的隔离级别有几种？" class="headerlink" title="Spring事务的隔离级别有几种？"></a>Spring事务的隔离级别有几种？</h3><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>
<ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong>  使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h3 id="spring事务中的事务传播行为"><a href="#Spring事务中的事务传播行为" class="headerlink" title="Spring事务中的事务传播行为"></a>Spring事务中的事务传播行为</h3><p>Spring 支持 7 种事务传播行为，确定客户端和被调用端的事务边界。（通俗讲就是多个具有事务控制的 service 相互调用时所形成的复杂的事务边界控制）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>传播行为</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>PROPAGATION_REQUIRED（XML文件中为REQUIRED)</td>
<td>如果没有事务就新建事务，如果存在一个事务就加入这个事务</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS(XML文件中为SUPPORTS）</td>
<td>支持当前事务，如果当前没有事务，就以非事务方式执行</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY(XML文件中为MANDATORY）</td>
<td>使用当前事务，如果没有事务就抛出异常</td>
</tr>
<tr>
<td>PROPAGATION_NESTED(XML文件中为NESTED)</td>
<td>如果当前存在事务，就在嵌套事务内执行，如果当前没有事务，则执行与 REQUIRED 类似的操作</td>
</tr>
<tr>
<td>PROPAGATION_NEVER（XML文件中为NEVER)</td>
<td>以非事务执行，若当前存在事务就抛出异常</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW(XML文件中为REQUIRES_NEW）</td>
<td>新建事务，如果当前存在事务，就把当前事务挂起，各自处理自己的事务</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED（XML文件中为NOT_SUPPORTED）</td>
<td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</td>
</tr>
</tbody>
</table>
</div>
<p><a href="https://blog.csdn.net/lldouble/article/details/80789098" target="_blank" rel="noopener">spring 事务传播行为实例分析_lldouble的博客-CSDN博客</a></p>
<h3 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h3><ul>
<li>Spring 事务的原理是 AOP，失效的根本原因就是这个 AOP 不起作用了</li>
<li>发生自调用，类里面使用 this 调用本类方法，此时这个 this 不是代理类，而是被代理对象【自己调用自己的方法，没办法给 AOP 一样织入方法】</li>
<li>方法不是 public 的</li>
<li>数据库不支持事务</li>
<li>异常被 catch 了，事务不会回滚【catch 抓住了异常，然后又不抛出来，事务就不生效】</li>
<li>抛出的异常没有被定义，默认是 RuntimeException【默认 RuntimeException 异常才回滚，其他类型异常不会回滚，如果想让它回滚，需要在注解上配置一下 <code>@Transactional(rollbackFor = Exception.class)</code>】</li>
</ul>
<p><a href="https://www.jianshu.com/p/4120b89190d0" target="_blank" rel="noopener">(转)Spring事务失效的原因(7个) - 简书 (jianshu.com)</a></p>
<h2 id="spring-循环依赖"><a href="#Spring-循环依赖" class="headerlink" title="Spring 循环依赖"></a>Spring 循环依赖</h2><p><a href="https://www.zhihu.com/question/438247718/answer/1730527725" target="_blank" rel="noopener">Spring 是如何解决循环依赖的？ - 苏三说技术的回答 - 知乎</a></p>
<p><a href="http://baijiahao.baidu.com/s?id=1671801896456911448&amp;qq-pf-to=pcqq.c2c" target="_blank" rel="noopener">面试官：聊聊Spring源码的生命周期、循环依赖 (baidu.com)</a></p>
<p>循环依赖就是 A 依赖 B 的同时，B 也依赖了 A，它们之间的依赖关系构成了一个环形调用。</p>
<ol>
<li>自己依赖自己的直接依赖，A 依赖 A。</li>
<li>两个对象之间的直接依赖，A 依赖 B，B 依赖 A。</li>
<li>多个对象之间的循环依赖，A 依赖 B，B 依赖 C，C 依赖 A。</li>
</ol>
<h3 id="什么情况下循环依赖可以被处理"><a href="#什么情况下循环依赖可以被处理？" class="headerlink" title="什么情况下循环依赖可以被处理？"></a>什么情况下循环依赖可以被处理？</h3><ul>
<li>单例的 setter 注入（能解决）</li>
<li>多例的 setter 注入（不能解决）</li>
<li>构造器注入（不能解决）</li>
<li>单例的代理对象 setter 注入（有可能解决）</li>
<li>DependsOn 循环依赖（不能解决）</li>
</ul>
<h3 id="spring-内部的三级缓存"><a href="#Spring-内部的三级缓存" class="headerlink" title="Spring 内部的三级缓存"></a>Spring 内部的三级缓存</h3><ul>
<li>singletionObjects 一级缓存【单例池】，用于保存实例化、注入、初始化完成的 bean 实例【创建好了的单例 bean】</li>
<li>earlySingletonObjects 二级缓存，用于保存实例化完成的 bean 实例【属性还未填充完，可能是代理对象，也可能是原始对象】</li>
<li>singletonFactories 三级缓存，存放可以生成 bean 的工厂，工厂主要用来生成 bean 的代理对象。</li>
</ul>
<h3 id="spring-如何解决循环依赖"><a href="#Spring-如何解决循环依赖？" class="headerlink" title="Spring 如何解决循环依赖？"></a>Spring 如何解决循环依赖？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService2 testService2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService1 testService1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-1e7bd042df73e47bb951e70b298c96ca_720w.jpg?source=1940ef5c" alt=""></p>
<p>Spring 通过三级缓存解决了循环依赖，其中一级缓存为单例池（singletonObjects），二级缓存为早期曝光对象（earlySingletonObjects），三级缓存为早期曝光对象工厂（singletonFactories）。</p>
<p>当 A、B 两个类发生循环引用时，在 A 完成实例化后，就是用实例化后的对象去创建一个对象工厂，并添加到三级缓存中。如果 A 被 AOP 代理，那么通过这个工厂获取到的就是 A 代理后的对象，如果 A 没有被 AOP 代理，那么这个工厂获取到的就是 A 实例化的对象。</p>
<p>当 A 进行属性注入时，会去创建 B，同时 B 又依赖了 A，所以创建 B 的同时又会去调用 <code>getBean(a)</code> 来获取需要的依赖，此时的 <code>getBean(a)</code> 会从缓存中获取：（其实还有一步是先去一级缓存看看有没有创建好了的单例）</p>
<ol>
<li>先获取到三级缓存中的工厂</li>
<li>调用对象工厂的 <code>getObject()</code> 方法来获取到对应的对象【没有被 AOP 代理就直接返回实例化的对象，有被 AOP 代理就返回代理后的对象】</li>
</ol>
<p>得到这个对象后将其注入到 B 中。紧接着 B 会走完它的生命周期流程，包括初始化、后置处理器等。当 B 创建完后，会将 B 再注入到 A 中，此时 A 再完成它的整个生命周期。至此，循环依赖结束。</p>
<h3 id="为什么要三级缓存二级缓存能解决循环依赖吗"><a href="#为什么要三级缓存？二级缓存能解决循环依赖吗？" class="headerlink" title="为什么要三级缓存？二级缓存能解决循环依赖吗？"></a>为什么要三级缓存？二级缓存能解决循环依赖吗？</h3><p>当 A、B 两个类发生循环引用时，如果对 A 进行了 AOP 代理，那么在创建 B 并且注入依赖的时候，我们希望从容器中获取到的是 A 代理后的对象，而不是 A 本身。利用三级缓存，只有在真正发生循环依赖的时候，才去提前生成代理对象，否则只会创建一个工厂并将其放入三级缓存中，但不会去通过这个工厂真正创建对象。</p>
<p>如果要使用二级缓存解决循环依赖，意味着所有 bean 在实例化后就要完成 AOP 代理，这样违背了 Spring 设计的原则，Spring 在设计之初就是通过后置处理器来在 bean 生命周期的最后一步完成 AOP 代理，而不是在实例化后就立马进行 AOP 代理。</p>
<h2 id="spring的自动装配"><a href="#Spring的自动装配" class="headerlink" title="Spring的自动装配"></a>Spring的自动装配</h2><p>自动装配指的是让我们定义的 Bean 自动注入属性。</p>
<p>Spring 中 Bean 有三种装配机制，分别是：</p>
<ul>
<li>在 xml 中显式装配；【在 xml 中指定要装配的依赖项】</li>
<li>在 Java 中显式装配；</li>
<li>隐式的自动装配；</li>
</ul>
<p><strong>自动装配</strong></p>
<ul>
<li><p>defalt：用 ref 指定注入的属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.zbsong.pojo.Dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.zbsong.pojo.Cat"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.zbsong.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cat"</span> <span class="attr">ref</span>=<span class="string">"cat"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dog"</span> <span class="attr">ref</span>=<span class="string">"dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>byName：根据 Bean 名字进行装配</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.zbsong.pojo.User"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果和 ref 一样，当一个 bean 节点带有 <code>autowire=&quot;byName&quot;</code> 的属性时，</p>
<ol>
<li>查找其类中所有的 set 方法名，获得属性要注入的属性名</li>
<li>去 Spring 容器中寻找是否有 id 和此属性名对应的对象</li>
<li>如果有，就取出注入；如果没有，就报空指针异常</li>
</ol>
</li>
<li><p>byType：根据 Bean 的类型进行装配</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.zbsong.pojo.User"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>autowire=&quot;byType&quot;</code> （按类型自动装配），需要首先保证同一个类型的对象，在 Spring 容器中唯一，如果不唯一则会抛出  NoUniqueBeanDefinitionException 异常。【即如果此时 Spring 容器中有两个 Cat 类型的对象 cat1 和  cat 2，那么按类型自动装配的时候就没办法确认去注入哪一个对象】</p>
</li>
<li><p>constructor：根据构造函数参数进行装配</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.zbsong.pojo.User"</span> <span class="attr">autowire</span>=<span class="string">"constructor"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实际上时按照构造函数的参数类型自动装配</p>
</li>
<li><p>autodetect：有默认构造器的情况下通过 constructor 方式装配，否则使用 byType 进行装配</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.zbsong.pojo.User"</span> <span class="attr">autowire</span>=<span class="string">"autodetect"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>@AutoWired 可以在字段、setter 方法、构造函数上使用，进行自动装配</p>
<p>作用在方法上，如果方法有参数会在 Spring 容器中查找是否有对应类型的对象，并且会执行该方法</p>
<p>作用在构造函数上可以明确成员变量的加载顺序。比如下面的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"><span class="keyword">private</span> String school;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserAccountServiceImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.school = user.getSchool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码会先执行构造方法，然后再给标注了 @Autowired 的 user 注入值，所以在执行构造方法的时候会报错。</p>
<p>解决办法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"><span class="keyword">private</span> String school;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserAccountServiceImpl</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.user = user;</span><br><span class="line">    <span class="keyword">this</span>.school = user.getSchool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为变量初始化的顺序为：静态变量或静态语句块 -&gt; 实例变量或初始化语句块 -&gt; 构造方法 -&gt; @Autowired</p>
</li>
</ul>
<h1 id="spring-mvc"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><p>MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="https://pic.tyzhang.top/images/2021/05/19/image.png" alt="image.png"></p>
<p>流程说明：</p>
<ol>
<li>客户端（浏览器）发起请求到前端控制器（DispatcherServlet）。</li>
<li>前端控制器请求处理器映射器（HandlerMapping）查找 Handler（可以根据xml配置、注解进行查找）。</li>
<li>处理器映射器解析到对应的 Handler 后，同拦截器（interceptor）一并构建执行链（HandlerExecutionChain）返回给前端控制器。</li>
<li>前端控制器调用处理器适配器（HandlerAdapter）去执行 Handler。</li>
<li>处理器适配器将会根据适配的结果去执行 Handler（执行的即我们平常讲的 Controller 控制器）。</li>
<li>Handler 执行完成给处理器适配器返回 ModelAndView。</li>
<li>处理器适配器向前端控制器返回 ModelAndView。</li>
<li>前端控制器请求视图解析器去进行视图解析。</li>
<li>视图解析器向前端控制器返回View。</li>
<li>前端控制器进行视图渲染 ，将模型数据填充到 request 域中。</li>
<li>前端控制器向用户响应结果。</li>
</ol>
<p><a href="https://www.cnblogs.com/myitnews/p/11565941.html" target="_blank" rel="noopener">SpringMVC详细流程（一） - codedot - 博客园 (cnblogs.com)</a></p>
<h3 id="controller-和-requestmapping-如何对应"><a href="#Controller-和-RequestMapping-如何对应" class="headerlink" title="Controller 和 RequestMapping 如何对应"></a>Controller 和 RequestMapping 如何对应</h3><p>Spring MVC 初始化的时候，会对所有的 Bean 扫描，添加了 @Controler 注解以及 @RequestMapping 注解的 Bean 添加到 Map 里面，他是一个 LinkedHashMap。key 是 url ，value 是 RequestMappingInfo。</p>
<h1 id="spring-boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><h2 id="spring-boot介绍"><a href="#Spring-Boot介绍" class="headerlink" title="Spring Boot介绍"></a>Spring Boot介绍</h2><p>Spring 是 EJB（重量级企业开发框架）的替代品，通过依赖注入和面向切面编程，用简单的 Java 对象（POJO）实现了 EJB 的功能。</p>
<p>虽然 Spring 的组件代码是轻量级的，但它的配置却是重量级的（需要大量 XML 配置）。</p>
<p>Spring 2.5 引入了基于注解的组件扫描，消除了大量的 XML 配置的 <code>&lt;bean&gt;</code> 定义。Spring 3.0 引入了基于 Java 的配置，可以替代 XML。</p>
<p>尽管如此，在开启某些 Spring 特性，比如事务管理和 Spring MVC，还是需要用 XML 或 Java 进行显示配置。配置 Servlet 和过滤器（比如 Spring 的 DispacherServlet）同样需要在 web.xml 或 Servlet 初始化代码里进行显示配置。</p>
<p>从本质上来讲，Spring Boot 就是 Spring，它做了那些没有它你自己也会去做的 Spring Bean 配置。Spring Boot 旨在简化 Spring 开发。</p>
<p><strong>Spring Boot优点</strong></p>
<ol>
<li>Spring Boot 不需要编写大量样板代码、XML 配置和注释。</li>
<li>Spring Boot 可以很容易地与 Spring 生态系统集成，如 Spring JDBC、Spring ORM等。</li>
<li>Spring Boot 遵循默认配置，以减少开发工作（默认配置可以修改）。</li>
<li>Spring Boot 应用程序提供嵌入式 HTTP 服务器，如 Tomcat，可以轻松地开发和测试 web 应用程序。</li>
</ol>
<p><a href="https://blog.csdn.net/csdnliuxin123524/article/details/88359309" target="_blank" rel="noopener">spring ORM是什么，spring的七大模块有哪些_小爷欣欣-CSDN博客</a></p>
<h2 id="spring-boot-如何创建项目"><a href="#Spring-Boot-如何创建项目" class="headerlink" title="Spring Boot 如何创建项目"></a>Spring Boot 如何创建项目</h2><p>可以通过 <a href="https://start.aliyun.com/bootstrap.html" target="_blank" rel="noopener">https://start.aliyun.com/bootstrap.html</a> 来生成一个 Spring Boot 项目。也可以通过 IDEA 创建一个。</p>
<h2 id="spring-boot-项目结构"><a href="#Spring-Boot-项目结构" class="headerlink" title="Spring Boot 项目结构"></a>Spring Boot 项目结构</h2><ul>
<li>src 文件夹：存放工程代码的地方<ul>
<li>main/java 文件夹：存放源代码</li>
<li>main/resources<ul>
<li>static 文件夹：存放静态文件，比如图片、css、js等</li>
<li>templates 文件夹：存放模板文件，比如 jsp、thymeleaf 等</li>
</ul>
</li>
<li>test 文件夹：存放测试文件</li>
</ul>
</li>
</ul>
<p>在 <code>src/main/java</code> 中 Application.java 是项目的启动类，需要放到最外层，不然会导致一些类无法被正确扫描到。</p>
<ol>
<li>domain 目录主要用于实体（Entity）与数据访问层（Repository）</li>
<li>service 层主要是业务类代码</li>
<li>controller 负责页面访问控制</li>
<li>config 目录主要放一些配置类</li>
</ol>
<h2 id="springbootapplication-注解"><a href="#SpringBootApplication-注解" class="headerlink" title="@SpringBootApplication 注解"></a>@SpringBootApplication 注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(HelloWorldApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span> <span class="comment">// 1</span></span><br><span class="line"><span class="meta">@ComponentScan</span> <span class="comment">// 2</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span> <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">//实际上它也是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Boot 的核心注解 @SpringBootApplication 可以被看作是 @Configuration、@EnableAutoConfiguration、@ComponentScan 注解的集合。这三个注解的作用分别是：</p>
<ul>
<li>@EnableAutoConfiguration：启用 Spring Boot 的自动配置机制</li>
<li>@Configuration：允许在上下文中通过注册额外的 bean 或导入其他配置类</li>
<li>@ComponentScan：扫描被 @Component（@Service、@Controller）注解的 bean，默认会扫描启动类所在包下的所有类。</li>
</ul>
<h2 id="spring-如何读取配置文件"><a href="#Spring-如何读取配置文件" class="headerlink" title="Spring 如何读取配置文件"></a>Spring 如何读取配置文件</h2><p>我们常将一些常用的配置信息放入配置文件当中，Spring 支持我们通过以下方式读取这些配置信息。</p>
<h3 id="通过-value-注解读取"><a href="#通过-Value-注解读取" class="headerlink" title="通过 @Value 注解读取"></a>通过 @Value 注解读取</h3><p>格式 <code>@Value(&quot;${property}&quot;)</code> 读取比较简单的配置信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;username&#125;"</span>)</span><br><span class="line">String username;</span><br></pre></td></tr></table></figure>
<h3 id="通过-configurationproperties-读取"><a href="#通过-ConfigurationProperties-读取" class="headerlink" title="通过 @ConfigurationProperties 读取"></a>通过 @ConfigurationProperties 读取</h3><ol>
<li><p>使用 @ConfigurationProperties 和 @Component 注解到 bean 定义类上，这里 @Component 代指同一类实例化 Bean 的注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将类定义为一个bean的注解，比如 @Component,@Service,@Controller,@Repository</span></span><br><span class="line"><span class="comment">// 或者 @Configuration</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 表示使用配置文件中前缀为user的属性的值初始化该bean定义产生的的bean实例的同名属性</span></span><br><span class="line"><span class="comment">// 在使用时这个定义产生的bean时，其属性name会是Tom</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="comment">// 省略getter/setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应application.properties配置文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.name=Tom</span><br><span class="line">user.age=11</span><br></pre></td></tr></table></figure>
<p>在此种场景下，当 Bean 被实例化时，@ConfigurationProperties 会将对应前缀的后面的属性与 Bean 对象的属性匹配。符合条件则进行赋值。</p>
</li>
<li><p>使用 @ConfigurationProperties 和 @Bean 注解在配置类的Bean定义方法上。以数据源配置为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Primary</span></span><br><span class="line">	<span class="meta">@Bean</span>(name = <span class="string">"primaryDataSource"</span>)</span><br><span class="line">	<span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"spring.datasource.primary"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> DataSource <span class="title">primaryDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里便是将前缀为“spring.datasource.primary”的属性，赋值给 DataSource 对应的属性值。</p>
<p>@Configuration 注解的配置类中通过 @Bean 注解在某个方法上将方法返回的对象定义为一个 Bean，并使用配置文件中相应的属性初始化该 Bean 的属性。</p>
</li>
<li><p>使用 @ConfigurationProperties 注解到普通类，然后再通过 @EnableConfigurationProperties 定义为 Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"user1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="comment">// 省略getter/setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 User 对象并没有使用 @Component 相关注解。而该 User 类对应的使用形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;User.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，通过 @EnableConfigurationProperties 对 User 进行实例化时，便会使用到 @ConfigurationProperties 的功能，对属性进行匹配赋值。</p>
</li>
</ol>
<h2 id="spring-boot-如何处理异常"><a href="#Spring-Boot-如何处理异常" class="headerlink" title="Spring Boot 如何处理异常"></a>Spring Boot 如何处理异常</h2><p><a href="https://www.cnblogs.com/ding-dang/p/13049181.html" target="_blank" rel="noopener">Spring全局异常处理 - 叮叮叮叮叮叮当 - 博客园 (cnblogs.com)</a></p>
<p>使用 @ControllerAdvice 和 @ExceptionHandler 处理全局异常。</p>
<ol>
<li>自定义异常类型，继承 RuntimeException 类。</li>
<li>创建异常处理类，类上添加 @ControllerAdvice  注解，可以添加 assignableTypes 参数指定只处理特定 Controller 类的异常。</li>
<li>在异常处理方法上添加 @ExceptionHandler(value = Exception.class)，value 可以指定要处理的是哪一类异常，此处表示所有异常都走这里。</li>
</ol>
<p><strong>1. 新建异常信息实体类</strong></p>
<p>非必要的类，主要用于包装异常信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/twuc/webApp/exception/ErrorResponse.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> String errorTypeName;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorResponse</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(e.getClass().getName(), e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorResponse</span><span class="params">(String errorTypeName, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorTypeName = errorTypeName;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">    ......省略getter/setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 自定义异常类型</strong></p>
<p>一般我们处理的都是 <code>RuntimeException</code> ，所以如果你需要自定义异常类型的话直接集成这个类就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/twuc/webApp/exception/ResourceNotFoundException.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceNotFoundException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceNotFoundException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceNotFoundException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 新建异常处理类</strong></p>
<p>我们只需要在类上加上 @ControllerAdvice 注解这个类就成为了全局异常处理类，当然你也可以通过 assignableTypes  指定特定的 Controller 类，让异常处理类只处理特定类抛出的异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/twuc/webApp/exception/GlobalExceptionHandler.java</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span>(assignableTypes = &#123;ExceptionController.class&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ErrorResponse illegalArgumentResponse = <span class="keyword">new</span> ErrorResponse(<span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误!"</span>));</span><br><span class="line">    ErrorResponse resourseNotFoundResponse = <span class="keyword">new</span> ErrorResponse(<span class="keyword">new</span> ResourceNotFoundException(<span class="string">"Sorry, the resourse not found!"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception.class)<span class="comment">// 拦截所有异常, 这里只是为了演示，一般情况下一个方法特定处理一种异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;ErrorResponse&gt; <span class="title">exceptionHandler</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IllegalArgumentException) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.status(<span class="number">400</span>).body(illegalArgumentResponse);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ResourceNotFoundException) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.status(<span class="number">404</span>).body(resourseNotFoundResponse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. controller模拟抛出异常</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/twuc/webApp/web/ExceptionController.java</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/illegalArgumentException"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/resourceNotFoundException"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwException2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ResourceNotFoundException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. 测试</strong></p>
<p>使用 Get 请求 <code>localhost:8080/api/resourceNotFoundException</code> ，服务端返回的 JSON 数据如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"Sorry, the resourse not found!"</span>,</span><br><span class="line">    <span class="attr">"errorTypeName"</span>: <span class="string">"com.twuc.webApp.exception.ResourceNotFoundException"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以通过 MockMvc 类在 test 中模拟 Http 请求，MockMvc 由 <code>org.springframework.boot.test</code> 包提供。</p>
<h2 id="jpa"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h2><p>JPA 是 Java persistence API 的简称，Java 持久层 API，是 JDK 5.0 注解或 XML 描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。</p>
<p><a href="https://blog.csdn.net/wujiaqi0921/article/details/78789087" target="_blank" rel="noopener">spring boot 中使用 jpa以及jpa介绍_ 深存少年梦-CSDN博客_jpa</a></p>
<h3 id="如何使用jpa在数据库中非持久化一个字段"><a href="#如何使用JPA在数据库中非持久化一个字段？" class="headerlink" title="如何使用JPA在数据库中非持久化一个字段？"></a>如何使用JPA在数据库中非持久化一个字段？</h3><p>假设有一个类有以下属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Entity(name=<span class="string">"USER"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String secrect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要让 secrect 这个字段不被持久化，即不被数据库存储怎么办呢？可以采用下面几种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String transient1; <span class="comment">// not persistent because of static</span></span><br><span class="line"><span class="keyword">final</span> String transient2 = “Satish”; <span class="comment">// not persistent because of final</span></span><br><span class="line"><span class="keyword">transient</span> String transient3; <span class="comment">// not persistent because of transient</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line">String transient4; <span class="comment">// not persistent because of @Transient</span></span><br></pre></td></tr></table></figure>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Filter 过滤器主要是用来过滤用户请求的，它允许我们对用户请求进行前置处理和后置处理，比如过滤非法请求。Filter 过滤器是面向切面编程——AOP 的具体实现（AOP 切面编程只是一种编程思想而已）。</p>
<p>如果想要自定义 Filter 的话非常简单，只需要实现 <code>javax.Servlet.Filter</code> 接口，然后重写里面的 3 个方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Filter.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//初始化过滤器后执行的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span><br><span class="line">   <span class="comment">// 对请求进行过滤</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest var1, ServletResponse var2, FilterChain var3)</span> <span class="keyword">throws</span> IOException, ServletException</span>;</span><br><span class="line">   <span class="comment">// 销毁过滤器后执行的操作，主要用户对某些资源的回收</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何实现过滤的"><a href="#如何实现过滤的？" class="headerlink" title="如何实现过滤的？"></a>如何实现过滤的？</h3><p>Filter 接口中有一个叫做 <code>doFilter()</code> 的方法，这个方法实现了对用户请求的过滤。具体流程：</p>
<ol>
<li>用户发送请求到 web 服务器，请求会先到过滤器。</li>
<li>过滤器对请求进行一些处理，比如过滤请求参数、修改返回给客户端的 response 内容、判断是否让用户访问该接口等等，再发送给目标资源。</li>
<li>用户请求响应完毕后，响应会先到过滤器，对响应内容进行一些处理，再把响应发送给客户端。</li>
</ol>
<p><img src="https://camo.githubusercontent.com/c2a4df886695d5efc1a1b2ce1d891f01c2984189b57258826a8b50a0d900d79e/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f66696c746572312e706e67" alt=""></p>
<h3 id="自定义filter"><a href="#自定义Filter" class="headerlink" title="自定义Filter"></a>自定义Filter</h3><p>多个 Filter 可以通过设置优先级来决定它们的执行顺序。</p>
<p><strong>手动注册配置实现</strong></p>
<p>自定义的 Filter 需要实现 <code>javax.Servlet.Filter</code> 接口，并重写接口中定义的 3 个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"初始化过滤器："</span>, filterConfig.getFilterName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//对请求进行预处理</span></span><br><span class="line">        logger.info(<span class="string">"过滤器开始对请求进行预处理："</span>);</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">        String requestUri = request.getRequestURI();</span><br><span class="line">        System.out.println(<span class="string">"请求的接口为："</span> + requestUri);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//通过 doFilter 方法实现过滤功能，它会自动的去寻找下一个过滤器，执行完后返回这里，可以看作是一个递归的过程</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        <span class="comment">// 上面的 doFilter 方法执行结束后用户的请求已经返回</span></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"该用户的请求已经处理完毕，请求花费的时间为："</span> + (endTime - startTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"销毁过滤器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在配置中注册自定义的过滤器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilterConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyFilter myFilter;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;MyFilter&gt; <span class="title">registFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean&lt;MyFilter&gt; filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;();</span><br><span class="line">		<span class="comment">// 注册自定义过滤器</span></span><br><span class="line">        filterRegistrationBean.setFilter(myFilter);</span><br><span class="line">		<span class="comment">// 指定过滤路径</span></span><br><span class="line">        filterRegistrationBean.setUrlPatterns(<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"/api/*"</span>)));</span><br><span class="line">		<span class="comment">// 设置优先级</span></span><br><span class="line">        <span class="comment">// filterRegistrationBean.setOrder(1);//优先级，1最顶级，越小越优先</span></span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过提供好的一些注解实现</strong></p>
<p>在自定义的过滤器类上加上注解 @WebFilter，然后再这个注解中通过它提供好的一些参数进行配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"MyFilterWithAnnotation"</span>, urlPatterns = <span class="string">"/api/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilterWithAnnotation</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，为了能让 Spring 找到它，你需要在启动类上加上 @ServletComponentScan 注解。</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>拦截器（Interceptor）同过滤器 Filter 一样，它们都是面向切面编程。在 Spring 中，当请求发送到 Controller 时，在被 Controller 处理之前，它必须经过 Interceptors（0 个或多个）。Spring Interceptor 是一个非常类似于 Servlet Filter 的概念 。</p>
<h3 id="自定义-interceptor"><a href="#自定义-Interceptor" class="headerlink" title="自定义 Interceptor"></a>自定义 Interceptor</h3><p>如果需要自定义 Interceptor，必须实现 <code>org.springframework.web.servlet.HandlerInterceptor</code> 接口或者继承 <code>org.springframework.web.servlet.handler.HandlerInterceptorAdapter</code> 类，并且需要重写下面 3 个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                         HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Object handler)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                       HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                       ModelAndView modelAndView)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                            HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Exception ex)</span></span></span><br></pre></td></tr></table></figure>
<p>每个请求可能会通过许多拦截器。下图说明了这一点。</p>
<p><img src="https://camo.githubusercontent.com/553bef452ebd4cc9bca0f889ec40d0e3d555f40034b433c55404c8e297b213d0/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f696e746572636570746f722d737072696e672e706e67" alt=""></p>
<p>LogInterceptor 用于过滤所有请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"\n-------- LogInterception.preHandle --- "</span>);</span><br><span class="line">        System.out.println(<span class="string">"Request URL: "</span> + request.getRequestURL());</span><br><span class="line">        System.out.println(<span class="string">"Start Time: "</span> + System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        request.setAttribute(<span class="string">"startTime"</span>, startTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, //</span></span></span><br><span class="line"><span class="function"><span class="params">                           Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"\n-------- LogInterception.postHandle --- "</span>);</span><br><span class="line">        System.out.println(<span class="string">"Request URL: "</span> + request.getRequestURL());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// You can add attributes in the modelAndView</span></span><br><span class="line">        <span class="comment">// and use that in the view page</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, //</span></span></span><br><span class="line"><span class="function"><span class="params">                                Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"\n-------- LogInterception.afterCompletion --- "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = (Long) request.getAttribute(<span class="string">"startTime"</span>);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"Request URL: "</span> + request.getRequestURL());</span><br><span class="line">        System.out.println(<span class="string">"End Time: "</span> + endTime);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Time Taken: "</span> + (endTime - startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置拦截器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// LogInterceptor apply to all URLs.</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LogInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过 <code>addPathPatterns()</code> 指定拦截哪个请求，<code>excludePathPatterns()</code> 指定不拦截哪个请求。</p>
<h2 id="拦截器和过滤器的区别"><a href="#拦截器和过滤器的区别" class="headerlink" title="拦截器和过滤器的区别"></a>拦截器和过滤器的区别</h2><ul>
<li>过滤器 Filter：运行在所有Servlet之前。是Java EE体系中的组件，无论是否使用其它框架都可以使用过滤器来实现拦截的效果。<ul>
<li>当你有一堆东西的时候，你只希望选择符合你要求的东西。定义这些要求的工具就是过滤器。</li>
</ul>
</li>
<li>拦截器 Interceptor：运行在 DispatcherServlet 之后。是 Spring MVC 框架中的组件，只有项目中使用了Spring MVC 框架才可以使用拦截器。<ul>
<li>在一个流程正在进行的时候，你希望干预它的进展，甚至终止它，这是拦截器做的事情。</li>
</ul>
</li>
</ul>
<ul>
<li>拦截器可以获取 Spring 容器中的各个 bean，而过滤器不行</li>
</ul>
<p><img src="https://images2017.cnblogs.com/blog/330611/201710/330611-20171023150603801-320372296.png" alt=""></p>
<p>拦截器功在对请求权限鉴定方面确实很有用处，在我所参与的这个项目之中，第三方的远程调用每个请求都需要参与鉴定，所以这样做非常方便，而且他是很独立的逻辑，这样做让业务逻辑代码很干净。</p>
<p><a href="https://www.cnblogs.com/panxuejun/p/7715917.html" target="_blank" rel="noopener">拦截器和过滤器的区别 - THISISPAN - 博客园 (cnblogs.com)</a></p>
<h2 id="spring-boot-自动装配原理"><a href="#Spring-Boot-自动装配原理" class="headerlink" title="Spring Boot 自动装配原理"></a>Spring Boot 自动装配原理</h2><p><strong>口水话回答</strong></p>
<p>自动装配就是可以通过注解或者一些简单的配置，就能在 Spring Boot 的帮助下实现某块功能，可以省去很多配置。具体的做法是引入一个 xxx-starter 第三方包，然后就可以使用了。</p>
<p>核心原理就是通过 Spring 扫描 META-INF/spring.factories 文件，识别需要自动装配的类，然后经过条件过滤，把最终需要自动装配的类加载到 IoC 容器中。</p>
<p>它的实现原理是通过核心注解 @SpringBootApplication 中的 @EnableAutoConfiguration 注解当中导入的加载自动装配类 <strong>AutoConfigurationImportSelector</strong> 实现的。该类继承了 ImportSelector 接口并实现了接口的 <code>selectImport()</code> 方法，通过该方法可以获取所有符合条件的类的全限定名，把这些类加载到 IoC 容器中。自动装配的步骤如下：</p>
<ol>
<li><p>判断自动装配开关是否打开</p>
<blockquote>
<p>默认spring.boot.enableautoconfiguration=true，可在 application.properties 或 application.yml 中设置</p>
</blockquote>
</li>
<li><p>调用 <code>getAutoConfigurationEntry()</code> 方法，获取所有需要装配的 bean：</p>
<ol>
<li>获取 EnableAutoConfiguration 注解中的 exclude 和 excludeName</li>
<li>读取 <code>META-INF/spring.factories</code>，目的是获取需要自动装配的所有配置类</li>
<li>进行筛选，配置类上会有条件注解，满足所有条件注解 @ConditionalOnXXX 的配置类才会被注入到 IoC 容器中</li>
</ol>
</li>
</ol>
<h3 id="什么是-spring-boot-自动装配"><a href="#什么是-Spring-Boot-自动装配？" class="headerlink" title="什么是 Spring Boot 自动装配？"></a>什么是 Spring Boot 自动装配？</h3><p>Spring Boot 在启动时扫描外部引用 jar 包中地 <code>META-INF/spring.factories</code> 文件，将文件中配置地类型信息加载到 Spring 容器，并执行类中定义的各种操作。对外部 jar 来说，只需要按照 Spring Boot 定义的标准，就能将自己的功能装进 Spring Boot中。（这个格式是 <code>自动配置的类全名.条件=值</code>）</p>
<p>大白话来讲就是：通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</p>
<p>自动装配可以用来引入第三方包，只需要引入一个 xxx-starter 就可以了，省去了很多的配置。</p>
<h3 id="spring-boot-是如何实现自动装配的"><a href="#Spring-Boot-是如何实现自动装配的？" class="headerlink" title="Spring Boot 是如何实现自动装配的？"></a>Spring Boot 是如何实现自动装配的？</h3><p>通过核心注解 @SpringBootApplication 中的 @EnableAutoConfiguration 注解中导入的加载自动装配类 AutoConfigurationImportSelector 实现的。该类继承了 ImportSelector  接口，实现了该接口的 <code>selectImports()</code> 方法，该方法主要用于获取所符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中，步骤如下：</p>
<ol>
<li><p>判断自动装配开关是否打开</p>
<blockquote>
<p>默认spring.boot.enableautoconfiguration=true，可在 application.properties 或 application.yml 中设置</p>
</blockquote>
</li>
<li><p>获取所有需要装配的 bean，<code>getAutoConfigurationEntry()</code> 方法：</p>
<ol>
<li>获取 EnableAutoConfiguration 注解中的 exclude 和 excludeName</li>
<li>获取需要自动装配的所有配置类，读取 <code>META-INF/spring.factories</code></li>
<li>筛选，满足所有条件注解 @ConditionalOnXXX 的类才会生效</li>
</ol>
</li>
</ol>
<p>Spring Boot 通过 @EnableAutoConfiguration 开启自动装配，通过 SpringFactoriesLoader 类最终加载 <code>META-INF/spring.factories</code> 中的自动配置类实现自动装配，自动配置类其实就是通过 @Conditional 按需加载的配置类，想要其生效必须引入 <code>spring-boot-starter-xxx</code> 包实现起步依赖。</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span> <span class="comment">// 1</span></span><br><span class="line"><span class="meta">@ComponentScan</span> <span class="comment">// 2</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span> <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Boot 的核心注解 @SpringBootApplication 可以被看作是 @Configuration、@EnableAutoConfiguration、@ComponentScan 注解的集合。这三个注解的作用分别是：</p>
<ul>
<li>@EnableAutoConfiguration：启用 Spring Boot 的自动装配机制</li>
<li>@Configuration：这个注解实际上就是代表了一个配置类，相当于一个 xml 文件</li>
<li>@ComponentScan：扫描被 @Component（@Service、@Controller）注解的 bean，默认会扫描启动类所在包下的所有类。</li>
</ul>
<p><strong>@EnableAutoConfiguration</strong> 是实现自动装配的重要注解，从它入手。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span> <span class="comment">//作用：将main包下的所欲组件注册到容器中</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;AutoConfigurationImportSelector.class&#125;) <span class="comment">//加载自动装配类 xxxAutoconfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@EnableAutoConfiguration 只是一个简单的注解，自动装配核心功能的实现就是由 AutoConfigurationImportSelector 类实现的。</p>
<p><strong>AutoConfigurationImportSelector </strong>  加载自动装配类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeferredImportSelector</span> <span class="keyword">extends</span> <span class="title">ImportSelector</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    String[] selectImports(AnnotationMetadata var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AutoConfigurationImportSelector 类实现了 ImportSelector 接口，接口中的 <code>selectImports()</code> 方法主要用于获取所符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中。它的具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] NO_IMPORTS = <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="comment">// &lt;1&gt;.判断自动装配开关是否打开</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// &lt;2&gt;.获取所有需要装配的bean</span></span><br><span class="line">        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">        AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = <span class="keyword">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c1200712655443ca4b38500d615bb70~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>现在我们结合 <code>getAutoConfigurationEntry()</code> 的源码来详细分析一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AutoConfigurationEntry EMPTY_ENTRY = <span class="keyword">new</span> AutoConfigurationEntry();</span><br><span class="line"></span><br><span class="line"><span class="function">AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;1&gt;.判断自动装配开关是否打开。默认spring.boot.enableautoconfiguration=true，可在 application.properties 或 application.yml 中设置</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// &lt;2&gt;.用于获取EnableAutoConfiguration注解中的 exclude 和 excludeName</span></span><br><span class="line">        AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">        <span class="comment">//&lt;3&gt;.获取需要自动装配的所有配置类，读取META-INF/spring.factories</span></span><br><span class="line">        List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">        <span class="comment">//&lt;4&gt;.筛选，@ConditionalOnXXX 中的所有条件都满足，该类才会生效。</span></span><br><span class="line">        configurations = <span class="keyword">this</span>.removeDuplicates(configurations);</span><br><span class="line">        Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">        <span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations = <span class="keyword">this</span>.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">        <span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Spring Boot 提供的条件注解</strong></p>
<ul>
<li>@ConditionalOnBean：当容器里有指定 Bean 的条件下</li>
<li>@ConditionalOnMissingBean：当容器里没有指定 Bean 的情况下</li>
<li>@ConditionalOnSingleCandidate：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean</li>
<li>@ConditionalOnClass：当类路径下有指定类的条件下</li>
<li>@ConditionalOnMissingClass：当类路径下没有指定类的条件下</li>
<li>@ConditionalOnProperty：指定的属性是否有指定的值</li>
<li>@ConditionalOnResource：类路径是否有指定的值</li>
<li>@ConditionalOnExpression：基于 SpEL 表达式作为判断条件</li>
<li>@ConditionalOnJava：基于 Java 版本作为判断条件</li>
<li>@ConditionalOnJndi：在 JNDI 存在的条件下差在指定的位置</li>
<li>@ConditionalOnNotWebApplication：当前项目不是 Web 项目的条件下</li>
<li>@ConditionalOnWebApplication：当前项目是 Web 项 目的条件下</li>
</ul>
<h2 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h2><p>第一步，创建<code>threadpool-spring-boot-starter</code>工程</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ff0ebe7844f40289eb60213af72c5a6~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>第二步，引入 Spring Boot 相关依赖</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e14254276604f87b261e5a80a354cc0~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>第三步，创建 ThreadPoolAutoConfiguration 类，添加 @Confuguration注解，在类中创建线程池的方法上添加注解 @Bean 和 @ConditionOnClass(ThreadPoolExecutor.class)</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1843f1d12c5649fba85fd7b4e4a59e39~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>第四步，在 <code>threadpool-spring-boot-starter</code> 工程的 resources 包下创建 <code>META-INF/spring.factories</code> 文件</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97b738321f1542ea8140484d6aaf0728~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>第五步，新建工程引入 <code>threadpool-spring-boot-starter</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edcdd8595a024aba85b6bb20d0e3fed4~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p>第六步，测试</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a265eea4de742a6bbdbbaa75f437307~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<h2 id="bean映射工具"><a href="#Bean映射工具" class="headerlink" title="Bean映射工具"></a>Bean映射工具</h2><p>用于将不同的两个对象实例进行属性复制，从而基于源对象的属性信息进行后续操作，而不改变源对象的属性信息。</p>
<p>这里边有涉及到了浅拷贝和深拷贝。如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行引用的传递，而没有真实的创建一个新的对象，则认为是<strong>浅拷贝</strong>。反之，在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是<strong>深拷贝</strong>。</p>
<h3 id="apache-的-beanutils"><a href="#Apache-的-BeanUtils" class="headerlink" title="Apache 的 BeanUtils"></a>Apache 的 BeanUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonSource</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">// getters/setters omiited</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">// getters/setters omiited</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApacheBeanUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">       <span class="comment">//下面只是用于单独测试</span></span><br><span class="line">        PersonSource personSource = <span class="keyword">new</span> PersonSource(<span class="number">1</span>, <span class="string">"pjmike"</span>, <span class="string">"12345"</span>, <span class="number">21</span>);</span><br><span class="line">        PersonDest personDest = <span class="keyword">new</span> PersonDest();</span><br><span class="line">        BeanUtils.copyProperties(personDest,personSource);</span><br><span class="line">        System.out.println(<span class="string">"persondest: "</span>+personDest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// persondest: PersonDest&#123;id=1, username='pjmike', age=21&#125;</span></span><br></pre></td></tr></table></figure>
<p>从上面的例子可以看出，对象拷贝非常简单，BeanUtils 最常用的方法就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将源对象中的值拷贝到目标对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyProperties</span><span class="params">(Object dest, Object orig)</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">    BeanUtilsBean.getInstance().copyProperties(dest, orig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，使用 <code>org.apache.commons.beanutils.BeanUtils</code> 对复杂对象的复制是引用，这是一种<strong>浅拷贝</strong>。并且由于对拷贝对象加了很多检验，造成了性能比较差，不推荐使用。</p>
<h3 id="spring-的-beanutils"><a href="#Spring-的-BeanUtils" class="headerlink" title="Spring 的 BeanUtils"></a>Spring 的 BeanUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpringBeanUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//下面只是用于单独测试</span></span><br><span class="line">        PersonSource personSource = <span class="keyword">new</span> PersonSource(<span class="number">1</span>, <span class="string">"pjmike"</span>, <span class="string">"12345"</span>, <span class="number">21</span>);</span><br><span class="line">        PersonDest personDest = <span class="keyword">new</span> PersonDest();</span><br><span class="line">        BeanUtils.copyProperties(personSource,personDest);</span><br><span class="line">        System.out.println(<span class="string">"persondest: "</span>+personDest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 下的 BeanUtils 也是使用 <code>copyProperties</code> 方法进行拷贝，只不过它的实现方式非常简单，就是对两个对象中相同名字的属性进行简单的 get/set，仅检查属性的可访问性。</p>
<p>成员变量赋值是基于目标对象的成员列表，并且会跳过 ignore 的以及在源对象中不存在，所以这个方法是安全的，不会因为两个对象之间的结构差异导致错误，但是<strong>必须保证同名的两个成员变量类型相同</strong>。</p>
<h2 id="spring-boot-定时任务"><a href="#Spring-Boot-定时任务" class="headerlink" title="Spring Boot  定时任务"></a>Spring Boot  定时任务</h2><p><a href="https://www.mmzsblog.cn/articles/2019/08/08/1565247960802.html" target="_blank" rel="noopener">玩转SpringBoot之定时任务详解 - Java学习之道 (mmzsblog.cn)</a></p>
<p>使用SpringBoot创建定时任务非常简单，目前主要有以下三种创建方式：</p>
<ol>
<li>基于注解(@Scheduled)</li>
<li>基于接口（SchedulingConfigurer） 前者相信大家都很熟悉，但是实际使用中我们往往想从数据库中读取指定时间来动态执行定时任务，这时候基于接口的定时任务就派上用场了。</li>
<li>基于注解设定多线程定时任务</li>
</ol>
<h3 id="静态基于注解"><a href="#静态：基于注解" class="headerlink" title="静态：基于注解"></a>静态：基于注解</h3><p>基于注解 @Scheduled 默认为单线程，开启多个任务时，任务的执行时机会受上一个任务执行时间的影响，可以理解为顺序执行。</p>
<h4 id="创建定时器"><a href="#创建定时器" class="headerlink" title="创建定时器"></a>创建定时器</h4><p>使用 Spring Boot 基于注解来创建定时任务非常简单，只需要几行代码便可完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Configuration</span>      <span class="comment">//1.主要用于标记配置类，兼备Component的效果。</span></span><br><span class="line"><span class="meta">@EnableScheduling</span>   <span class="comment">// 2.开启定时任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaticScheduleTask</span> </span>&#123;</span><br><span class="line">    <span class="comment">//3.添加定时任务</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0/5 * * * * ?"</span>)</span><br><span class="line">    <span class="comment">//或直接指定时间间隔，例如：5秒</span></span><br><span class="line">    <span class="comment">//@Scheduled(fixedRate=5000)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"执行静态定时任务时间: "</span> + LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cron 表达式的参数分别表示：</p>
<ul>
<li>秒（0~59） 例如0/5表示每5秒</li>
<li>分（0~59）</li>
<li>时（0~23）</li>
<li>日（0~31）的某天，需计算</li>
<li>月（0~11）</li>
<li>周几（ 可填1-7 或 SUN/MON/TUE/WED/THU/FRI/SAT）</li>
</ul>
<p>@Scheduled 注解的参数还支持简单的延时操作，例如 fixedDelay，fixedRate 填写相应的毫秒数即可。</p>
<blockquote>
<p>千万不能忘了添加 @EnableScheduling 注解，在启动类上添加【官网这么讲的】</p>
</blockquote>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>虽然使用很方便，但是当我们想要调整执行周期的时候，需要重启应用才能生效。所以为了达到实时生效的效果，可以使用接口来完成定时任务。</p>
<h3 id="动态基于接口-schedulingconfigurer"><a href="#动态：基于接口-SchedulingConfigurer" class="headerlink" title="动态：基于接口 SchedulingConfigurer"></a>动态：基于接口 SchedulingConfigurer</h3><p>需要创建数据库，指定 cron_id 和 cron 字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS `socks`;</span><br><span class="line">CREATE DATABASE `socks`;</span><br><span class="line">USE `SOCKS`;</span><br><span class="line">DROP TABLE IF EXISTS `cron`;</span><br><span class="line">CREATE TABLE `cron`  (</span><br><span class="line">  `cron_id` varchar(30) NOT NULL PRIMARY KEY,</span><br><span class="line">  `cron` varchar(30) NOT NULL  </span><br><span class="line">);</span><br><span class="line">INSERT INTO `cron` VALUES (&apos;1&apos;, &apos;0/5 * * * * ?&apos;);</span><br></pre></td></tr></table></figure>
<h4 id="创建定时器"><a href="#创建定时器-1" class="headerlink" title="创建定时器"></a>创建定时器</h4><p>数据库准备好后，编写定时任务。定义一个配置类，实现 SchedulingConfigurer 接口的 <code>configureTasks()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CronMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select cron from cron limit 1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCron</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Configuration</span>      <span class="comment">// 1.主要用于标记配置类，兼备Component的效果。</span></span><br><span class="line"><span class="meta">@EnableScheduling</span>   <span class="comment">// 2.开启定时任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicScheduleTask</span> <span class="keyword">implements</span> <span class="title">SchedulingConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>      <span class="comment">//注入mapper</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line">    CronMapper cronMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行定时任务.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 给它 runnable 任务和时间 trigger</span></span><br><span class="line">        taskRegistrar.addTriggerTask(</span><br><span class="line">                <span class="comment">//1.添加任务内容(Runnable)</span></span><br><span class="line">                () -&gt; System.out.println(<span class="string">"执行动态定时任务: "</span> + LocalDateTime.now().toLocalTime()),</span><br><span class="line">                <span class="comment">//2.设置执行周期(Trigger)</span></span><br><span class="line">                triggerContext -&gt; &#123;</span><br><span class="line">                    <span class="comment">//2.1 从数据库获取执行周期</span></span><br><span class="line">                    String cron = cronMapper.getCron();</span><br><span class="line">                    <span class="comment">//2.2 合法性校验.</span></span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isEmpty(cron)) &#123;</span><br><span class="line">                        <span class="comment">// Omitted Code ..</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//2.3 返回执行周期(Date)</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> CronTrigger(cron).nextExecutionTime(triggerContext);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修改执行周期"><a href="#修改执行周期" class="headerlink" title="修改执行周期"></a>修改执行周期</h4><p>通过修改数据库的数据，下一次定时任务执行时会自动的读取到我们最新的配置，然后设置好间隔时间。</p>
<p>如果在数据库修改时格式出现错误，则定时任务会停止，即使重新修改正确，此时只能重新启动项目才能恢复。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>基于注解设定多线程定时任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Component注解用于对那些比较中立的类进行注释；</span></span><br><span class="line"><span class="comment">//相对与在持久层、业务层和控制层分别采用 @Repository、@Service 和 @Controller 对分层中的类进行注释</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableScheduling</span>   <span class="comment">// 1.开启定时任务</span></span><br><span class="line"><span class="meta">@EnableAsync</span>        <span class="comment">// 2.开启多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultithreadScheduleTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span> <span class="comment">// 这个注解很重要</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedDelay = <span class="number">1000</span>)  <span class="comment">//间隔1秒</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"第一个定时任务开始 : "</span> + LocalDateTime.now().toLocalTime() + <span class="string">"\r\n线程 : "</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span> * <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedDelay = <span class="number">2000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"第二个定时任务开始 : "</span> + LocalDateTime.now().toLocalTime() + <span class="string">"\r\n线程 : "</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><h2 id="springbootapplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(HelloWorldApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@SpringBootApplication 注解是 Spring Boot 项目的基石，创建 Spring Boot 项目之后会默认在主类加上该注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span> <span class="comment">// 1</span></span><br><span class="line"><span class="meta">@ComponentScan</span> <span class="comment">// 2</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span> <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">//实际上它也是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Boot 的核心注解 @SpringBootApplication 可以被看作是 @Configuration、@EnableAutoConfiguration、@ComponentScan 注解的集合。这三个注解的作用分别是：</p>
<ul>
<li>@EnableAutoConfiguration：启用 Spring Boot 的自动配置机制</li>
<li>@Configuration：允许在上下文中通过注册额外的 bean 或导入其他配置类</li>
<li>@ComponentScan：扫描被 @Component（@Service、@Controller）注解的 bean，默认会扫描启动类所在包下的所有类。</li>
</ul>
<h2 id="spring-bean-相关"><a href="#Spring-Bean-相关" class="headerlink" title="Spring Bean 相关"></a>Spring Bean 相关</h2><h3 id="autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>自动导入对象到类中，被注入进来的对象同样要被 Spring 容器管理比如：Service 类注入到 Controller 类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserService userService;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="componentrepositoryservicecontroller"><a href="#Component-Repository-Service-Controller" class="headerlink" title="@Component,@Repository,@Service,@Controller"></a>@Component,@Repository,@Service,@Controller</h3><p>我们一般使用 @Autowired 注解让 Spring 容器帮我们自动装配 bean。想要把类标识成可用于 @Autowired 注解自动装配，可以采用以下注解实现：</p>
<ul>
<li>@Component：通用注解，可标注任意类为 Spring 组件。</li>
<li>@Repository：对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li>@Service：对应服务层，主要涉及一些复杂的逻辑操作，需要用到 Dao 层。</li>
<li>@Controller：对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h3 id="restcontroller"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><p>@RestController 注解是 @Controller 和 @ResponseBody 的合集，表示这是个控制器 bean ，并且会将函数的返回值直接填入 HTTP 响应体重，是 RESTful 风格的控制器。</p>
<p>单独使用 @Controller 一般用在要返回一个视图的情况，这种情况属于比较传统的 Spring MVC 的应用，对应于前后端不分离的情况。</p>
<p>@Controller + @ResponseBody 返回 JSON 或 XML 形式数据。</p>
<h3 id="scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><p>声明 Spring Bean 的作用于，使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"singleton"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">personSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p>一般用来声明配置类，可以使用 @component 注解替代，不过使用 @configuration 注解声明配置类更加语义化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理常见的-http-请求类型"><a href="#处理常见的-HTTP-请求类型" class="headerlink" title="处理常见的 HTTP 请求类型"></a>处理常见的 HTTP 请求类型</h2><p>4 种常见的请求类型：</p>
<ul>
<li>GET：请求从服务器获取特定资源。</li>
<li>POST：在服务器上创建一个新的资源。</li>
<li>PUT：更新服务器上的资源。</li>
<li>DELETE：从服务器删除特定的资源。</li>
</ul>
<h3 id="get请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><p><code>@GetMapping(&quot;/user&quot;)</code> 等价于 <code>@RequestMapping(value=&quot;/user&quot;, method=RequestMethod.GET)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;List&lt;User&gt;&gt; getAllUsers() &#123;</span><br><span class="line"> <span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="post请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><p><code>@PostMapping(&quot;/users&quot;)</code> 等价于 <code>@RequestMapping(value=&quot;/users&quot;, method=RequestMethod.POST)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title">createUser</span><span class="params">(@Valid @RequestBody UserCreateRequest userCreateRequest)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> userRespository.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="put请求"><a href="#PUT请求" class="headerlink" title="PUT请求"></a>PUT请求</h3><p><code>@PutMapping(&quot;/users/{userId}&quot;)</code> 等价于 <code>@RequestMapping(value=&quot;/users/{userId}&quot;, method=RequestMethod.PUT)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping</span>(<span class="string">"/users/&#123;userId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title">updateUser</span><span class="params">(@PathVariable(value = <span class="string">"userId"</span>)</span> Long userId,</span></span><br><span class="line"><span class="function">  @Valid @RequestBody UserUpdateRequest userUpdateRequest) </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="delete请求"><a href="#DELETE请求" class="headerlink" title="DELETE请求"></a>DELETE请求</h3><p><code>@DeleteMapping(&quot;/users/{userId}&quot;)</code> 等价于 <code>@RequestMapping(value=&quot;/users/{userId}&quot;, method=RequestMethod.DELETE)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping</span>(<span class="string">"/users/&#123;userId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">deleteUser</span><span class="params">(@PathVariable(value = <span class="string">"userId"</span>)</span> Long userId)</span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前后端传值"><a href="#前后端传值" class="headerlink" title="前后端传值"></a>前后端传值</h2><h3 id="pathvariable和requestparam"><a href="#PathVariable和-RequestParam" class="headerlink" title="@PathVariable和@RequestParam"></a>@PathVariable和@RequestParam</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/klasses/&#123;klassId&#125;/teachers"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Teacher&gt; <span class="title">getKlassRelatedTeachers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         @PathVariable(<span class="string">"klassId"</span>)</span> Long klassId,</span></span><br><span class="line"><span class="function">         @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"type"</span>, required = <span class="keyword">false</span>)</span> String type ) </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们请求的 url 是：<code>/klasses/{123456}/teachers?type=web</code></p>
<p>那么我们服务获取到的数据就是：<code>klassId=123456,type=web</code>。</p>
<h3 id="requestbody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>用于读取 Request 请求的 body 部分，并且 ContentType 为 <code>application/json</code> 格式的数据，接收到数据之后自动将数据绑定到 java 对象上。</p>
<p>演示：</p>
<p>注册一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/sign-up"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">signUp</span><span class="params">(@RequestBody @Valid UserRegisterRequest userRegisterRequest)</span> </span>&#123;</span><br><span class="line">  userService.save(userRegisterRequest);</span><br><span class="line">  <span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UserRegisterRequest 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRegisterRequest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送 post 请求到这个接口，并且 body 携带 JSON 数据：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"userName"</span>:<span class="string">"coder"</span>,<span class="attr">"fullName"</span>:<span class="string">"shuangkou"</span>,<span class="attr">"password"</span>:<span class="string">"123456"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们的后端就可以直接把 json 格式的数据映射到 UserRegisterRequest 类上。</p>
<blockquote>
<p>需要注意的是：<strong>一个请求方法只可以有一个 @RequestBody，但是可以有多个 @RequestParam和  @PathVariable</strong>。 如果你的方法必须要用两个  @RequestBody 来接受数据的话，大概率是你的数据库设计或者系统设计出问题了！</p>
</blockquote>
<h2 id="读取配置信息"><a href="#读取配置信息" class="headerlink" title="读取配置信息"></a>读取配置信息</h2><p>很多时候我们需要将一些常用的配置信息放到配置文件中。Spring 提供了一些方法可以读取这些配置文件。</p>
<h3 id="通过-value-注解读取"><a href="#通过-Value-注解读取-1" class="headerlink" title="通过 @Value 注解读取"></a>通过 @Value 注解读取</h3><p>格式 <code>@Value(&quot;${property}&quot;)</code> 读取比较简单的配置信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;username&#125;"</span>)</span><br><span class="line">String username;</span><br></pre></td></tr></table></figure>
<h3 id="通过-configurationproperties-读取"><a href="#通过-ConfigurationProperties-读取-1" class="headerlink" title="通过 @ConfigurationProperties 读取"></a>通过 @ConfigurationProperties 读取</h3><ol>
<li><p>使用 @ConfigurationProperties 和 @Component 注解到 bean 定义类上，这里 @Component 代指同一类实例化 Bean 的注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将类定义为一个bean的注解，比如 @Component,@Service,@Controller,@Repository</span></span><br><span class="line"><span class="comment">// 或者 @Configuration</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 表示使用配置文件中前缀为user的属性的值初始化该bean定义产生的的bean实例的同名属性</span></span><br><span class="line"><span class="comment">// 在使用时这个定义产生的bean时，其属性name会是Tom</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="comment">// 省略getter/setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应application.properties配置文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.name=Tom</span><br><span class="line">user.age=11</span><br></pre></td></tr></table></figure>
<p>在此种场景下，当 Bean 被实例化时，@ConfigurationProperties 会将对应前缀的后面的属性与 Bean 对象的属性匹配。符合条件则进行赋值。</p>
</li>
<li><p>使用 @ConfigurationProperties 和 @Bean 注解在配置类的Bean定义方法上。以数据源配置为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Primary</span></span><br><span class="line">	<span class="meta">@Bean</span>(name = <span class="string">"primaryDataSource"</span>)</span><br><span class="line">	<span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"spring.datasource.primary"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> DataSource <span class="title">primaryDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里便是将前缀为“spring.datasource.primary”的属性，赋值给 DataSource 对应的属性值。</p>
<p>@Configuration 注解的配置类中通过 @Bean 注解在某个方法上将方法返回的对象定义为一个 Bean，并使用配置文件中相应的属性初始化该 Bean 的属性。</p>
</li>
<li><p>使用 @ConfigurationProperties 注解到普通类，然后再通过 @EnableConfigurationProperties 定义为 Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"user1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="comment">// 省略getter/setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 User 对象并没有使用 @Component 相关注解。而该 User 类对应的使用形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;User.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，通过 @EnableConfigurationProperties 对 User 进行实例化时，便会使用到 @ConfigurationProperties 的功能，对属性进行匹配赋值。</p>
</li>
</ol>
<h2 id="全局处理controller层异常"><a href="#全局处理Controller层异常" class="headerlink" title="全局处理Controller层异常"></a>全局处理Controller层异常</h2><ul>
<li>@ControllerAdvice：注解定义全局异常处理类，可以添加 assignableTypes 参数指定只处理特定 Controoler 类的异常。</li>
<li>@ExceptionHandler：注解声明异常处理方法，value 可以指定要处理的是哪一类异常。</li>
</ul>
<h2 id="json-数据处理"><a href="#JSON-数据处理" class="headerlink" title="JSON 数据处理"></a>JSON 数据处理</h2><h3 id="过滤json数据"><a href="#过滤JSON数据" class="headerlink" title="过滤JSON数据"></a>过滤JSON数据</h3><p>@JsonIgnoreProperties 作用在类上用于过滤掉特定字段不返回或者不解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成json时将userRoles属性过滤</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties</span>(&#123;<span class="string">"userRoles"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UserRole&gt; userRoles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@JsonIgnore 一般用于类的属性上，作用和上面的 @JsonIgnoreProperties 一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">   <span class="comment">//生成json时将userRoles属性过滤</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UserRole&gt; userRoles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="格式化-json-数据"><a href="#格式化-JSON-数据" class="headerlink" title="格式化 JSON 数据"></a>格式化 JSON 数据</h3><p>@JsonFormat 一般用来格式化 JSON 数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat</span>(shape=JsonFormat.Shape.STRING, pattern=<span class="string">"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"</span>, timezone=<span class="string">"GMT"</span>)</span><br><span class="line"><span class="keyword">private</span> Date date;</span><br></pre></td></tr></table></figure>
<h3 id="扁平化对象"><a href="#扁平化对象" class="headerlink" title="扁平化对象"></a>扁平化对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JsonUnwrapped</span></span><br><span class="line">    <span class="keyword">private</span> Location location;</span><br><span class="line">    <span class="meta">@JsonUnwrapped</span></span><br><span class="line">    <span class="keyword">private</span> PersonInfo personInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="meta">@ToString</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Location</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String provinceName;</span><br><span class="line">        <span class="keyword">private</span> String countyName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="meta">@ToString</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonInfo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String userName;</span><br><span class="line">        <span class="keyword">private</span> String fullName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未扁平化之前：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"location"</span>: &#123;</span><br><span class="line">        <span class="attr">"provinceName"</span>:<span class="string">"湖北"</span>,</span><br><span class="line">        <span class="attr">"countyName"</span>:<span class="string">"武汉"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"personInfo"</span>: &#123;</span><br><span class="line">        <span class="attr">"userName"</span>: <span class="string">"coder1234"</span>,</span><br><span class="line">        <span class="attr">"fullName"</span>: <span class="string">"shaungkou"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 @JsonUnwrapped 扁平对象之后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JsonUnwrapped</span></span><br><span class="line">    <span class="keyword">private</span> Location location;</span><br><span class="line">    <span class="meta">@JsonUnwrapped</span></span><br><span class="line">    <span class="keyword">private</span> PersonInfo personInfo;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"provinceName"</span>:<span class="string">"湖北"</span>,</span><br><span class="line">  <span class="attr">"countyName"</span>:<span class="string">"武汉"</span>,</span><br><span class="line">  <span class="attr">"userName"</span>: <span class="string">"coder1234"</span>,</span><br><span class="line">  <span class="attr">"fullName"</span>: <span class="string">"shaungkou"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试相关"><a href="#测试相关" class="headerlink" title="测试相关"></a>测试相关</h2><p>@Test 声明一个方法为测试方法。</p>
<p>@Transactional 被声明的测试方法的数据会回滚，避免污染测试数据。</p>
<p> @WithMockUser 由Spring Security 提供的，用来模拟一个真实用户，并且可以赋予权限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@WithMockUser</span>(username = <span class="string">"user-id-18163138155"</span>, authorities = <span class="string">"ROLE_TEACHER"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">should_import_student_success</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@ActiveProfiles 一般作用于测试类上，用于声明生效的 Spring 配置文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span>(webEnvironment = RANDOM_PORT)</span><br><span class="line"><span class="meta">@ActiveProfiles</span>(<span class="string">"test"</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBase</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="autowired-可以加载构造方法上吗"><a href="#Autowired-可以加载构造方法上吗" class="headerlink" title="@Autowired 可以加载构造方法上吗"></a>@Autowired 可以加载构造方法上吗</h2><p>@Autowired 可以对成员变量、方法以及构造函数进行注释。</p>
<p>作用在成员变量上，相当于在配置文件中配置 bean，并且使用 setter 注入。作用在成员变量上要等到类完全加载完，才会将相应的 bean 注入。</p>
<p>作用在普通方法上，会在注入的时候调用一次该方法，如果方法中有实体参数，会对参数进行装配，可以用来在自动注入的时候做一些初始化操作。</p>
<p>作用在构造函数上可以解决如下问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"><span class="keyword">private</span> String school;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserAccountServiceImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.school = user.getSchool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码不能运行成功，因为作用在成员变量上要等到类完全加载完，才会将相应的 bean 注入。这里会限制性构造方法，然后再给注解了 @Autowired 的 user 注入值，所以在执行构造方法的时候，会报错。</p>
<blockquote>
<p>Java变量的初始化顺序为：静态变量或静态语句块–&gt;实例变量或初始化语句块–&gt;构造方法–&gt;@Autowired</p>
</blockquote>
<p>解决方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> User user; <span class="comment">// final 去确保单例</span></span><br><span class="line"><span class="keyword">private</span> String school;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserAccountServiceImpl</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.user = user;</span><br><span class="line">    <span class="keyword">this</span>.school = user.getSchool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="spring事务"><a href="#Spring事务-1" class="headerlink" title="Spring事务"></a>Spring事务</h1><h2 id="事务的特性acid"><a href="#事务的特性ACID" class="headerlink" title="事务的特性ACID"></a>事务的特性ACID</h2><p>原子性 Atomicity：一个事务中的所有操作，要么全部完成，要么全部不完成。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
<p>一致性 Consistency：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。举个例子说 A 向 B 转了 100 块钱，B 的账户里应该多 100，如果 A 的账户没有减 100，那么就是不一致的。</p>
<p>隔离性 Isolation：数据库允许多个并发事务同时对其数据进行读写和修改，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务的隔离级别分为：未提交读（Read Uncommitted）、提交读（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。</p>
<p>持久性 Durability：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
<h2 id="spring对事务的支持"><a href="#Spring对事务的支持" class="headerlink" title="Spring对事务的支持"></a>Spring对事务的支持</h2><p>是否支持事务取决于数据库，比如使用 MySQL 的话，需要选择 innodb 引擎才可以支持事务。</p>
<h3 id="如何实现回滚"><a href="#如何实现回滚？" class="headerlink" title="如何实现回滚？"></a><strong>如何实现回滚？</strong></h3><p>在 MySQL 中，恢复机制是通过<strong>回滚日志（undo log）</strong>来实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。</p>
<p>如果执行过程中遇到异常，直接利用回滚日志中的信息将数据回滚到修改之前的样子即可。并且由于回滚日志会先于数据持久化到磁盘上，这就保证了即使遇到数据库突然宕机，当用户再次启动数据库时，数据库还能够通过查询回滚日志来完成之前没有完成的事务。</p>
<h3 id="spring支持两种方式的事务"><a href="#Spring支持两种方式的事务" class="headerlink" title="Spring支持两种方式的事务"></a>Spring支持两种方式的事务</h3><p><strong>1）编程式事务管理</strong></p>
<p>通过 TransactionTemplate 或者 TransactionManager 手动管理事务，实际应用中用的比较少。</p>
<p>TransactionTemplate：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        transactionTemplate.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// ....  业务代码</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="comment">//回滚</span></span><br><span class="line">                    transactionStatus.setRollbackOnly();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransactionManager：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	TransactionStatus status = transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ....  业务代码</span></span><br><span class="line">        transactionManager.commit(status);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        transactionManager.rollback(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2）声明式事务管理</strong></p>
<p>推荐使用，因为其代码侵入性最小，实际是通过 AOP 实现。</p>
<p>使用 @Transactional 注解进行事务管理的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation=propagation.PROPAGATION_REQUIRED)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">  B b = <span class="keyword">new</span> B();</span><br><span class="line">  C c = <span class="keyword">new</span> C();</span><br><span class="line">  b.bMethod();</span><br><span class="line">  c.cMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spring事务管理接口"><a href="#Spring事务管理接口" class="headerlink" title="Spring事务管理接口"></a>Spring事务管理接口</h3><p>Spring 框架中，事务管理相关最重要的 3 个接口如下：</p>
<ul>
<li>PlatformTransactionManager：（平台）事务管理器，Spring 事务策略的核心。</li>
<li>TransactionDefinition：事务定义信息（事务隔离级别、传播行为、超时、只读、回滚规则）。</li>
<li>TransactionStatus：事务运行状态。</li>
</ul>
<p>PlatformTransactionManager 会根据 TransactionDefinition 的定义（比如事务超时时间、隔离级别、传播行为等）来进行事务管理，而 TransactionStatus 接口则提供了一些方法来获取事务相应的状态（比如是否新事务、是否可以回滚等等）。</p>
<h4 id="platformtransactionmanager事务管理接口"><a href="#PlatformTransactionManager：事务管理接口" class="headerlink" title="PlatformTransactionManager：事务管理接口"></a>PlatformTransactionManager：事务管理接口</h4><p>Spring 并不直接管理事务，而是提供了多种事务管理器。Spring 事务管理器的接口是 PlatformTransactionManager。</p>
<p>通过这个接口，Spring 为各个平台如 JDBC（DataSourceTransactionManager）、Hibernate（HibernateTransactionManager）等都提供了对应的事务管理器，但是具体的实现是各个平台自己的事情了。</p>
<p>该接口定义了三个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得事务</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="transactiondefinition事务属性"><a href="#TransactionDefinition：事务属性" class="headerlink" title="TransactionDefinition：事务属性"></a>TransactionDefinition：事务属性</h4><p>事务管理器 PlatformTransactionManager 通过<code>getTransaction(TransactionDefinition definition)</code> 方法来得到一个事务，TransactionDefinition 类就是用来定义一些基本的事务属性。</p>
<p>事务属性包括 5 种：隔离级别、传播行为、回滚原则、是否只读、事务超时。</p>
<h4 id="transactionstatus事务状态"><a href="#TransactionStatus：事务状态" class="headerlink" title="TransactionStatus：事务状态"></a>TransactionStatus：事务状态</h4><p>TransactionStatus 接口用来记录事务的状态，该接口定义了一组方法用于获取或判断事务的相应状态信息。</p>
<p><code>PlatformTransactionManager.getTransaction(...)</code> 方法返回一个 TransactionStatus 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>; <span class="comment">// 是否是新的事务</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="keyword">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事务属性详解"><a href="#事务属性详解" class="headerlink" title="事务属性详解"></a>事务属性详解</h3><h4 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h4><p>事务传播行为是用来解决业务层之间相互调用的事务问题。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
<p>Spring 支持 7 种事务传播行为，确定客户端和被调用端的事务边界。（通俗讲就是多个具有事务控制的 service 相互调用时所形成的复杂的事务边界控制）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>传播行为</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>PROPAGATION_REQUIRED（XML文件中为REQUIRED)</td>
<td>表示当前方法必须在一个具有事务的上下文中运行，如有客户端有事务在进行，那么被调用端将在该事务中运行，否则的话重新开启一个事务。（如果被调用端发生异常，那么调用端和被调用端事务都将回滚）【默认】</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS(XML文件中为SUPPORTS）</td>
<td>表示当前方法不必需要具有一个事务上下文，但是如果有一个事务的话，它也可以在这个事务中运行</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY(XML文件中为MANDATORY）</td>
<td>表示当前方法必须在一个事务中运行，如果没有事务，将抛出异常</td>
</tr>
<tr>
<td>PROPAGATION_NESTED(XML文件中为NESTED)</td>
<td>表示如果当前方法正有一个事务在运行中，则该方法应该运行在一个嵌套事务中，被嵌套的事务可以独立于被封装的事务中进行提交或者回滚。如果封装事务存在，并且外层事务抛出异常回滚，那么内层事务必须回滚，反之，内层事务并不影响外层事务。如果封装事务不存在，则同PROPAGATION_REQUIRED的一样</td>
</tr>
<tr>
<td>PROPAGATION_NEVER（XML文件中为NEVER)</td>
<td>表示当方法务不应该在一个事务中运行，如果存在一个事务，则抛出异常</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW(XML文件中为REQUIRES_NEW）</td>
<td>表示当前方法必须运行在它自己的事务中。一个新的事务将启动，而且如果有一个现有的事务在运行的话，则这个方法将在运行期被挂起，直到新的事务提交或者回滚才恢复执行。</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED（XML文件中为NOT_SUPPORTED）</td>
<td>表示该方法不应该在一个事务中运行。如果有一个事务正在运行，他将在运行期被挂起，直到这个事务提交或者回滚才恢复执行</td>
</tr>
</tbody>
</table>
</div>
<p><a href="https://blog.csdn.net/lldouble/article/details/80789098" target="_blank" rel="noopener">spring 事务传播行为实例分析_lldouble的博客-CSDN博客</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486668&amp;idx=2&amp;sn=0381e8c836442f46bdc5367170234abb&amp;chksm=cea24307f9d5ca11c96943b3ccfa1fc70dc97dd87d9c540388581f8fe6d805ff548dff5f6b5b&amp;token=1776990505&amp;lang=zh_CN#rd" target="_blank" rel="noopener">太难了~面试官让我结合案例讲讲自己对Spring事务传播行为的理解。 (qq.com)</a></p>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>ISOLATION_DEFAULT</td>
<td>使用后端数据库默认的隔离级别，MySQL 默认采用 REPEATABLE_READ 级别。</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td>最低的隔离级别，允许读取尚未提交的数据，可能会导致<strong>脏读</strong>、<strong>不可重复读</strong>或<strong>幻读</strong></td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>允许读已经提交的数据，可以阻止脏读，但是仍然可能发生<strong>不可重复读和幻读</strong></td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己修改。可以阻止脏读和不可重复读，但仍有可能发生<strong>幻读</strong></td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行。</td>
</tr>
</tbody>
</table>
</div>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong></p>
<p>幻读：关于幻读，可重复读的真实用例是什么？ - 知乎用户的回答 - 知乎<br><a href="https://www.zhihu.com/question/47007926/answer/222348887" target="_blank" rel="noopener">https://www.zhihu.com/question/47007926/answer/222348887</a></p>
<h4 id="事务超时属性"><a href="#事务超时属性" class="headerlink" title="事务超时属性"></a>事务超时属性</h4><p>事务超时，指一个事务所允许执行的最长时间，如果超过了该时间限制还没有完成，则自动回滚事务。</p>
<p>在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒，默认值为 -1。</p>
<h4 id="事务只读属性"><a href="#事务只读属性" class="headerlink" title="事务只读属性"></a>事务只读属性</h4><p>对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务。只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中。</p>
<h4 id="事务回滚规则"><a href="#事务回滚规则" class="headerlink" title="事务回滚规则"></a>事务回滚规则</h4><p>回滚规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下只有遇到运行时异常（RuntimeException）时才会回滚，Error 也会导致事务回滚。遇到检查（Checked）异常时不会回滚。</p>
<p>通过 rollbackFor 可以指定回滚特定的异常类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor= MyException.class)</span><br></pre></td></tr></table></figure>
<h2 id="transactional-注解使用详解"><a href="#Transactional-注解使用详解" class="headerlink" title="@Transactional 注解使用详解"></a>@Transactional 注解使用详解</h2><h4 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h4><ul>
<li>方法上：只能加到 public 方法上，否则不生效</li>
<li>类：加到类上表明对该类中所有的 public 方法都生效</li>
<li>接口：不推荐</li>
</ul>
<h4 id="常用配置参数"><a href="#常用配置参数" class="headerlink" title="常用配置参数"></a>常用配置参数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>propagation</td>
<td>事务的传播行为，默认值为 REQUIRED</td>
</tr>
<tr>
<td>isolation</td>
<td>事务的隔离级别，默认值为 DEFAULT，使用后端数据库默认的隔离级别</td>
</tr>
<tr>
<td>timeout</td>
<td>事务的超时时间，默认值为 -1（不会超时）。超过该时间但事务还未完成，自动回滚事务。</td>
</tr>
<tr>
<td>readOnly</td>
<td>指定事务是否为只读事务，默认为 false</td>
</tr>
<tr>
<td>rollbackFor</td>
<td>用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型</td>
</tr>
</tbody>
</table>
</div>
<h4 id="transacntional-事务注解原理"><a href="#Transacntional-事务注解原理" class="headerlink" title="@Transacntional 事务注解原理"></a>@Transacntional 事务注解原理</h4><p>@Transacntional 注解的工作机制是基于 AOP 实现的，AOP 是利用动态代理实现。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现接口，会使用 CGLIB 动态代理。</p>
<p>如果一个类或者一个类的 public 方法上被标注有 @Transacntional 注解，Spring 容器就会在启动的时候为其创建一个代理类，在调用被 @Transacntional 注解的 public 方法时，会现在目标方法之前开启事务，方法执行过程中如果遇到异常会回滚事务，方法调用完之后提交事务，这些都是通过 AOP 实现的。</p>
<h4 id="spring-aop-自调用问题"><a href="#Spring-AOP-自调用问题" class="headerlink" title="Spring AOP 自调用问题"></a>Spring AOP 自调用问题</h4><p>若同一类中的其他没有 @Transacntional 注解的方法内部调用有 @Transacntional 注解的方法，有 @Transacntional 注解的方法的事务会失效。</p>
<p>这是由于 Spring AOP 代理的原因造成的，因为只有当 @Transacntional 注解的方法在类以外被调用的时候，Spring 事务管理才生效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"><span class="comment">// method1() 调用 method2() 会导致 method2() 的事务失效</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     method2();</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决办法就是避免同一类中自调用或者使用 AspectJ 取代 Spring AOP 代理。</p>
<h4 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h4><ol>
<li>@Transactional 注解只有作用到 public 方法上事务才生效，不推荐在接口上使用；</li>
<li>避免同一个类中调用 @Transactional 注解的方法，这样会导致事务失效；</li>
<li>正确的设置 @Transactional 的 rollbackFor 和 propagation 属性，否则事务可能会回滚失败</li>
</ol>
<h1 id="spring框架中用了哪些设计模式"><a href="#Spring框架中用了哪些设计模式" class="headerlink" title="Spring框架中用了哪些设计模式"></a>Spring框架中用了哪些设计模式</h1><ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 jdbcTemplate、hibernateTemplate`等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485303&amp;idx=1&amp;sn=9e4626a1e3f001f9b0d84a6fa0cff04a&amp;chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&amp;token=255050878&amp;lang=zh_CN#rd" target="_blank" rel="noopener">面试官:“谈谈Spring中都用到了那些设计模式?”。 (qq.com)</a></p>
<h1 id="mybatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="和的区别是什么"><a href="#和-的区别是什么" class="headerlink" title="#{}和${}的区别是什么"></a>#{}和${}的区别是什么</h2><ul>
<li><code>${}</code> 是 properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如 <code>${driver}</code> 会被静态替换为 <code>com.mysql.jdbc.Driver</code>。</li>
<li><code>#{}</code> 是 sql 的参数占位符，MyBatis 会将 sql 中的 <code>#{}</code> 替换为 <code>?</code> 号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的 <code>?</code> 号占位符设置参数值，比如 <code>ps.setInt(0, parameterValue)</code>，<code>${item.name}</code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 <code>param.getItem().getName()</code>。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">ID</span>，COMMAND <span class="keyword">from</span> Message <span class="keyword">where</span> COMMAND=#&#123;command&#125;</span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">ID</span>，COMMAND <span class="keyword">from</span> Message <span class="keyword">where</span> COMMAND=‘$&#123;command&#125;’</span><br></pre></td></tr></table></figure>
<p>前者解析为：</p>
<p>​            <code>Select ID，COMMAND from Message where COMMAND=？</code>具有预编译效果</p>
<p>后者解析为：</p>
<p>​            <code>Select ID，COMMAND from Message where COMMAND=段子</code>   不具有预编译效果</p>
<h2 id="xml-映射文件中除了常见的selectinsertupdatedelete标签之外还有哪些标签"><a href="#XML-映射文件中，除了常见的select-insert-update-delete标签之外，还有哪些标签" class="headerlink" title="XML 映射文件中，除了常见的select|insert|update|delete标签之外，还有哪些标签"></a>XML 映射文件中，除了常见的select|insert|update|delete标签之外，还有哪些标签</h2><p>还有 <code>&lt;resultMap&gt;</code>（将查询结果映射到一个结果集）、<code>&lt;where&gt;</code>（where 条件）、<code>&lt;if&gt;</code>（if 判断）、<code>&lt;foreach&gt;</code>（循环）、<code>&lt;sql&gt;</code>（sql片段抽取，达到重用的目的，使用 <code>&lt;inlcude&gt;</code>）</p>
<h2 id="通常一个-xml-映射文件都会写一个-dao-接口与之对应这个-dao-接口的工作原理是什么"><a href="#通常一个-XML-映射文件都会写一个-Dao-接口与之对应，这个-Dao-接口的工作原理是什么？" class="headerlink" title="通常一个 XML 映射文件都会写一个 Dao 接口与之对应，这个 Dao 接口的工作原理是什么？"></a>通常一个 XML 映射文件都会写一个 Dao 接口与之对应，这个 Dao 接口的工作原理是什么？</h2><p>Dao 接口，就是熟悉的 Mapper 接口。接口的全限定名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中的 MappedStatement（对应一个 select|insert|update|delete 节点） 的 id 值，接口方法内的参数，就是传递给 sql 的参数。</p>
<p>Mapper 接口是没有实现类的，当调用接口方法时，接口全限定名+方法名拼接的字符串作为 key 值，可以唯一定位一个 MappedStatement。在 MyBatis 中，每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，都会被解析为一个 MappedStatement 对象。</p>
<h2 id="dao-接口里的方法参数不同时方法能重载吗"><a href="#Dao-接口里的方法，参数不同时方法能重载吗？" class="headerlink" title="Dao 接口里的方法，参数不同时方法能重载吗？"></a>Dao 接口里的方法，参数不同时方法能重载吗？</h2><p>Dao 接口方法可以重载，但是需要满足以下条件：</p>
<ol>
<li>仅有一个无参方法和一个有参方法。</li>
<li>多个有参方法时，参数数量必须一致。且使用相同的 @Param 注解。</li>
</ol>
<p>Dao 接口里的方法可以重载，但是 Mybatis 的 XML 里面的 id 不允许重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mapper接口里面方法重载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StuMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">getAllStu</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">getAllStu</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 <code>StuMapper.xml</code> 中利用 Mybatis 的动态 sql 就可以实现。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAllStu"</span> <span class="attr">resultType</span>=<span class="string">"com.pojo.Student"</span>&gt;</span></span><br><span class="line">    select * from student</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id != null"</span>&gt;</span></span><br><span class="line">            id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="mybatis-是如何进行分页的分页插件的原理是什么"><a href="#MyBatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="MyBatis 是如何进行分页的？分页插件的原理是什么？"></a>MyBatis 是如何进行分页的？分页插件的原理是什么？</h2><p>通常我们进行分页，都是传递参数给 sql 语句，使用 limit 来进行分页查询的。（<strong>物理分页</strong>，在 sql 中指定 limit 和 offset 值）</p>
<p>MyBatis 提供了内置的专门处理分页的 RowBounds 类。（<strong>逻辑分页</strong>会将所有的结果都查询到，然后根据 RowBounds 中提供的 offset 和 limit 值来获取最后的结果）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.session;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RowBounds</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NO_ROW_OFFSET = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NO_ROW_LIMIT = Integer.MAX_VALUE;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RowBounds DEFAULT = <span class="keyword">new</span> RowBounds();</span><br><span class="line">  <span class="comment">// 偏移量，即从第几行开始读取，起始位是0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">  <span class="comment">// 限制条数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RowBounds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.offset = NO_ROW_OFFSET;</span><br><span class="line">    <span class="keyword">this</span>.limit = NO_ROW_LIMIT;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RowBounds</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    <span class="keyword">this</span>.limit = limit;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> limit;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该类使用起来极为方便，先给接口增加一个 RowBounds 参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Student&gt; <span class="title">findStudentByRowBounds</span><span class="params">(@Param(<span class="string">"name"</span>)</span> String name, RowBounds rowBounds)</span>;</span><br></pre></td></tr></table></figure>
<p>然后配置普通的 SQL</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findStudentByRowBounds"</span> <span class="attr">resultMap</span>=<span class="string">"studentMapper"</span>&gt;</span></span><br><span class="line">    SELECT * FROM studuent WHERE name LIKE CONCAT('%', #&#123;name&#125;, '%')</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>MyBatis 会自动识别 RowBounds，并根据你传递的 RowBounds 参数进行分页。</p>
<p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<h2 id="mybatis-执行插入操作后返回数据库主键"><a href="#MyBatis-执行插入操作后，返回数据库主键" class="headerlink" title="MyBatis 执行插入操作后，返回数据库主键"></a>MyBatis 执行插入操作后，返回数据库主键</h2><p>在定义 XML 映射器时设置属性 useGeneratedKeys 值为 true，并分别指定属性 keyProperty 和 keyColumn 为对应的数据库记录主键字段与 Java 对象的主键属性。</p>
<h2 id="mybatis-动态-sql"><a href="#MyBatis-动态-sql" class="headerlink" title="MyBatis 动态 sql"></a>MyBatis 动态 sql</h2><p>MyBatis 动态 sql 可以让我们在 XML 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，MyBatis 提供了 9 种动态 sql 标签 <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>。</p>
<p>trim 标签：我的理解是它是一个格式化标记，通过 prefix 设置前缀xxx，suffix 设置后缀xxx，prefixoverride 去除第一个前缀xxx，suffixOverrides 去除最后一个后缀xxx，xxx表示属性引号中的值。</p>
<p><a href="https://www.pianshen.com/article/12411707055/" target="_blank" rel="noopener">动态sql标签trim的用法 - 程序员大本营 (pianshen.com)</a></p>
<p><a href="https://www.cnblogs.com/qiankun-site/p/5758924.html" target="_blank" rel="noopener">mybatis动态sql中的trim标签的使用 - 西风恶 - 博客园 (cnblogs.com)</a></p>
<p>其执行原理为，从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p>
<h2 id="mybatis-是如何将-sql-执行结果封装为目标对象并返回的都有哪些映射形式"><a href="#MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h2><p>第一种：使用 <code>&lt;resultMap&gt;</code> 标签，逐一定义列名和对象属性名之间的映射关系。第二种：使用 sql 列的别名功能，将列别名书写为对象属性名。</p>
<p>有了列名与属性名的映射关系后，MyBatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h1 id="servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>Servlet 是用 Java 编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。侠义的 Servlet 是指 Java 语言实现的一个接口，广义的 Servlet 是指实现了这个 Servlet 接口的类，一般情况下人们将 Servlet 理解为后者。</p>
<h2 id="tomcat-和-servlet-的关系-amp-工作流程"><a href="#Tomcat-和-Servlet-的关系-amp-工作流程" class="headerlink" title="Tomcat 和 Servlet 的关系 &amp; 工作流程"></a>Tomcat 和 Servlet 的关系 &amp; 工作流程</h2><p>Tomcat 是 Web 应用服务器，是一个 Servlet/JSP 容器。Tomcat 作为 Servlet 容器，负责处理客户请求，把请求传递给 Servlet，并将 Servlet 的响应传递回给客户。Servlet 是一种运行在支持 Java 语言的服务器上的组件，用于交互式地浏览和修改数据，生成动态 Web 内容。</p>
<p>从 HTTP 协议中的请求和响应可以得知，浏览器发出的请求是一个请求文本，浏览器接收到的是一个响应文本。</p>
<p><img src="https://images2015.cnblogs.com/blog/874710/201702/874710-20170214204632894-1786729693.png" alt=""></p>
<ol>
<li>Tomcat 将 HTTP 请求文本接收并解析，然后封装成 HttpServletRequest 类型的 request 对象，所有的 HTTP 头数据都可以通过 request 对象调用对应的方法查询到。</li>
<li>Tomcat 同时会把要响应的信息封装到为 HttpServletResponse 类型的 response 对象，通过设置 response 属性就可以控制要输出到浏览器的内容，然后将 response 交给 Tomcat，Tomcat 就会将其变成响应文本的格式发送给浏览器。</li>
</ol>
<h2 id="servlet-工作原理"><a href="#Servlet-工作原理" class="headerlink" title="Servlet 工作原理"></a>Servlet 工作原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line">    <span class="function">ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;   <span class="comment">// 这个方法会返回由Servlet容器传给init()方法的ServletConfig对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line">    <span class="function">String <span class="title">getServletInfo</span><span class="params">()</span></span>;    <span class="comment">// 这个方法会返回Servlet的一段描述，可以返回一段字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Servlet 接口定义了 Servlet 与 Servlet 容器之间的契约。</p>
<p>Serlvet 容器将 Servlet 类载入内存，并产生 Servlet 实例【单例】。用户请求时，Serlvet 容器调用对应 Servlet 的 <code>service()</code> 方法，并传入一个 ServletRequest 对象和一个 ServletResponse 对象。</p>
<p>ServletRequest 对象和一个 ServletResponse 对象都是由 Servlet 容器（例如 Tomcat）封装好的，不需要程序员去实现，可以直接使用它们。ServletRequest 中封装了当前的 HTTP 请求，所以开发人员不必解析和操作原始的 HTTP 数据。ServletResponse 表示当前用户的 HTTP 响应，程序员只需要直接操作 ServletResponse 对象就能把响应轻松的发回给用户。</p>
<p>对于每一个应用程序，Servlet 容器还会创建一个 ServletContext 对象。这个对象中封装了上下文（应用程序）的环境详情【每个应用程序只有一个 ServletContext】。每个 Servlet 对象也都有一个封装 Servlet 配置的 ServletConfig 对象。</p>
<h2 id="servlet-的生命周期"><a href="#Servlet-的生命周期" class="headerlink" title="Servlet 的生命周期"></a>Servlet 的生命周期</h2><p>在 Servlet 接口的定义中，<code>init()</code>，<code>service()</code>，<code>destroy()</code> 是定义 Servlet 生命周期的方法。代表了 Servlet 从“出生”到“工作”再到“死亡”的过程。Servlet 容器（例如 TomCat）会根据下面的规则来调用这三个方法：</p>
<ul>
<li>当 Servlet 第一次被请求时，Servlet 容器就会开始调用 <code>init()</code> 方法来初始化一个 Servlet 对象出来，但是这个方法在后续请求中不会在被 Servlet 容器调用。调用这个方法时，Servlet 容器会传入一个 ServletConfig 对象进来从而对 Servlet 对象进行初始化</li>
<li>每当请求 Servlet 时，Servlet 容器就会调用 <code>service()</code> 方法，执行主要的业务逻辑</li>
<li>当要销毁 Servlet 时，Servlet 容器就会调用 <code>destory()</code> 方法，执行一些后处理逻辑</li>
</ul>
<h2 id="编写一个-servlet"><a href="#编写一个-Servlet" class="headerlink" title="编写一个 Servlet"></a>编写一个 Servlet</h2><p>1.创建一个 MyServlet 继承 HttpServlet 抽象类，重写 <code>doGet()</code> 和 <code>doPost()</code> 方法【这里的 HttpServlet 是实现了 Servlet 接口的抽象类 GenericServlet 的子类，利用 HttpServlet 抽象类可以直接在 <code>doGet()</code> 中处理 GET 请求，<code>doPost()</code> 中处理 POST 请求，而不用在 <code>service()</code> 方法中条件判断。实际上 HttpServlet 的 <code>service()</code> 方法就是做了这么一件事情，判断请求的方式去调用不同的处理方法。】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"处理get请求"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"处理post请求"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.在 web.xml 中配置 MyServlet，这一步的目的是为了让 tomcat 知道将封装好的 request 找到对应的 Servlet。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Servlet的名字，一般和类名相同--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Servlet的全限定类名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>top.zbsong.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--跟上面的Servlet名字相同，对应--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--浏览器通过该url找到Servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/MyServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.通过浏览器访问 <code>http://localhost:8080/ServletDemo/MyServlet</code></p>
<h2 id="请求转发和重定向的区别"><a href="#请求转发和重定向的区别" class="headerlink" title="请求转发和重定向的区别"></a>请求转发和重定向的区别</h2><ul>
<li>从数据共享来看，请求转发中目标页面和转发到的页面共享 request 里的数据；重定向不共享任何数据</li>
<li>从运用场景来看，请求转发一般用于用户登录，根据角色转发到相应的模块；重定向一般用于用户注销登录时返回主页面和跳转到其他网站等</li>
<li>从效率上来看，请求转发高；重定向低</li>
<li>请求转发是服务器调用不同的资源处理同一请求，始终是处理的同一个请求；重定向是让浏览器再次向服务器发送请求，前后是两个不同的请求。</li>
</ul>
<p>请求转发：forward，重定向：redirect。</p>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/数据库学习/" data-toggle="tooltip" data-placement="top" title="数据库">&larr; 上一篇</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/项目—秒杀总结/" data-toggle="tooltip" data-placement="top" title="两种限流算法的实现">下一篇 &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">目录</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#spring"><span class="toc-nav-number">1.</span> <span class="toc-nav-text"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#spring框架概述"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text"><a href="#Spring&#x6846;&#x67B6;&#x6982;&#x8FF0;" class="headerlink" title="Spring&#x6846;&#x67B6;&#x6982;&#x8FF0;"></a>Spring&#x6846;&#x67B6;&#x6982;&#x8FF0;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#特征"><span class="toc-nav-number">1.1.1.</span> <span class="toc-nav-text"><a href="#&#x7279;&#x5F81;" class="headerlink" title="&#x7279;&#x5F81;"></a>&#x7279;&#x5F81;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#列举一些重要的模块"><span class="toc-nav-number">1.1.2.</span> <span class="toc-nav-text"><a href="#&#x5217;&#x4E3E;&#x4E00;&#x4E9B;&#x91CD;&#x8981;&#x7684;&#x6A21;&#x5757;" class="headerlink" title="&#x5217;&#x4E3E;&#x4E00;&#x4E9B;&#x91CD;&#x8981;&#x7684;&#x6A21;&#x5757;"></a>&#x5217;&#x4E3E;&#x4E00;&#x4E9B;&#x91CD;&#x8981;&#x7684;&#x6A21;&#x5757;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#restcontroller和controller"><span class="toc-nav-number">1.1.3.</span> <span class="toc-nav-text"><a href="#RestController&#x548C;-Controller" class="headerlink" title="@RestController&#x548C;@Controller"></a>@RestController&#x548C;@Controller</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ioc和di"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text"><a href="#IoC&#x548C;DI" class="headerlink" title="IoC&#x548C;DI"></a>IoC&#x548C;DI</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#概念"><span class="toc-nav-number">1.2.1.</span> <span class="toc-nav-text"><a href="#&#x6982;&#x5FF5;" class="headerlink" title="&#x6982;&#x5FF5;"></a>&#x6982;&#x5FF5;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#ioc"><span class="toc-nav-number">1.2.1.1.</span> <span class="toc-nav-text"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#di"><span class="toc-nav-number">1.2.1.2.</span> <span class="toc-nav-text"><a href="#DI" class="headerlink" title="DI"></a>DI</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#总结"><span class="toc-nav-number">1.2.1.3.</span> <span class="toc-nav-text"><a href="#&#x603B;&#x7ED3;" class="headerlink" title="&#x603B;&#x7ED3;"></a>&#x603B;&#x7ED3;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#spring-ioc容器的初始化过程"><span class="toc-nav-number">1.2.2.</span> <span class="toc-nav-text"><a href="#Spring-IoC&#x5BB9;&#x5668;&#x7684;&#x521D;&#x59CB;&#x5316;&#x8FC7;&#x7A0B;" class="headerlink" title="Spring IoC&#x5BB9;&#x5668;&#x7684;&#x521D;&#x59CB;&#x5316;&#x8FC7;&#x7A0B;"></a>Spring IoC&#x5BB9;&#x5668;&#x7684;&#x521D;&#x59CB;&#x5316;&#x8FC7;&#x7A0B;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#spring-aop"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jdk-proxy"><span class="toc-nav-number">1.3.1.</span> <span class="toc-nav-text"><a href="#JDK-Proxy" class="headerlink" title="JDK Proxy"></a>JDK Proxy</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#cglib"><span class="toc-nav-number">1.3.2.</span> <span class="toc-nav-text"><a href="#CGLib" class="headerlink" title="CGLib"></a>CGLib</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#aop的使用"><span class="toc-nav-number">1.3.3.</span> <span class="toc-nav-text"><a href="#AOP&#x7684;&#x4F7F;&#x7528;" class="headerlink" title="AOP&#x7684;&#x4F7F;&#x7528;"></a>AOP&#x7684;&#x4F7F;&#x7528;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#基于xml的方式"><span class="toc-nav-number">1.3.3.1.</span> <span class="toc-nav-text"><a href="#&#x57FA;&#x4E8E;XML&#x7684;&#x65B9;&#x5F0F;" class="headerlink" title="&#x57FA;&#x4E8E;XML&#x7684;&#x65B9;&#x5F0F;"></a>&#x57FA;&#x4E8E;XML&#x7684;&#x65B9;&#x5F0F;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#基于注解的方式"><span class="toc-nav-number">1.3.3.2.</span> <span class="toc-nav-text"><a href="#&#x57FA;&#x4E8E;&#x6CE8;&#x89E3;&#x7684;&#x65B9;&#x5F0F;" class="headerlink" title="&#x57FA;&#x4E8E;&#x6CE8;&#x89E3;&#x7684;&#x65B9;&#x5F0F;"></a>&#x57FA;&#x4E8E;&#x6CE8;&#x89E3;&#x7684;&#x65B9;&#x5F0F;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#aop-常用注解"><span class="toc-nav-number">1.3.4.</span> <span class="toc-nav-text"><a href="#AOP-&#x5E38;&#x7528;&#x6CE8;&#x89E3;&#xFF1A;" class="headerlink" title="AOP &#x5E38;&#x7528;&#x6CE8;&#x89E3;&#xFF1A;"></a>AOP &#x5E38;&#x7528;&#x6CE8;&#x89E3;&#xFF1A;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#spring-aop和aspectj-aop有什么区别"><span class="toc-nav-number">1.3.5.</span> <span class="toc-nav-text"><a href="#Spring-AOP&#x548C;AspectJ-AOP&#x6709;&#x4EC0;&#x4E48;&#x533A;&#x522B;&#xFF1F;" class="headerlink" title="Spring AOP&#x548C;AspectJ AOP&#x6709;&#x4EC0;&#x4E48;&#x533A;&#x522B;&#xFF1F;"></a>Spring AOP&#x548C;AspectJ AOP&#x6709;&#x4EC0;&#x4E48;&#x533A;&#x522B;&#xFF1F;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#spring-bean"><span class="toc-nav-number">1.4.</span> <span class="toc-nav-text"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#spring-如何管理-bean-的"><span class="toc-nav-number">1.4.1.</span> <span class="toc-nav-text"><a href="#Spring-&#x5982;&#x4F55;&#x7BA1;&#x7406;-Bean-&#x7684;" class="headerlink" title="Spring &#x5982;&#x4F55;&#x7BA1;&#x7406; Bean &#x7684;"></a>Spring &#x5982;&#x4F55;&#x7BA1;&#x7406; Bean &#x7684;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#bean-的作用域"><span class="toc-nav-number">1.4.2.</span> <span class="toc-nav-text"><a href="#Bean-&#x7684;&#x4F5C;&#x7528;&#x57DF;" class="headerlink" title="Bean &#x7684;&#x4F5C;&#x7528;&#x57DF;"></a>Bean &#x7684;&#x4F5C;&#x7528;&#x57DF;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#spring中的单例bean的线程安全问题"><span class="toc-nav-number">1.4.3.</span> <span class="toc-nav-text"><a href="#Spring&#x4E2D;&#x7684;&#x5355;&#x4F8B;bean&#x7684;&#x7EBF;&#x7A0B;&#x5B89;&#x5168;&#x95EE;&#x9898;" class="headerlink" title="Spring&#x4E2D;&#x7684;&#x5355;&#x4F8B;bean&#x7684;&#x7EBF;&#x7A0B;&#x5B89;&#x5168;&#x95EE;&#x9898;"></a>Spring&#x4E2D;&#x7684;&#x5355;&#x4F8B;bean&#x7684;&#x7EBF;&#x7A0B;&#x5B89;&#x5168;&#x95EE;&#x9898;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#component和bean的区别是什么"><span class="toc-nav-number">1.4.4.</span> <span class="toc-nav-text"><a href="#Component&#x548C;-Bean&#x7684;&#x533A;&#x522B;&#x662F;&#x4EC0;&#x4E48;&#xFF1F;" class="headerlink" title="@Component&#x548C;@Bean&#x7684;&#x533A;&#x522B;&#x662F;&#x4EC0;&#x4E48;&#xFF1F;"></a>@Component&#x548C;@Bean&#x7684;&#x533A;&#x522B;&#x662F;&#x4EC0;&#x4E48;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#将一个类声明为spring的bean的注解有哪些"><span class="toc-nav-number">1.4.5.</span> <span class="toc-nav-text"><a href="#&#x5C06;&#x4E00;&#x4E2A;&#x7C7B;&#x58F0;&#x660E;&#x4E3A;Spring&#x7684;bean&#x7684;&#x6CE8;&#x89E3;&#x6709;&#x54EA;&#x4E9B;" class="headerlink" title="&#x5C06;&#x4E00;&#x4E2A;&#x7C7B;&#x58F0;&#x660E;&#x4E3A;Spring&#x7684;bean&#x7684;&#x6CE8;&#x89E3;&#x6709;&#x54EA;&#x4E9B;"></a>&#x5C06;&#x4E00;&#x4E2A;&#x7C7B;&#x58F0;&#x660E;&#x4E3A;Spring&#x7684;bean&#x7684;&#x6CE8;&#x89E3;&#x6709;&#x54EA;&#x4E9B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#bean-的生命周期"><span class="toc-nav-number">1.4.6.</span> <span class="toc-nav-text"><a href="#Bean-&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;" class="headerlink" title="Bean &#x7684;&#x751F;&#x547D;&#x5468;&#x671F;"></a>Bean &#x7684;&#x751F;&#x547D;&#x5468;&#x671F;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#一个-bean-的生命周期分为四个阶段"><span class="toc-nav-number">1.4.6.1.</span> <span class="toc-nav-text"><a href="#&#x4E00;&#x4E2A;-Bean-&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;&#x5206;&#x4E3A;&#x56DB;&#x4E2A;&#x9636;&#x6BB5;" class="headerlink" title="&#x4E00;&#x4E2A; Bean &#x7684;&#x751F;&#x547D;&#x5468;&#x671F;&#x5206;&#x4E3A;&#x56DB;&#x4E2A;&#x9636;&#x6BB5;"></a>&#x4E00;&#x4E2A; Bean &#x7684;&#x751F;&#x547D;&#x5468;&#x671F;&#x5206;&#x4E3A;&#x56DB;&#x4E2A;&#x9636;&#x6BB5;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#总结"><span class="toc-nav-number">1.4.6.2.</span> <span class="toc-nav-text"><a href="#&#x603B;&#x7ED3;-1" class="headerlink" title="&#x603B;&#x7ED3;"></a>&#x603B;&#x7ED3;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#beanfactory接口"><span class="toc-nav-number">1.4.7.</span> <span class="toc-nav-text"><a href="#BeanFactory&#x63A5;&#x53E3;" class="headerlink" title="BeanFactory&#x63A5;&#x53E3;"></a>BeanFactory&#x63A5;&#x53E3;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#applicationcontext接口"><span class="toc-nav-number">1.4.8.</span> <span class="toc-nav-text"><a href="#ApplicationContext&#x63A5;&#x53E3;" class="headerlink" title="ApplicationContext&#x63A5;&#x53E3;"></a>ApplicationContext&#x63A5;&#x53E3;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#spring-中-beanfactory-和-applicationcontext-的区别"><span class="toc-nav-number">1.4.9.</span> <span class="toc-nav-text"><a href="#Spring-&#x4E2D;-BeanFactory-&#x548C;-ApplicationContext-&#x7684;&#x533A;&#x522B;" class="headerlink" title="Spring &#x4E2D; BeanFactory &#x548C; ApplicationContext &#x7684;&#x533A;&#x522B;"></a>Spring &#x4E2D; BeanFactory &#x548C; ApplicationContext &#x7684;&#x533A;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#factorybean接口"><span class="toc-nav-number">1.4.10.</span> <span class="toc-nav-text"><a href="#FactoryBean&#x63A5;&#x53E3;" class="headerlink" title="FactoryBean&#x63A5;&#x53E3;"></a>FactoryBean&#x63A5;&#x53E3;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#beandefinition接口"><span class="toc-nav-number">1.4.11.</span> <span class="toc-nav-text"><a href="#BeanDefinition&#x63A5;&#x53E3;" class="headerlink" title="BeanDefinition&#x63A5;&#x53E3;"></a>BeanDefinition&#x63A5;&#x53E3;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#spring事务"><span class="toc-nav-number">1.5.</span> <span class="toc-nav-text"><a href="#Spring&#x4E8B;&#x52A1;" class="headerlink" title="Spring&#x4E8B;&#x52A1;"></a>Spring&#x4E8B;&#x52A1;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#spring管理事务的方式有几种"><span class="toc-nav-number">1.5.1.</span> <span class="toc-nav-text"><a href="#Spring&#x7BA1;&#x7406;&#x4E8B;&#x52A1;&#x7684;&#x65B9;&#x5F0F;&#x6709;&#x51E0;&#x79CD;&#xFF1F;" class="headerlink" title="Spring&#x7BA1;&#x7406;&#x4E8B;&#x52A1;&#x7684;&#x65B9;&#x5F0F;&#x6709;&#x51E0;&#x79CD;&#xFF1F;"></a>Spring&#x7BA1;&#x7406;&#x4E8B;&#x52A1;&#x7684;&#x65B9;&#x5F0F;&#x6709;&#x51E0;&#x79CD;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#spring事务的隔离级别有几种"><span class="toc-nav-number">1.5.2.</span> <span class="toc-nav-text"><a href="#Spring&#x4E8B;&#x52A1;&#x7684;&#x9694;&#x79BB;&#x7EA7;&#x522B;&#x6709;&#x51E0;&#x79CD;&#xFF1F;" class="headerlink" title="Spring&#x4E8B;&#x52A1;&#x7684;&#x9694;&#x79BB;&#x7EA7;&#x522B;&#x6709;&#x51E0;&#x79CD;&#xFF1F;"></a>Spring&#x4E8B;&#x52A1;&#x7684;&#x9694;&#x79BB;&#x7EA7;&#x522B;&#x6709;&#x51E0;&#x79CD;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#spring事务中的事务传播行为"><span class="toc-nav-number">1.5.3.</span> <span class="toc-nav-text"><a href="#Spring&#x4E8B;&#x52A1;&#x4E2D;&#x7684;&#x4E8B;&#x52A1;&#x4F20;&#x64AD;&#x884C;&#x4E3A;" class="headerlink" title="Spring&#x4E8B;&#x52A1;&#x4E2D;&#x7684;&#x4E8B;&#x52A1;&#x4F20;&#x64AD;&#x884C;&#x4E3A;"></a>Spring&#x4E8B;&#x52A1;&#x4E2D;&#x7684;&#x4E8B;&#x52A1;&#x4F20;&#x64AD;&#x884C;&#x4E3A;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#事务失效"><span class="toc-nav-number">1.5.4.</span> <span class="toc-nav-text"><a href="#&#x4E8B;&#x52A1;&#x5931;&#x6548;" class="headerlink" title="&#x4E8B;&#x52A1;&#x5931;&#x6548;"></a>&#x4E8B;&#x52A1;&#x5931;&#x6548;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#spring-循环依赖"><span class="toc-nav-number">1.6.</span> <span class="toc-nav-text"><a href="#Spring-&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;" class="headerlink" title="Spring &#x5FAA;&#x73AF;&#x4F9D;&#x8D56;"></a>Spring &#x5FAA;&#x73AF;&#x4F9D;&#x8D56;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#什么情况下循环依赖可以被处理"><span class="toc-nav-number">1.6.1.</span> <span class="toc-nav-text"><a href="#&#x4EC0;&#x4E48;&#x60C5;&#x51B5;&#x4E0B;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x53EF;&#x4EE5;&#x88AB;&#x5904;&#x7406;&#xFF1F;" class="headerlink" title="&#x4EC0;&#x4E48;&#x60C5;&#x51B5;&#x4E0B;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x53EF;&#x4EE5;&#x88AB;&#x5904;&#x7406;&#xFF1F;"></a>&#x4EC0;&#x4E48;&#x60C5;&#x51B5;&#x4E0B;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x53EF;&#x4EE5;&#x88AB;&#x5904;&#x7406;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#spring-内部的三级缓存"><span class="toc-nav-number">1.6.2.</span> <span class="toc-nav-text"><a href="#Spring-&#x5185;&#x90E8;&#x7684;&#x4E09;&#x7EA7;&#x7F13;&#x5B58;" class="headerlink" title="Spring &#x5185;&#x90E8;&#x7684;&#x4E09;&#x7EA7;&#x7F13;&#x5B58;"></a>Spring &#x5185;&#x90E8;&#x7684;&#x4E09;&#x7EA7;&#x7F13;&#x5B58;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#spring-如何解决循环依赖"><span class="toc-nav-number">1.6.3.</span> <span class="toc-nav-text"><a href="#Spring-&#x5982;&#x4F55;&#x89E3;&#x51B3;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#xFF1F;" class="headerlink" title="Spring &#x5982;&#x4F55;&#x89E3;&#x51B3;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#xFF1F;"></a>Spring &#x5982;&#x4F55;&#x89E3;&#x51B3;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#为什么要三级缓存二级缓存能解决循环依赖吗"><span class="toc-nav-number">1.6.4.</span> <span class="toc-nav-text"><a href="#&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x4E09;&#x7EA7;&#x7F13;&#x5B58;&#xFF1F;&#x4E8C;&#x7EA7;&#x7F13;&#x5B58;&#x80FD;&#x89E3;&#x51B3;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x5417;&#xFF1F;" class="headerlink" title="&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x4E09;&#x7EA7;&#x7F13;&#x5B58;&#xFF1F;&#x4E8C;&#x7EA7;&#x7F13;&#x5B58;&#x80FD;&#x89E3;&#x51B3;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x5417;&#xFF1F;"></a>&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x4E09;&#x7EA7;&#x7F13;&#x5B58;&#xFF1F;&#x4E8C;&#x7EA7;&#x7F13;&#x5B58;&#x80FD;&#x89E3;&#x51B3;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x5417;&#xFF1F;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#spring的自动装配"><span class="toc-nav-number">1.7.</span> <span class="toc-nav-text"><a href="#Spring&#x7684;&#x81EA;&#x52A8;&#x88C5;&#x914D;" class="headerlink" title="Spring&#x7684;&#x81EA;&#x52A8;&#x88C5;&#x914D;"></a>Spring&#x7684;&#x81EA;&#x52A8;&#x88C5;&#x914D;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#spring-mvc"><span class="toc-nav-number">2.</span> <span class="toc-nav-text"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#工作原理"><span class="toc-nav-number">2.0.1.</span> <span class="toc-nav-text"><a href="#&#x5DE5;&#x4F5C;&#x539F;&#x7406;" class="headerlink" title="&#x5DE5;&#x4F5C;&#x539F;&#x7406;"></a>&#x5DE5;&#x4F5C;&#x539F;&#x7406;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#controller-和-requestmapping-如何对应"><span class="toc-nav-number">2.0.2.</span> <span class="toc-nav-text"><a href="#Controller-&#x548C;-RequestMapping-&#x5982;&#x4F55;&#x5BF9;&#x5E94;" class="headerlink" title="Controller &#x548C; RequestMapping &#x5982;&#x4F55;&#x5BF9;&#x5E94;"></a>Controller &#x548C; RequestMapping &#x5982;&#x4F55;&#x5BF9;&#x5E94;</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#spring-boot"><span class="toc-nav-number">3.</span> <span class="toc-nav-text"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#spring-boot介绍"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text"><a href="#Spring-Boot&#x4ECB;&#x7ECD;" class="headerlink" title="Spring Boot&#x4ECB;&#x7ECD;"></a>Spring Boot&#x4ECB;&#x7ECD;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#spring-boot-如何创建项目"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text"><a href="#Spring-Boot-&#x5982;&#x4F55;&#x521B;&#x5EFA;&#x9879;&#x76EE;" class="headerlink" title="Spring Boot &#x5982;&#x4F55;&#x521B;&#x5EFA;&#x9879;&#x76EE;"></a>Spring Boot &#x5982;&#x4F55;&#x521B;&#x5EFA;&#x9879;&#x76EE;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#spring-boot-项目结构"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text"><a href="#Spring-Boot-&#x9879;&#x76EE;&#x7ED3;&#x6784;" class="headerlink" title="Spring Boot &#x9879;&#x76EE;&#x7ED3;&#x6784;"></a>Spring Boot &#x9879;&#x76EE;&#x7ED3;&#x6784;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#springbootapplication-注解"><span class="toc-nav-number">3.4.</span> <span class="toc-nav-text"><a href="#SpringBootApplication-&#x6CE8;&#x89E3;" class="headerlink" title="@SpringBootApplication &#x6CE8;&#x89E3;"></a>@SpringBootApplication &#x6CE8;&#x89E3;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#spring-如何读取配置文件"><span class="toc-nav-number">3.5.</span> <span class="toc-nav-text"><a href="#Spring-&#x5982;&#x4F55;&#x8BFB;&#x53D6;&#x914D;&#x7F6E;&#x6587;&#x4EF6;" class="headerlink" title="Spring &#x5982;&#x4F55;&#x8BFB;&#x53D6;&#x914D;&#x7F6E;&#x6587;&#x4EF6;"></a>Spring &#x5982;&#x4F55;&#x8BFB;&#x53D6;&#x914D;&#x7F6E;&#x6587;&#x4EF6;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#通过-value-注解读取"><span class="toc-nav-number">3.5.1.</span> <span class="toc-nav-text"><a href="#&#x901A;&#x8FC7;-Value-&#x6CE8;&#x89E3;&#x8BFB;&#x53D6;" class="headerlink" title="&#x901A;&#x8FC7; @Value &#x6CE8;&#x89E3;&#x8BFB;&#x53D6;"></a>&#x901A;&#x8FC7; @Value &#x6CE8;&#x89E3;&#x8BFB;&#x53D6;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#通过-configurationproperties-读取"><span class="toc-nav-number">3.5.2.</span> <span class="toc-nav-text"><a href="#&#x901A;&#x8FC7;-ConfigurationProperties-&#x8BFB;&#x53D6;" class="headerlink" title="&#x901A;&#x8FC7; @ConfigurationProperties &#x8BFB;&#x53D6;"></a>&#x901A;&#x8FC7; @ConfigurationProperties &#x8BFB;&#x53D6;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#spring-boot-如何处理异常"><span class="toc-nav-number">3.6.</span> <span class="toc-nav-text"><a href="#Spring-Boot-&#x5982;&#x4F55;&#x5904;&#x7406;&#x5F02;&#x5E38;" class="headerlink" title="Spring Boot &#x5982;&#x4F55;&#x5904;&#x7406;&#x5F02;&#x5E38;"></a>Spring Boot &#x5982;&#x4F55;&#x5904;&#x7406;&#x5F02;&#x5E38;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#jpa"><span class="toc-nav-number">3.7.</span> <span class="toc-nav-text"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#如何使用jpa在数据库中非持久化一个字段"><span class="toc-nav-number">3.7.1.</span> <span class="toc-nav-text"><a href="#&#x5982;&#x4F55;&#x4F7F;&#x7528;JPA&#x5728;&#x6570;&#x636E;&#x5E93;&#x4E2D;&#x975E;&#x6301;&#x4E45;&#x5316;&#x4E00;&#x4E2A;&#x5B57;&#x6BB5;&#xFF1F;" class="headerlink" title="&#x5982;&#x4F55;&#x4F7F;&#x7528;JPA&#x5728;&#x6570;&#x636E;&#x5E93;&#x4E2D;&#x975E;&#x6301;&#x4E45;&#x5316;&#x4E00;&#x4E2A;&#x5B57;&#x6BB5;&#xFF1F;"></a>&#x5982;&#x4F55;&#x4F7F;&#x7528;JPA&#x5728;&#x6570;&#x636E;&#x5E93;&#x4E2D;&#x975E;&#x6301;&#x4E45;&#x5316;&#x4E00;&#x4E2A;&#x5B57;&#x6BB5;&#xFF1F;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#过滤器"><span class="toc-nav-number">3.8.</span> <span class="toc-nav-text"><a href="#&#x8FC7;&#x6EE4;&#x5668;" class="headerlink" title="&#x8FC7;&#x6EE4;&#x5668;"></a>&#x8FC7;&#x6EE4;&#x5668;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#介绍"><span class="toc-nav-number">3.8.1.</span> <span class="toc-nav-text"><a href="#&#x4ECB;&#x7ECD;" class="headerlink" title="&#x4ECB;&#x7ECD;"></a>&#x4ECB;&#x7ECD;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#如何实现过滤的"><span class="toc-nav-number">3.8.2.</span> <span class="toc-nav-text"><a href="#&#x5982;&#x4F55;&#x5B9E;&#x73B0;&#x8FC7;&#x6EE4;&#x7684;&#xFF1F;" class="headerlink" title="&#x5982;&#x4F55;&#x5B9E;&#x73B0;&#x8FC7;&#x6EE4;&#x7684;&#xFF1F;"></a>&#x5982;&#x4F55;&#x5B9E;&#x73B0;&#x8FC7;&#x6EE4;&#x7684;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#自定义filter"><span class="toc-nav-number">3.8.3.</span> <span class="toc-nav-text"><a href="#&#x81EA;&#x5B9A;&#x4E49;Filter" class="headerlink" title="&#x81EA;&#x5B9A;&#x4E49;Filter"></a>&#x81EA;&#x5B9A;&#x4E49;Filter</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#拦截器"><span class="toc-nav-number">3.9.</span> <span class="toc-nav-text"><a href="#&#x62E6;&#x622A;&#x5668;" class="headerlink" title="&#x62E6;&#x622A;&#x5668;"></a>&#x62E6;&#x622A;&#x5668;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#自定义-interceptor"><span class="toc-nav-number">3.9.1.</span> <span class="toc-nav-text"><a href="#&#x81EA;&#x5B9A;&#x4E49;-Interceptor" class="headerlink" title="&#x81EA;&#x5B9A;&#x4E49; Interceptor"></a>&#x81EA;&#x5B9A;&#x4E49; Interceptor</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#拦截器和过滤器的区别"><span class="toc-nav-number">3.10.</span> <span class="toc-nav-text"><a href="#&#x62E6;&#x622A;&#x5668;&#x548C;&#x8FC7;&#x6EE4;&#x5668;&#x7684;&#x533A;&#x522B;" class="headerlink" title="&#x62E6;&#x622A;&#x5668;&#x548C;&#x8FC7;&#x6EE4;&#x5668;&#x7684;&#x533A;&#x522B;"></a>&#x62E6;&#x622A;&#x5668;&#x548C;&#x8FC7;&#x6EE4;&#x5668;&#x7684;&#x533A;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#spring-boot-自动装配原理"><span class="toc-nav-number">3.11.</span> <span class="toc-nav-text"><a href="#Spring-Boot-&#x81EA;&#x52A8;&#x88C5;&#x914D;&#x539F;&#x7406;" class="headerlink" title="Spring Boot &#x81EA;&#x52A8;&#x88C5;&#x914D;&#x539F;&#x7406;"></a>Spring Boot &#x81EA;&#x52A8;&#x88C5;&#x914D;&#x539F;&#x7406;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#什么是-spring-boot-自动装配"><span class="toc-nav-number">3.11.1.</span> <span class="toc-nav-text"><a href="#&#x4EC0;&#x4E48;&#x662F;-Spring-Boot-&#x81EA;&#x52A8;&#x88C5;&#x914D;&#xFF1F;" class="headerlink" title="&#x4EC0;&#x4E48;&#x662F; Spring Boot &#x81EA;&#x52A8;&#x88C5;&#x914D;&#xFF1F;"></a>&#x4EC0;&#x4E48;&#x662F; Spring Boot &#x81EA;&#x52A8;&#x88C5;&#x914D;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#spring-boot-是如何实现自动装配的"><span class="toc-nav-number">3.11.2.</span> <span class="toc-nav-text"><a href="#Spring-Boot-&#x662F;&#x5982;&#x4F55;&#x5B9E;&#x73B0;&#x81EA;&#x52A8;&#x88C5;&#x914D;&#x7684;&#xFF1F;" class="headerlink" title="Spring Boot &#x662F;&#x5982;&#x4F55;&#x5B9E;&#x73B0;&#x81EA;&#x52A8;&#x88C5;&#x914D;&#x7684;&#xFF1F;"></a>Spring Boot &#x662F;&#x5982;&#x4F55;&#x5B9E;&#x73B0;&#x81EA;&#x52A8;&#x88C5;&#x914D;&#x7684;&#xFF1F;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#自定义starter"><span class="toc-nav-number">3.12.</span> <span class="toc-nav-text"><a href="#&#x81EA;&#x5B9A;&#x4E49;starter" class="headerlink" title="&#x81EA;&#x5B9A;&#x4E49;starter"></a>&#x81EA;&#x5B9A;&#x4E49;starter</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#bean映射工具"><span class="toc-nav-number">3.13.</span> <span class="toc-nav-text"><a href="#Bean&#x6620;&#x5C04;&#x5DE5;&#x5177;" class="headerlink" title="Bean&#x6620;&#x5C04;&#x5DE5;&#x5177;"></a>Bean&#x6620;&#x5C04;&#x5DE5;&#x5177;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#apache-的-beanutils"><span class="toc-nav-number">3.13.1.</span> <span class="toc-nav-text"><a href="#Apache-&#x7684;-BeanUtils" class="headerlink" title="Apache &#x7684; BeanUtils"></a>Apache &#x7684; BeanUtils</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#spring-的-beanutils"><span class="toc-nav-number">3.13.2.</span> <span class="toc-nav-text"><a href="#Spring-&#x7684;-BeanUtils" class="headerlink" title="Spring &#x7684; BeanUtils"></a>Spring &#x7684; BeanUtils</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#spring-boot-定时任务"><span class="toc-nav-number">3.14.</span> <span class="toc-nav-text"><a href="#Spring-Boot-&#x5B9A;&#x65F6;&#x4EFB;&#x52A1;" class="headerlink" title="Spring Boot  &#x5B9A;&#x65F6;&#x4EFB;&#x52A1;"></a>Spring Boot  &#x5B9A;&#x65F6;&#x4EFB;&#x52A1;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#静态基于注解"><span class="toc-nav-number">3.14.1.</span> <span class="toc-nav-text"><a href="#&#x9759;&#x6001;&#xFF1A;&#x57FA;&#x4E8E;&#x6CE8;&#x89E3;" class="headerlink" title="&#x9759;&#x6001;&#xFF1A;&#x57FA;&#x4E8E;&#x6CE8;&#x89E3;"></a>&#x9759;&#x6001;&#xFF1A;&#x57FA;&#x4E8E;&#x6CE8;&#x89E3;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#创建定时器"><span class="toc-nav-number">3.14.1.1.</span> <span class="toc-nav-text"><a href="#&#x521B;&#x5EFA;&#x5B9A;&#x65F6;&#x5668;" class="headerlink" title="&#x521B;&#x5EFA;&#x5B9A;&#x65F6;&#x5668;"></a>&#x521B;&#x5EFA;&#x5B9A;&#x65F6;&#x5668;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#缺点"><span class="toc-nav-number">3.14.1.2.</span> <span class="toc-nav-text"><a href="#&#x7F3A;&#x70B9;" class="headerlink" title="&#x7F3A;&#x70B9;"></a>&#x7F3A;&#x70B9;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#动态基于接口-schedulingconfigurer"><span class="toc-nav-number">3.14.2.</span> <span class="toc-nav-text"><a href="#&#x52A8;&#x6001;&#xFF1A;&#x57FA;&#x4E8E;&#x63A5;&#x53E3;-SchedulingConfigurer" class="headerlink" title="&#x52A8;&#x6001;&#xFF1A;&#x57FA;&#x4E8E;&#x63A5;&#x53E3; SchedulingConfigurer"></a>&#x52A8;&#x6001;&#xFF1A;&#x57FA;&#x4E8E;&#x63A5;&#x53E3; SchedulingConfigurer</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#创建定时器"><span class="toc-nav-number">3.14.2.1.</span> <span class="toc-nav-text"><a href="#&#x521B;&#x5EFA;&#x5B9A;&#x65F6;&#x5668;-1" class="headerlink" title="&#x521B;&#x5EFA;&#x5B9A;&#x65F6;&#x5668;"></a>&#x521B;&#x5EFA;&#x5B9A;&#x65F6;&#x5668;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#修改执行周期"><span class="toc-nav-number">3.14.2.2.</span> <span class="toc-nav-text"><a href="#&#x4FEE;&#x6539;&#x6267;&#x884C;&#x5468;&#x671F;" class="headerlink" title="&#x4FEE;&#x6539;&#x6267;&#x884C;&#x5468;&#x671F;"></a>&#x4FEE;&#x6539;&#x6267;&#x884C;&#x5468;&#x671F;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#多线程"><span class="toc-nav-number">3.14.3.</span> <span class="toc-nav-text"><a href="#&#x591A;&#x7EBF;&#x7A0B;" class="headerlink" title="&#x591A;&#x7EBF;&#x7A0B;"></a>&#x591A;&#x7EBF;&#x7A0B;</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#常用注解"><span class="toc-nav-number">4.</span> <span class="toc-nav-text"><a href="#&#x5E38;&#x7528;&#x6CE8;&#x89E3;" class="headerlink" title="&#x5E38;&#x7528;&#x6CE8;&#x89E3;"></a>&#x5E38;&#x7528;&#x6CE8;&#x89E3;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#springbootapplication"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#spring-bean-相关"><span class="toc-nav-number">4.2.</span> <span class="toc-nav-text"><a href="#Spring-Bean-&#x76F8;&#x5173;" class="headerlink" title="Spring Bean &#x76F8;&#x5173;"></a>Spring Bean &#x76F8;&#x5173;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#autowired"><span class="toc-nav-number">4.2.1.</span> <span class="toc-nav-text"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#componentrepositoryservicecontroller"><span class="toc-nav-number">4.2.2.</span> <span class="toc-nav-text"><a href="#Component-Repository-Service-Controller" class="headerlink" title="@Component,@Repository,@Service,@Controller"></a>@Component,@Repository,@Service,@Controller</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#restcontroller"><span class="toc-nav-number">4.2.3.</span> <span class="toc-nav-text"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#scope"><span class="toc-nav-number">4.2.4.</span> <span class="toc-nav-text"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#configuration"><span class="toc-nav-number">4.2.5.</span> <span class="toc-nav-text"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#处理常见的-http-请求类型"><span class="toc-nav-number">4.3.</span> <span class="toc-nav-text"><a href="#&#x5904;&#x7406;&#x5E38;&#x89C1;&#x7684;-HTTP-&#x8BF7;&#x6C42;&#x7C7B;&#x578B;" class="headerlink" title="&#x5904;&#x7406;&#x5E38;&#x89C1;&#x7684; HTTP &#x8BF7;&#x6C42;&#x7C7B;&#x578B;"></a>&#x5904;&#x7406;&#x5E38;&#x89C1;&#x7684; HTTP &#x8BF7;&#x6C42;&#x7C7B;&#x578B;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#get请求"><span class="toc-nav-number">4.3.1.</span> <span class="toc-nav-text"><a href="#GET&#x8BF7;&#x6C42;" class="headerlink" title="GET&#x8BF7;&#x6C42;"></a>GET&#x8BF7;&#x6C42;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#post请求"><span class="toc-nav-number">4.3.2.</span> <span class="toc-nav-text"><a href="#POST&#x8BF7;&#x6C42;" class="headerlink" title="POST&#x8BF7;&#x6C42;"></a>POST&#x8BF7;&#x6C42;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#put请求"><span class="toc-nav-number">4.3.3.</span> <span class="toc-nav-text"><a href="#PUT&#x8BF7;&#x6C42;" class="headerlink" title="PUT&#x8BF7;&#x6C42;"></a>PUT&#x8BF7;&#x6C42;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#delete请求"><span class="toc-nav-number">4.3.4.</span> <span class="toc-nav-text"><a href="#DELETE&#x8BF7;&#x6C42;" class="headerlink" title="DELETE&#x8BF7;&#x6C42;"></a>DELETE&#x8BF7;&#x6C42;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#前后端传值"><span class="toc-nav-number">4.4.</span> <span class="toc-nav-text"><a href="#&#x524D;&#x540E;&#x7AEF;&#x4F20;&#x503C;" class="headerlink" title="&#x524D;&#x540E;&#x7AEF;&#x4F20;&#x503C;"></a>&#x524D;&#x540E;&#x7AEF;&#x4F20;&#x503C;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#pathvariable和requestparam"><span class="toc-nav-number">4.4.1.</span> <span class="toc-nav-text"><a href="#PathVariable&#x548C;-RequestParam" class="headerlink" title="@PathVariable&#x548C;@RequestParam"></a>@PathVariable&#x548C;@RequestParam</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#requestbody"><span class="toc-nav-number">4.4.2.</span> <span class="toc-nav-text"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#读取配置信息"><span class="toc-nav-number">4.5.</span> <span class="toc-nav-text"><a href="#&#x8BFB;&#x53D6;&#x914D;&#x7F6E;&#x4FE1;&#x606F;" class="headerlink" title="&#x8BFB;&#x53D6;&#x914D;&#x7F6E;&#x4FE1;&#x606F;"></a>&#x8BFB;&#x53D6;&#x914D;&#x7F6E;&#x4FE1;&#x606F;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#通过-value-注解读取"><span class="toc-nav-number">4.5.1.</span> <span class="toc-nav-text"><a href="#&#x901A;&#x8FC7;-Value-&#x6CE8;&#x89E3;&#x8BFB;&#x53D6;-1" class="headerlink" title="&#x901A;&#x8FC7; @Value &#x6CE8;&#x89E3;&#x8BFB;&#x53D6;"></a>&#x901A;&#x8FC7; @Value &#x6CE8;&#x89E3;&#x8BFB;&#x53D6;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#通过-configurationproperties-读取"><span class="toc-nav-number">4.5.2.</span> <span class="toc-nav-text"><a href="#&#x901A;&#x8FC7;-ConfigurationProperties-&#x8BFB;&#x53D6;-1" class="headerlink" title="&#x901A;&#x8FC7; @ConfigurationProperties &#x8BFB;&#x53D6;"></a>&#x901A;&#x8FC7; @ConfigurationProperties &#x8BFB;&#x53D6;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#全局处理controller层异常"><span class="toc-nav-number">4.6.</span> <span class="toc-nav-text"><a href="#&#x5168;&#x5C40;&#x5904;&#x7406;Controller&#x5C42;&#x5F02;&#x5E38;" class="headerlink" title="&#x5168;&#x5C40;&#x5904;&#x7406;Controller&#x5C42;&#x5F02;&#x5E38;"></a>&#x5168;&#x5C40;&#x5904;&#x7406;Controller&#x5C42;&#x5F02;&#x5E38;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#json-数据处理"><span class="toc-nav-number">4.7.</span> <span class="toc-nav-text"><a href="#JSON-&#x6570;&#x636E;&#x5904;&#x7406;" class="headerlink" title="JSON &#x6570;&#x636E;&#x5904;&#x7406;"></a>JSON &#x6570;&#x636E;&#x5904;&#x7406;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#过滤json数据"><span class="toc-nav-number">4.7.1.</span> <span class="toc-nav-text"><a href="#&#x8FC7;&#x6EE4;JSON&#x6570;&#x636E;" class="headerlink" title="&#x8FC7;&#x6EE4;JSON&#x6570;&#x636E;"></a>&#x8FC7;&#x6EE4;JSON&#x6570;&#x636E;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#格式化-json-数据"><span class="toc-nav-number">4.7.2.</span> <span class="toc-nav-text"><a href="#&#x683C;&#x5F0F;&#x5316;-JSON-&#x6570;&#x636E;" class="headerlink" title="&#x683C;&#x5F0F;&#x5316; JSON &#x6570;&#x636E;"></a>&#x683C;&#x5F0F;&#x5316; JSON &#x6570;&#x636E;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#扁平化对象"><span class="toc-nav-number">4.7.3.</span> <span class="toc-nav-text"><a href="#&#x6241;&#x5E73;&#x5316;&#x5BF9;&#x8C61;" class="headerlink" title="&#x6241;&#x5E73;&#x5316;&#x5BF9;&#x8C61;"></a>&#x6241;&#x5E73;&#x5316;&#x5BF9;&#x8C61;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#测试相关"><span class="toc-nav-number">4.8.</span> <span class="toc-nav-text"><a href="#&#x6D4B;&#x8BD5;&#x76F8;&#x5173;" class="headerlink" title="&#x6D4B;&#x8BD5;&#x76F8;&#x5173;"></a>&#x6D4B;&#x8BD5;&#x76F8;&#x5173;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#autowired-可以加载构造方法上吗"><span class="toc-nav-number">4.9.</span> <span class="toc-nav-text"><a href="#Autowired-&#x53EF;&#x4EE5;&#x52A0;&#x8F7D;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x4E0A;&#x5417;" class="headerlink" title="@Autowired &#x53EF;&#x4EE5;&#x52A0;&#x8F7D;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x4E0A;&#x5417;"></a>@Autowired &#x53EF;&#x4EE5;&#x52A0;&#x8F7D;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x4E0A;&#x5417;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#spring事务"><span class="toc-nav-number">5.</span> <span class="toc-nav-text"><a href="#Spring&#x4E8B;&#x52A1;-1" class="headerlink" title="Spring&#x4E8B;&#x52A1;"></a>Spring&#x4E8B;&#x52A1;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#事务的特性acid"><span class="toc-nav-number">5.1.</span> <span class="toc-nav-text"><a href="#&#x4E8B;&#x52A1;&#x7684;&#x7279;&#x6027;ACID" class="headerlink" title="&#x4E8B;&#x52A1;&#x7684;&#x7279;&#x6027;ACID"></a>&#x4E8B;&#x52A1;&#x7684;&#x7279;&#x6027;ACID</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#spring对事务的支持"><span class="toc-nav-number">5.2.</span> <span class="toc-nav-text"><a href="#Spring&#x5BF9;&#x4E8B;&#x52A1;&#x7684;&#x652F;&#x6301;" class="headerlink" title="Spring&#x5BF9;&#x4E8B;&#x52A1;&#x7684;&#x652F;&#x6301;"></a>Spring&#x5BF9;&#x4E8B;&#x52A1;&#x7684;&#x652F;&#x6301;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#如何实现回滚"><span class="toc-nav-number">5.2.1.</span> <span class="toc-nav-text"><a href="#&#x5982;&#x4F55;&#x5B9E;&#x73B0;&#x56DE;&#x6EDA;&#xFF1F;" class="headerlink" title="&#x5982;&#x4F55;&#x5B9E;&#x73B0;&#x56DE;&#x6EDA;&#xFF1F;"></a><strong>&#x5982;&#x4F55;&#x5B9E;&#x73B0;&#x56DE;&#x6EDA;&#xFF1F;</strong></span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#spring支持两种方式的事务"><span class="toc-nav-number">5.2.2.</span> <span class="toc-nav-text"><a href="#Spring&#x652F;&#x6301;&#x4E24;&#x79CD;&#x65B9;&#x5F0F;&#x7684;&#x4E8B;&#x52A1;" class="headerlink" title="Spring&#x652F;&#x6301;&#x4E24;&#x79CD;&#x65B9;&#x5F0F;&#x7684;&#x4E8B;&#x52A1;"></a>Spring&#x652F;&#x6301;&#x4E24;&#x79CD;&#x65B9;&#x5F0F;&#x7684;&#x4E8B;&#x52A1;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#spring事务管理接口"><span class="toc-nav-number">5.2.3.</span> <span class="toc-nav-text"><a href="#Spring&#x4E8B;&#x52A1;&#x7BA1;&#x7406;&#x63A5;&#x53E3;" class="headerlink" title="Spring&#x4E8B;&#x52A1;&#x7BA1;&#x7406;&#x63A5;&#x53E3;"></a>Spring&#x4E8B;&#x52A1;&#x7BA1;&#x7406;&#x63A5;&#x53E3;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#platformtransactionmanager事务管理接口"><span class="toc-nav-number">5.2.3.1.</span> <span class="toc-nav-text"><a href="#PlatformTransactionManager&#xFF1A;&#x4E8B;&#x52A1;&#x7BA1;&#x7406;&#x63A5;&#x53E3;" class="headerlink" title="PlatformTransactionManager&#xFF1A;&#x4E8B;&#x52A1;&#x7BA1;&#x7406;&#x63A5;&#x53E3;"></a>PlatformTransactionManager&#xFF1A;&#x4E8B;&#x52A1;&#x7BA1;&#x7406;&#x63A5;&#x53E3;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#transactiondefinition事务属性"><span class="toc-nav-number">5.2.3.2.</span> <span class="toc-nav-text"><a href="#TransactionDefinition&#xFF1A;&#x4E8B;&#x52A1;&#x5C5E;&#x6027;" class="headerlink" title="TransactionDefinition&#xFF1A;&#x4E8B;&#x52A1;&#x5C5E;&#x6027;"></a>TransactionDefinition&#xFF1A;&#x4E8B;&#x52A1;&#x5C5E;&#x6027;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#transactionstatus事务状态"><span class="toc-nav-number">5.2.3.3.</span> <span class="toc-nav-text"><a href="#TransactionStatus&#xFF1A;&#x4E8B;&#x52A1;&#x72B6;&#x6001;" class="headerlink" title="TransactionStatus&#xFF1A;&#x4E8B;&#x52A1;&#x72B6;&#x6001;"></a>TransactionStatus&#xFF1A;&#x4E8B;&#x52A1;&#x72B6;&#x6001;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#事务属性详解"><span class="toc-nav-number">5.2.4.</span> <span class="toc-nav-text"><a href="#&#x4E8B;&#x52A1;&#x5C5E;&#x6027;&#x8BE6;&#x89E3;" class="headerlink" title="&#x4E8B;&#x52A1;&#x5C5E;&#x6027;&#x8BE6;&#x89E3;"></a>&#x4E8B;&#x52A1;&#x5C5E;&#x6027;&#x8BE6;&#x89E3;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#事务传播行为"><span class="toc-nav-number">5.2.4.1.</span> <span class="toc-nav-text"><a href="#&#x4E8B;&#x52A1;&#x4F20;&#x64AD;&#x884C;&#x4E3A;" class="headerlink" title="&#x4E8B;&#x52A1;&#x4F20;&#x64AD;&#x884C;&#x4E3A;"></a>&#x4E8B;&#x52A1;&#x4F20;&#x64AD;&#x884C;&#x4E3A;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#事务隔离级别"><span class="toc-nav-number">5.2.4.2.</span> <span class="toc-nav-text"><a href="#&#x4E8B;&#x52A1;&#x9694;&#x79BB;&#x7EA7;&#x522B;" class="headerlink" title="&#x4E8B;&#x52A1;&#x9694;&#x79BB;&#x7EA7;&#x522B;"></a>&#x4E8B;&#x52A1;&#x9694;&#x79BB;&#x7EA7;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#事务超时属性"><span class="toc-nav-number">5.2.4.3.</span> <span class="toc-nav-text"><a href="#&#x4E8B;&#x52A1;&#x8D85;&#x65F6;&#x5C5E;&#x6027;" class="headerlink" title="&#x4E8B;&#x52A1;&#x8D85;&#x65F6;&#x5C5E;&#x6027;"></a>&#x4E8B;&#x52A1;&#x8D85;&#x65F6;&#x5C5E;&#x6027;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#事务只读属性"><span class="toc-nav-number">5.2.4.4.</span> <span class="toc-nav-text"><a href="#&#x4E8B;&#x52A1;&#x53EA;&#x8BFB;&#x5C5E;&#x6027;" class="headerlink" title="&#x4E8B;&#x52A1;&#x53EA;&#x8BFB;&#x5C5E;&#x6027;"></a>&#x4E8B;&#x52A1;&#x53EA;&#x8BFB;&#x5C5E;&#x6027;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#事务回滚规则"><span class="toc-nav-number">5.2.4.5.</span> <span class="toc-nav-text"><a href="#&#x4E8B;&#x52A1;&#x56DE;&#x6EDA;&#x89C4;&#x5219;" class="headerlink" title="&#x4E8B;&#x52A1;&#x56DE;&#x6EDA;&#x89C4;&#x5219;"></a>&#x4E8B;&#x52A1;&#x56DE;&#x6EDA;&#x89C4;&#x5219;</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#transactional-注解使用详解"><span class="toc-nav-number">5.3.</span> <span class="toc-nav-text"><a href="#Transactional-&#x6CE8;&#x89E3;&#x4F7F;&#x7528;&#x8BE6;&#x89E3;" class="headerlink" title="@Transactional &#x6CE8;&#x89E3;&#x4F7F;&#x7528;&#x8BE6;&#x89E3;"></a>@Transactional &#x6CE8;&#x89E3;&#x4F7F;&#x7528;&#x8BE6;&#x89E3;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#作用范围"><span class="toc-nav-number">5.3.0.1.</span> <span class="toc-nav-text"><a href="#&#x4F5C;&#x7528;&#x8303;&#x56F4;" class="headerlink" title="&#x4F5C;&#x7528;&#x8303;&#x56F4;"></a>&#x4F5C;&#x7528;&#x8303;&#x56F4;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#常用配置参数"><span class="toc-nav-number">5.3.0.2.</span> <span class="toc-nav-text"><a href="#&#x5E38;&#x7528;&#x914D;&#x7F6E;&#x53C2;&#x6570;" class="headerlink" title="&#x5E38;&#x7528;&#x914D;&#x7F6E;&#x53C2;&#x6570;"></a>&#x5E38;&#x7528;&#x914D;&#x7F6E;&#x53C2;&#x6570;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#transacntional-事务注解原理"><span class="toc-nav-number">5.3.0.3.</span> <span class="toc-nav-text"><a href="#Transacntional-&#x4E8B;&#x52A1;&#x6CE8;&#x89E3;&#x539F;&#x7406;" class="headerlink" title="@Transacntional &#x4E8B;&#x52A1;&#x6CE8;&#x89E3;&#x539F;&#x7406;"></a>@Transacntional &#x4E8B;&#x52A1;&#x6CE8;&#x89E3;&#x539F;&#x7406;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#spring-aop-自调用问题"><span class="toc-nav-number">5.3.0.4.</span> <span class="toc-nav-text"><a href="#Spring-AOP-&#x81EA;&#x8C03;&#x7528;&#x95EE;&#x9898;" class="headerlink" title="Spring AOP &#x81EA;&#x8C03;&#x7528;&#x95EE;&#x9898;"></a>Spring AOP &#x81EA;&#x8C03;&#x7528;&#x95EE;&#x9898;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#使用总结"><span class="toc-nav-number">5.3.0.5.</span> <span class="toc-nav-text"><a href="#&#x4F7F;&#x7528;&#x603B;&#x7ED3;" class="headerlink" title="&#x4F7F;&#x7528;&#x603B;&#x7ED3;"></a>&#x4F7F;&#x7528;&#x603B;&#x7ED3;</span></a></li></ol></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#spring框架中用了哪些设计模式"><span class="toc-nav-number">6.</span> <span class="toc-nav-text"><a href="#Spring&#x6846;&#x67B6;&#x4E2D;&#x7528;&#x4E86;&#x54EA;&#x4E9B;&#x8BBE;&#x8BA1;&#x6A21;&#x5F0F;" class="headerlink" title="Spring&#x6846;&#x67B6;&#x4E2D;&#x7528;&#x4E86;&#x54EA;&#x4E9B;&#x8BBE;&#x8BA1;&#x6A21;&#x5F0F;"></a>Spring&#x6846;&#x67B6;&#x4E2D;&#x7528;&#x4E86;&#x54EA;&#x4E9B;&#x8BBE;&#x8BA1;&#x6A21;&#x5F0F;</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#mybatis"><span class="toc-nav-number">7.</span> <span class="toc-nav-text"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#和的区别是什么"><span class="toc-nav-number">7.1.</span> <span class="toc-nav-text"><a href="#&#x548C;-&#x7684;&#x533A;&#x522B;&#x662F;&#x4EC0;&#x4E48;" class="headerlink" title="#{}&#x548C;${}&#x7684;&#x533A;&#x522B;&#x662F;&#x4EC0;&#x4E48;"></a>#{}&#x548C;${}&#x7684;&#x533A;&#x522B;&#x662F;&#x4EC0;&#x4E48;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#xml-映射文件中除了常见的selectinsertupdatedelete标签之外还有哪些标签"><span class="toc-nav-number">7.2.</span> <span class="toc-nav-text"><a href="#XML-&#x6620;&#x5C04;&#x6587;&#x4EF6;&#x4E2D;&#xFF0C;&#x9664;&#x4E86;&#x5E38;&#x89C1;&#x7684;select-insert-update-delete&#x6807;&#x7B7E;&#x4E4B;&#x5916;&#xFF0C;&#x8FD8;&#x6709;&#x54EA;&#x4E9B;&#x6807;&#x7B7E;" class="headerlink" title="XML &#x6620;&#x5C04;&#x6587;&#x4EF6;&#x4E2D;&#xFF0C;&#x9664;&#x4E86;&#x5E38;&#x89C1;&#x7684;select|insert|update|delete&#x6807;&#x7B7E;&#x4E4B;&#x5916;&#xFF0C;&#x8FD8;&#x6709;&#x54EA;&#x4E9B;&#x6807;&#x7B7E;"></a>XML &#x6620;&#x5C04;&#x6587;&#x4EF6;&#x4E2D;&#xFF0C;&#x9664;&#x4E86;&#x5E38;&#x89C1;&#x7684;select|insert|update|delete&#x6807;&#x7B7E;&#x4E4B;&#x5916;&#xFF0C;&#x8FD8;&#x6709;&#x54EA;&#x4E9B;&#x6807;&#x7B7E;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#通常一个-xml-映射文件都会写一个-dao-接口与之对应这个-dao-接口的工作原理是什么"><span class="toc-nav-number">7.3.</span> <span class="toc-nav-text"><a href="#&#x901A;&#x5E38;&#x4E00;&#x4E2A;-XML-&#x6620;&#x5C04;&#x6587;&#x4EF6;&#x90FD;&#x4F1A;&#x5199;&#x4E00;&#x4E2A;-Dao-&#x63A5;&#x53E3;&#x4E0E;&#x4E4B;&#x5BF9;&#x5E94;&#xFF0C;&#x8FD9;&#x4E2A;-Dao-&#x63A5;&#x53E3;&#x7684;&#x5DE5;&#x4F5C;&#x539F;&#x7406;&#x662F;&#x4EC0;&#x4E48;&#xFF1F;" class="headerlink" title="&#x901A;&#x5E38;&#x4E00;&#x4E2A; XML &#x6620;&#x5C04;&#x6587;&#x4EF6;&#x90FD;&#x4F1A;&#x5199;&#x4E00;&#x4E2A; Dao &#x63A5;&#x53E3;&#x4E0E;&#x4E4B;&#x5BF9;&#x5E94;&#xFF0C;&#x8FD9;&#x4E2A; Dao &#x63A5;&#x53E3;&#x7684;&#x5DE5;&#x4F5C;&#x539F;&#x7406;&#x662F;&#x4EC0;&#x4E48;&#xFF1F;"></a>&#x901A;&#x5E38;&#x4E00;&#x4E2A; XML &#x6620;&#x5C04;&#x6587;&#x4EF6;&#x90FD;&#x4F1A;&#x5199;&#x4E00;&#x4E2A; Dao &#x63A5;&#x53E3;&#x4E0E;&#x4E4B;&#x5BF9;&#x5E94;&#xFF0C;&#x8FD9;&#x4E2A; Dao &#x63A5;&#x53E3;&#x7684;&#x5DE5;&#x4F5C;&#x539F;&#x7406;&#x662F;&#x4EC0;&#x4E48;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#dao-接口里的方法参数不同时方法能重载吗"><span class="toc-nav-number">7.4.</span> <span class="toc-nav-text"><a href="#Dao-&#x63A5;&#x53E3;&#x91CC;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x53C2;&#x6570;&#x4E0D;&#x540C;&#x65F6;&#x65B9;&#x6CD5;&#x80FD;&#x91CD;&#x8F7D;&#x5417;&#xFF1F;" class="headerlink" title="Dao &#x63A5;&#x53E3;&#x91CC;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x53C2;&#x6570;&#x4E0D;&#x540C;&#x65F6;&#x65B9;&#x6CD5;&#x80FD;&#x91CD;&#x8F7D;&#x5417;&#xFF1F;"></a>Dao &#x63A5;&#x53E3;&#x91CC;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x53C2;&#x6570;&#x4E0D;&#x540C;&#x65F6;&#x65B9;&#x6CD5;&#x80FD;&#x91CD;&#x8F7D;&#x5417;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#mybatis-是如何进行分页的分页插件的原理是什么"><span class="toc-nav-number">7.5.</span> <span class="toc-nav-text"><a href="#MyBatis-&#x662F;&#x5982;&#x4F55;&#x8FDB;&#x884C;&#x5206;&#x9875;&#x7684;&#xFF1F;&#x5206;&#x9875;&#x63D2;&#x4EF6;&#x7684;&#x539F;&#x7406;&#x662F;&#x4EC0;&#x4E48;&#xFF1F;" class="headerlink" title="MyBatis &#x662F;&#x5982;&#x4F55;&#x8FDB;&#x884C;&#x5206;&#x9875;&#x7684;&#xFF1F;&#x5206;&#x9875;&#x63D2;&#x4EF6;&#x7684;&#x539F;&#x7406;&#x662F;&#x4EC0;&#x4E48;&#xFF1F;"></a>MyBatis &#x662F;&#x5982;&#x4F55;&#x8FDB;&#x884C;&#x5206;&#x9875;&#x7684;&#xFF1F;&#x5206;&#x9875;&#x63D2;&#x4EF6;&#x7684;&#x539F;&#x7406;&#x662F;&#x4EC0;&#x4E48;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#mybatis-执行插入操作后返回数据库主键"><span class="toc-nav-number">7.6.</span> <span class="toc-nav-text"><a href="#MyBatis-&#x6267;&#x884C;&#x63D2;&#x5165;&#x64CD;&#x4F5C;&#x540E;&#xFF0C;&#x8FD4;&#x56DE;&#x6570;&#x636E;&#x5E93;&#x4E3B;&#x952E;" class="headerlink" title="MyBatis &#x6267;&#x884C;&#x63D2;&#x5165;&#x64CD;&#x4F5C;&#x540E;&#xFF0C;&#x8FD4;&#x56DE;&#x6570;&#x636E;&#x5E93;&#x4E3B;&#x952E;"></a>MyBatis &#x6267;&#x884C;&#x63D2;&#x5165;&#x64CD;&#x4F5C;&#x540E;&#xFF0C;&#x8FD4;&#x56DE;&#x6570;&#x636E;&#x5E93;&#x4E3B;&#x952E;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#mybatis-动态-sql"><span class="toc-nav-number">7.7.</span> <span class="toc-nav-text"><a href="#MyBatis-&#x52A8;&#x6001;-sql" class="headerlink" title="MyBatis &#x52A8;&#x6001; sql"></a>MyBatis &#x52A8;&#x6001; sql</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#mybatis-是如何将-sql-执行结果封装为目标对象并返回的都有哪些映射形式"><span class="toc-nav-number">7.8.</span> <span class="toc-nav-text"><a href="#MyBatis-&#x662F;&#x5982;&#x4F55;&#x5C06;-sql-&#x6267;&#x884C;&#x7ED3;&#x679C;&#x5C01;&#x88C5;&#x4E3A;&#x76EE;&#x6807;&#x5BF9;&#x8C61;&#x5E76;&#x8FD4;&#x56DE;&#x7684;&#xFF1F;&#x90FD;&#x6709;&#x54EA;&#x4E9B;&#x6620;&#x5C04;&#x5F62;&#x5F0F;&#xFF1F;" class="headerlink" title="MyBatis &#x662F;&#x5982;&#x4F55;&#x5C06; sql &#x6267;&#x884C;&#x7ED3;&#x679C;&#x5C01;&#x88C5;&#x4E3A;&#x76EE;&#x6807;&#x5BF9;&#x8C61;&#x5E76;&#x8FD4;&#x56DE;&#x7684;&#xFF1F;&#x90FD;&#x6709;&#x54EA;&#x4E9B;&#x6620;&#x5C04;&#x5F62;&#x5F0F;&#xFF1F;"></a>MyBatis &#x662F;&#x5982;&#x4F55;&#x5C06; sql &#x6267;&#x884C;&#x7ED3;&#x679C;&#x5C01;&#x88C5;&#x4E3A;&#x76EE;&#x6807;&#x5BF9;&#x8C61;&#x5E76;&#x8FD4;&#x56DE;&#x7684;&#xFF1F;&#x90FD;&#x6709;&#x54EA;&#x4E9B;&#x6620;&#x5C04;&#x5F62;&#x5F0F;&#xFF1F;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#servlet"><span class="toc-nav-number">8.</span> <span class="toc-nav-text"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#tomcat-和-servlet-的关系-amp-工作流程"><span class="toc-nav-number">8.1.</span> <span class="toc-nav-text"><a href="#Tomcat-&#x548C;-Servlet-&#x7684;&#x5173;&#x7CFB;-amp-&#x5DE5;&#x4F5C;&#x6D41;&#x7A0B;" class="headerlink" title="Tomcat &#x548C; Servlet &#x7684;&#x5173;&#x7CFB; &amp; &#x5DE5;&#x4F5C;&#x6D41;&#x7A0B;"></a>Tomcat &#x548C; Servlet &#x7684;&#x5173;&#x7CFB; &amp; &#x5DE5;&#x4F5C;&#x6D41;&#x7A0B;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#servlet-工作原理"><span class="toc-nav-number">8.2.</span> <span class="toc-nav-text"><a href="#Servlet-&#x5DE5;&#x4F5C;&#x539F;&#x7406;" class="headerlink" title="Servlet &#x5DE5;&#x4F5C;&#x539F;&#x7406;"></a>Servlet &#x5DE5;&#x4F5C;&#x539F;&#x7406;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#servlet-的生命周期"><span class="toc-nav-number">8.3.</span> <span class="toc-nav-text"><a href="#Servlet-&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;" class="headerlink" title="Servlet &#x7684;&#x751F;&#x547D;&#x5468;&#x671F;"></a>Servlet &#x7684;&#x751F;&#x547D;&#x5468;&#x671F;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#编写一个-servlet"><span class="toc-nav-number">8.4.</span> <span class="toc-nav-text"><a href="#&#x7F16;&#x5199;&#x4E00;&#x4E2A;-Servlet" class="headerlink" title="&#x7F16;&#x5199;&#x4E00;&#x4E2A; Servlet"></a>&#x7F16;&#x5199;&#x4E00;&#x4E2A; Servlet</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#请求转发和重定向的区别"><span class="toc-nav-number">8.5.</span> <span class="toc-nav-text"><a href="#&#x8BF7;&#x6C42;&#x8F6C;&#x53D1;&#x548C;&#x91CD;&#x5B9A;&#x5411;&#x7684;&#x533A;&#x522B;" class="headerlink" title="&#x8BF7;&#x6C42;&#x8F6C;&#x53D1;&#x548C;&#x91CD;&#x5B9A;&#x5411;&#x7684;&#x533A;&#x522B;"></a>&#x8BF7;&#x6C42;&#x8F6C;&#x53D1;&#x548C;&#x91CD;&#x5B9A;&#x5411;&#x7684;&#x533A;&#x522B;</span></a></li></ol></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">标签</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#java" title="java">java</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
				<!--
                
                <hr>
                <h5>朋友们</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://tyzhang.top/" target="_blank">ztygalaxy</a></li>
                    
                        <li><a href="http://www.tangyincheng.com/" target="_blank">yctang</a></li>
                    
                        <li><a href="https://dolnw.github.io" target="_blank">JCWang</a></li>
                    
                </ul>
                
				-->
            </div>
        </div>
    </div>
</article>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: ''
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


<!-- chrome Firefox 中文锚点定位失效-->
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<!-- smooth scroll behavior polyfill  -->
<script type="text/javascript" src="/js/smoothscroll.js"></script>
<script>
        $('#toc').on('click','a',function(a){
            // var isChrome = window.navigator.userAgent.indexOf("Chrome") !== -1;
            // console.log(window.navigator.userAgent,isChrome)
                // if(isChrome) {
                    // console.log(a.currentTarget.outerHTML);
                    // console.log($(a.currentTarget).attr("href"));
                    //跳转到指定锚点
                    // document.getElementById(a.target.innerText.toLowerCase()).scrollIntoView(true);
                    document.getElementById($(a.currentTarget).attr("href").replace("#","")).scrollIntoView({behavior: 'smooth' });
                // }
        })  
</script>


    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                
				
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/songzblink">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 宋正兵 2021 
                    <br>
                    Theme by <a href="http://www.huweihuang.com">Huwei Huang</a>
                    re-Ported by <a href="https://github.com/ztygalaxy">ztygalaxy</a>
					
					<br>
                    <a href="http://www.beian.miit.gov.cn/" style="color: gray">浙ICP备2021018896号</a>
					<br>
					<!-- <p class="copyright text-muted" style="margin-top: 5px"> -->
						<img src="../../img/备案图标.png"/>
						<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null" style="color: gray">null</a>
					<!-- </p> -->
					
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("zbsong.top/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="zbsong.top/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>

</html>
