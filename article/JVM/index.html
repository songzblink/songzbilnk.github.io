<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/logo.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          JVM—内存结构、垃圾回收、类加载与字节码技术 - 宋正兵的博客 | zbsong Blog
        
    </title>

    <link rel="canonical" href="zbsong.top/article/JVM/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('https://api.dujin.org/bing/1920.php')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#java" title="java">java</a>
                            
                        </div>
                        <h1>JVM—内存结构、垃圾回收、类加载与字节码技术</h1>
                        <!-- <h2 class="subheading">JVM的内存结构、垃圾回收、类加载与字节码技术</h2> -->
                        <span class="meta">
                            宋正兵 on
                            2021-04-01
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">songzblink</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">主页</a>
                    </li>
					<li>
                        <a href="/archive/">归档</a>
                    </li>
					<li>
                        <a href="/tags/">标签</a>
                    </li>
					<li>
                        <a href="/about/">关于</a>
                    </li>
					<!--
					修改about在前面的问题
                    
                        
                    
                        
                        <li>
                            <a href="/about/">关于</a>
                        </li>
                        
                    
                        
                        <li>
                            <a href="/archive/">归档</a>
                        </li>
                        
                    
                        
                        <li>
                            <a href="/tags/">标签</a>
                        </li>
                        
                    
                    -->
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
	// querySelector 获取文档中 id="demo" 的元素
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				
                <h1 id="内存结构">内存结构</h1>
<p><img src="https://pic.tyzhang.top/images/2021/04/04/image88db7519d63eb6fe.png" alt="image88db7519d63eb6fe.png"></p>
<h2 id="程序计数器">程序计数器</h2>
<p>Program Counter Register</p>
<ul>
<li>作用：存放下一条指令所在单元的地址的地方，物理上使用寄存器来实现的</li>
<li>特点：
<ul>
<li>线程私有</li>
<li>唯一一个不会存在内存溢出的区域</li>
</ul>
</li>
</ul>
<h2 id="虚拟机栈">虚拟机栈</h2>
<p>Java Virtual Machine Stacks</p>
<ul>
<li>每个线程运行时所需要的内存，称为虚拟机栈</li>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能由一个活动栈帧，对应着当前正在执行的那个方法</li>
</ul>
<p>栈内存不需要进行垃圾回收。</p>
<p>栈内存划的大，方便更多次的方法调用，划的过大，会让线程数变少，因为物理内存是一定的。</p>
<p>方法内局部变量是线程私有的，不需要考虑线程安全，如果是公有的，需要考虑线程安全。</p>
<h3 id="线程安全">线程安全</h3>
<p>判断一个变量是不是线程安全的，不仅要看他是不是方法内的局部变量，还要看他是否逃离了方法的作用范围，如method3。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程同时执行此方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> m1&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">5000</span>; i++)&#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 线程1方法调用该方法，新建一个栈帧，每个线程私有int x作为局部变量，与其他线程不相互影响。</span></span><br><span class="line"><span class="comment">* 如果修改为static int x，线程1和线程2都要读取x自增后再写回，不加安全保护会产生线程安全问题。</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="number">4</span>);</span><br><span class="line">        sb.append(<span class="number">5</span>);</span><br><span class="line">        sb.append(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 与主线程共享sb</span></span><br><span class="line">            method2(sb);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同上，线程安全</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非线程安全，因为作为方法参数传递进来，因此可能会有其他线程访问，对其他线程共享，如main。需要使用StringBuffer。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">(StringBuilder s)</span> </span>&#123;</span><br><span class="line">        s.append(<span class="number">1</span>);</span><br><span class="line">        s.append(<span class="number">2</span>);</span><br><span class="line">        s.append(<span class="number">3</span>);</span><br><span class="line">        System.out.println(s.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">m3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="number">2</span>);</span><br><span class="line">        sb.append(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 其他线程可能拿到这个对象的引用，并发的修改。</span></span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈内存溢出">栈内存溢出</h3>
<ul>
<li>栈帧过多导致栈内存溢出</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// java.lang.StackOverflowError</span></span><br></pre></td></tr></table></figure>
<p>​	使用 <code>-Xss256k</code> 设置栈内存大小，使递归调用次数变小。</p>
<ul>
<li>栈帧过大导致栈内存溢出</li>
</ul>
<p>即该区域可能抛出以下异常：</p>
<ul>
<li>当线程请求的栈深度超过虚拟机所允许的深度，即栈帧过多，会抛出 <code>StackOverflowError</code> 异常；</li>
<li>虚拟机栈进行动态扩展时如果无法申请到足够内存，会抛出 <code>OutOfMemoryError</code> 异常。</li>
</ul>
<h3 id="线程运行诊断">线程运行诊断</h3>
<p><strong>案例1</strong> ：CPU 占用过高</p>
<p><strong>定位问题</strong></p>
<ol>
<li>
<p>使用 linux 的 top 命令定位哪个进程对 cpu 的占用过高</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 ps 查看进程的哪个线程占用率过高</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps H -eo pid,tid,%cpu | grep 进程ID</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 jstack 命令查看有问题的线程，展示的线程 ID 为十六进制，可定位到问题代码的行数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 进程ID</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>案例2</strong> ：程序运行很长时间没有结果</p>
<p>jstack 命令也能够检查出来 deadlock 死锁的存在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> A a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">static</span> B b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(a)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e,printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span>(b)&#123;</span><br><span class="line">                System.out.println(<span class="string">"我获得了a和b"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(b)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(a)&#123;&#123;</span><br><span class="line">                System.out.println(<span class="string">"我获得了a和b"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// deadlock 死锁</span></span><br><span class="line"><span class="comment">// 线程1先锁住a然后休眠2秒，在其休眠这段时间一秒后新线程2锁住了b，当线程2锁线程a时发现已经被锁了需要等待。再过一秒线程1醒过来，想要锁住线程b但是需要等待，于是死锁。</span></span><br></pre></td></tr></table></figure>
<h2 id="本地方法栈">本地方法栈</h2>
<p>Native Method Stacks，本地方法运行时候使用的内存。</p>
<p>本地方法：本地方法由其他语言如C或C++编写，编译成与处理器相关的机器代码。</p>
<p>与虚拟机栈一样，本地方法栈区域也会抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 异常。</p>
<h2 id="heap堆">Heap堆</h2>
<p>通过 new 关键字，创建对象都会使用堆内存</p>
<ul>
<li>
<p><strong>线程共享</strong>的，堆中对象都需要考虑线程安全的问题</p>
</li>
<li>
<p>有垃圾回收机制，不再被引用的对象会被回收</p>
</li>
</ul>
<p>如果在堆中没有足够的内存再去完成实例分配，并且堆也无法再扩展时，将会抛出 <code>OutofMemoryError</code> 异常。</p>
<h3 id="堆内存溢出">堆内存溢出</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String a = <span class="string">"hello"</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            list.add(a);</span><br><span class="line">            a = a + a;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// java.lang.OutofMemoryError:Java heap space</span></span><br></pre></td></tr></table></figure>
<p>可以使用 <code>-Xmx8m</code> 修改堆空间大小。</p>
<h3 id="堆内存诊断">堆内存诊断</h3>
<p><strong>jps工具</strong></p>
<p>查看当前系统中有哪些 java 进程</p>
<p><strong>jmap工具</strong></p>
<p>查看某一时刻堆内存占用情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 进程ID</span><br></pre></td></tr></table></figure>
<p><strong>jconsole工具</strong></p>
<p>是一个图形界面，多功能的监测工具，可以连续监测</p>
<h2 id="方法区">方法区</h2>
<p><img src="https://pic.tyzhang.top/images/2021/04/04/image39668280b49515ce.png" alt="image39668280b49515ce.png"></p>
<p><img src="https://pic.tyzhang.top/images/2021/04/04/image.png" alt="image.png"></p>
<p>【上面两张图的“常量池”应该是“运行时常量池”】</p>
<p>Method Area 方法区，也称非堆（Non-Heap），又是一个被<strong>线程共享</strong>的内存区域。方法区用于存放 class 的相关信息，如类名，访问修饰符，常量池，字段描述，方法描述等等。另外，方法区包含了一个特殊的区域“运行时常量池”。</p>
<p>当方法区无法满足内存分配需求时，将抛出 <code>OutOfMemoryError</code> 异常。</p>
<h3 id="方法区内存溢出">方法区内存溢出</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.8放在了元空间，1.8前放在永久代。元空间内存溢出，默认使用物理内存，不限制大小，因此默认不会看到溢出</span></span><br><span class="line"><span class="comment">// -XX:MaxMetaspaceSizer=8m 来设置元空间大小</span></span><br><span class="line"><span class="comment">// 可以用来加载类的二进制字节码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_8</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Demo1_8 test = <span class="keyword">new</span> Demo1_8();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++, j++) &#123;</span><br><span class="line">                <span class="comment">//生成类的二进制字节码</span></span><br><span class="line">                ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>); </span><br><span class="line">                <span class="comment">// 版本号，public，类名，包名，父类，接口</span></span><br><span class="line">                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">"Class"</span> + i, <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>);	</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="keyword">byte</span>[] code = cw.toByteArray();	</span><br><span class="line">                <span class="comment">// 执行类加载</span></span><br><span class="line">                test.defineClass(<span class="string">"Class"</span> + i, code, <span class="number">0</span>, code.length);	</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.8 java.lang.OutOfMemoryError:Metaspace</span></span><br><span class="line"><span class="comment">// 1.6 java.lang.OutOfMemoryError:PermGen space</span></span><br></pre></td></tr></table></figure>
<p>Java1.8使用 <code>-XX:MaxMetaspaceSizer=8m</code> 设置最大元空间大小。</p>
<p>Java1.8前使用 <code>-XX:MaxPermSize=8m</code> 设置最大元空间大小。</p>
<h3 id="场景">场景</h3>
<p>动态加载类</p>
<ul>
<li>Spring</li>
<li>MyBatis</li>
</ul>
<p>spring aop中都是使用到了cglib这类字节码的技术，动态代理的类越多，就需要越多的方法区来保证动态生成的class可以加载入到内存中去。</p>
<h3 id="运行时常量池">运行时常量池</h3>
<p><strong>常量池</strong>，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。</p>
<p><strong>运行时常量池</strong>，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址。</p>
<p>可以通过 <code>javap -v</code> 命令反编译 .class 文件查看。</p>
<h3 id="stringtable">StringTable</h3>
<h4 id="特性">特性</h4>
<p>String table 又称为 String pool，字符串常量池，其存在于堆中(jdk1.7之后改的)，hashtable 结构，不能扩容。最重要的一点，String table 中存储的并不是 String 类型的对象，存储的而是指向 String 对象的索引，真实对象还是存储在堆中。</p>
<p>String table 还存在一个 hash 表的特性，里面<strong>不存在相同的两个字符串，延迟加载遇到没见过的才加进去</strong>。</p>
<p>此外 String 对象调用 intern() 方法时，会先在 String table 中查找是否存在于该对象相同的字符串，若存在直接返回 String table 中字符串的引用，若不存在则在 String table 中创建一个与该对象相同的字符串。</p>
<ul>
<li>利用字符串常量池的机制，来避免重复创造字符串对象</li>
<li><strong>字符串变量拼接</strong>的原理是 StringBuilder（1.8）</li>
<li><strong>字符串常量拼接</strong>的原理是 编译器优化</li>
<li>可以使用 intern() 方法，主动将字符串对象尝试放入字符串常量池当中
<ul>
<li>JDK 1.8 将这个字符串对象尝试放入字符串常量池，如果字符串常量池中有则不会放入，如过没有则会放入，无论成功与否都会把串池中的对象返回</li>
<li>JDK 1.6 将这个字符串对象尝试放入字符串常量池，如果字符串常量池中有则不会放入，如过没有则会将这个字符串对象<strong>复制</strong>一份放入串池，无论成功与否都会把串池中的对象返回</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringTable ["a", "b", "ab"]  hashtable结构 不能扩容</span></span><br><span class="line"><span class="comment">// 常量池中的信息，都会被加载到运行时常量池，这时 a b ab 都是常量池中的符号，还没有变为 java 字符串对象</span></span><br><span class="line"><span class="comment">// ldc #2 会把 a 符号变为 "a" 字符串对象</span></span><br><span class="line"><span class="comment">// ldc #3 会把 b 符号变为 "b" 字符串对象</span></span><br><span class="line"><span class="comment">// ldc #4 会把 ab 符号变为 "ab" 字符串对象</span></span><br><span class="line">String s1 = <span class="string">"a"</span>; <span class="comment">// 懒惰的</span></span><br><span class="line">String s2 = <span class="string">"b"</span>;</span><br><span class="line">String s3 = <span class="string">"ab"</span>;</span><br><span class="line">String s4 = s1 + s2; <span class="comment">// new String("ab")</span></span><br><span class="line"><span class="comment">// 通过反编译可以发现s4经过了以下细节</span></span><br><span class="line"><span class="comment">// new StringBuilder().append("a").append("b").toString()</span></span><br><span class="line"><span class="comment">// toString() 方法实际是通过 new 关键字创建了一个字符串对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接在常量池寻找"ab"和s3是一样的</span></span><br><span class="line"><span class="comment">// javac 在编译期间的优化，结果已经在编译期间确定为 ab，与s4的s1s2变量不相同</span></span><br><span class="line">String s5 = <span class="string">"a"</span> + <span class="string">"b"</span>; </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(s3 == s5);</span><br><span class="line"></span><br><span class="line"><span class="comment">// s4为"ab"，而"ab"已经存在于字符串常量池当中，直接返回字符串常量池当中的"ab"的引用(和s3相同)给s6</span></span><br><span class="line"><span class="comment">// intern 用来返回常量池中的某字符串，如果常量池中已经存在该字符串，则直接返回常量池中该对象的引用。否则，在常量池中加入该对象，然后 返回引用。</span></span><br><span class="line">String s6 = s4.intern();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(s3 == s6);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String x2 = <span class="keyword">new</span> String(<span class="string">"c"</span>) + <span class="keyword">new</span> String(<span class="string">"d"</span>);</span><br><span class="line"><span class="comment">// StringTable ["c", "d"]</span></span><br><span class="line"><span class="comment">// 堆 new String("cd")</span></span><br><span class="line"></span><br><span class="line">String x1 = <span class="string">"cd"</span>;</span><br><span class="line"><span class="comment">// StringTable ["c", "d", "cd"]</span></span><br><span class="line"><span class="comment">// 堆 new String("cd")</span></span><br><span class="line"></span><br><span class="line">x2.intern();<span class="comment">//  StringTable中已经有了，入池失败</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(x1 == x2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果将两行语句调换 1.8</span></span><br><span class="line">String x2 = <span class="keyword">new</span> String(<span class="string">"c"</span>) + <span class="keyword">new</span> String(<span class="string">"d"</span>); <span class="comment">// 堆中</span></span><br><span class="line">x2.intern(); <span class="comment">// 池中没有，入池成功</span></span><br><span class="line">String x1 = <span class="string">"cd"</span>; <span class="comment">// 常量池中有，直接取出来</span></span><br><span class="line">System.out.println(x1 == x2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 1.6中副本入池，x2仍然是堆中cd，不等</span></span><br></pre></td></tr></table></figure>
<h4 id="存放位置">存放位置</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 8下设置 -Xmx10m -XX:UseGCOvereadLimit</span></span><br><span class="line"><span class="comment">// JDK 6下设置 -XX:MaxPermSize=10m</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;~&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; <span class="number">26000</span>; j++)&#123;</span><br><span class="line">                list.add(String.valueOf(j).intern());</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwsable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.6 OutOfMemory: PerGen space</span></span><br><span class="line"><span class="comment">// 1.8 OutOfMemory: Heap space</span></span><br></pre></td></tr></table></figure>
<p>在 JDK 1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区，此时 hotspot 虚拟机对方法区的实现为永久代</p>
<p>在 JDK 1.7 字符串常量池被从方法区拿到了堆中，这里没有提到运行时常量池，也就是说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区，也就是hotspot中的永久代</p>
<p>在 JDK 1.8 hotspot 移除了永久代用元空间（Metaspace）取而代之，这时候字符串常量池还在堆，运行时常量池还在方法区，只不过方法区的实现从永久代变成了元空间（Metaspace）</p>
<h4 id="垃圾回收">垃圾回收</h4>
<p>当内存不足时，StringTable 中那些没有被引用的字符串仍然会被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                String.valueOf(i).intern();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [GC (Allocation Failure) [PSYoungGen: 2048K-&gt;504K(2560K)] 2048K-&gt;664K(9728K), 0.0016202 secs] [Times: user=0.03 sys=0.02, real=0.00 secs]</span></span><br></pre></td></tr></table></figure>
<h3 id="性能调优">性能调优</h3>
<ol>
<li>
<p>调整 hash 桶的个数。如果系统里字符串常量非常多，可以适当调大</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置桶大小 -XX:StringTable=桶个数</span></span><br><span class="line"><span class="comment">// -XX:StringTable=20000 -XX:PrintStringTableStatistics</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader reader =</span><br><span class="line">                <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"linux.words"</span>), <span class="string">"utf-8"</span>))) &#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                line = reader.readLine();</span><br><span class="line">                <span class="keyword">if</span> (line == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                line.intern();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"cost"</span> + (System.nanoTime() - start) / <span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 200000 401ms</span></span><br><span class="line"><span class="comment">// 1009	12000ms</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>考虑将字符串对象是否入池。如果应用里有大量的字符串而且可能会重复，则可以考虑让字符串入池减少堆内存个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        List&lt;String&gt; address = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> (BufferedReader reader =</span><br><span class="line">                    <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                            <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"linux.words"</span>), <span class="string">"utf-8"</span>))) &#123;</span><br><span class="line">                String line = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    line = reader.readLine();</span><br><span class="line">                    <span class="keyword">if</span> (line == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// address.add(line); // 防止垃圾回收</span></span><br><span class="line">                    address.add(line.intern()); <span class="comment">// 做一个入池动作，将串池内的加入到list，外的被垃圾回收掉</span></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"cost"</span> + (System.nanoTime() - start) / <span class="number">1000000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="垃圾回收">垃圾回收</h1>
<h2 id="如何判断对象可以回收">如何判断对象可以回收</h2>
<h3 id="引用计数法">引用计数法</h3>
<p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。</p>
<p>判定效率高，但两个对象相互引用会导致内存泄漏，环形数据。</p>
<h3 id="可达性分析算法">可达性分析算法</h3>
<p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说，就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。</p>
<p>如下图，对象 object 5、object 6、object 7 虽然互相有关联，但是它们到 GC Roots 是不可达的，所以它们将会被判定为是可回收的对象。</p>
<p><img src="https://pic.tyzhang.top/images/2021/04/05/image.png" alt="image.png"></p>
<p>在 Java 语言中，可作为 GC Roots 的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li>
</ul>
<p>Memory Analyzer(MAT) 由 Eclipse 提供的 java 堆分析工具。</p>
<h2 id="四种引用">四种引用</h2>
<h3 id="强引用">强引用</h3>
<p>强引用就是指在程序代码之中普遍存在的，类似 <code>Object obj=new Object()</code> 这类的引用。只有所有 GC Roots 对象都不通过强引用引用该对象，该对象才能被垃圾回收。</p>
<h3 id="软引用">软引用</h3>
<p>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次触发垃圾回收，回收软引用对象。</p>
<p>软引用是通过 SoftReference 类实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference softObj = <span class="keyword">new</span> SoftReference(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">// 去除强引用</span></span><br></pre></td></tr></table></figure>
<p>这样就是一个简单的软引用使用方法，可以通过 get() 方法获取对象。当 JVM 认为内存空间不足时，就会去试图回收软引用指向的对象，也就是说在 JVM 抛出 <code>OutOfMemoryError</code> 之前，会去清理软引用对象。</p>
<p>软引用可以与引用队列（ReferenceQueue）联合使用，用来释放软引用自身。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">SoftReference softObj = <span class="keyword">new</span> SoftReference(obj, queue);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">// 去除强引用</span></span><br></pre></td></tr></table></figure>
<p>当 softObj 软引用的 obj 被 GC 回收之后，softObj 对象就会被塞到 queue 中，之后我们可以通过这个队列的 poll() 来检查你关心的对象是否被回收了，如果队列为空，就返回一个null；否则就返回软引用对象，也就是 sofObj。</p>
<blockquote>
<p>软引用一般用来实现内存敏感的缓存，如果有空闲内存就可以保留缓存，当内存不足时就清理掉，这样就保证使用缓存的同时不会耗尽内存。例如图片缓存框架中缓存图片就是通过软引用的。</p>
</blockquote>
<p><strong>举例：</strong> byte[] 数组缓存举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-Xmx20m -XX:+PrintGCDetails -verbose:gc*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">soft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// List --&gt; SoftReference --&gt; byte[]</span></span><br><span class="line">        List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"循环结束"</span> + list.size());</span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// OutOfMemoryError: Java heap space</span></span><br><span class="line">        <span class="comment">// List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; 5; i++) &#123;</span></span><br><span class="line">            <span class="comment">// list.add(new byte[_4MB]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 改为弱引用</span></span><br><span class="line">        soft();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三次循环GC一次，第四次GC后仍然不够，再触发一次新的GC，回收软引用。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">循环结束5</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">[B@677327b6</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<p><strong>举例：</strong> 使用引用队列清理软引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-Xmx20m -XX:+PrintGCDetails -verbose:gc*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">soft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 引用队列</span></span><br><span class="line">        ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 关联了引用队列，当软引用所关联的byte[]被回收时，软引用自己会加入到queue中去</span></span><br><span class="line">            SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB], queue);</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从队列中获取无用的软引用对象，并移除</span></span><br><span class="line">        Reference&lt;? extends <span class="keyword">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">        <span class="keyword">while</span> (poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.remove(poll);</span><br><span class="line">            poll = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"循环结束"</span> + list.size());</span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        soft();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">循环结束1</span></span><br><span class="line"><span class="comment">[B@677327b6</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<h3 id="弱引用">弱引用</h3>
<p>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象。</p>
<p>弱引用可以通过 WeakReference 类实现的，它的生命周期比软引用还要短，也是通过 get() 方法获取对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; weakObj = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">// 去除强引用</span></span><br></pre></td></tr></table></figure>
<p>同样也可以配合 ReferenceQueue 使用，也同样适用于内存敏感的缓存。 ThreadLocal 中的 key 就用到了弱引用。</p>
<h3 id="虚引用">虚引用</h3>
<p>也称为幽灵引用或者幻影引用。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p>
<p>虚引用可以通过 PhantomReference 类实现，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference&lt;Object&gt; phantomObj = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj, queue);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">// 去除强引用</span></span><br></pre></td></tr></table></figure>
<p>无法通过虚引用访问对象的任何属性或者函数。虚引用仅仅只是提供了一种确保对象被 finalize 以后来做某些事情的机制。</p>
<p>虚引用必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存。</p>
<h3 id="终结器引用了解">终结器引用（了解）</h3>
<p>即使在可达性分析算法中不可达的对象，也并非时“非死不可”的。对于终结器引用对象，需要经历两次标记过程：</p>
<ol>
<li>
<p>如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法</p>
<p>虚拟机将这两种情况都视为“没有必要执行”：</p>
<ul>
<li>当对象没有覆盖 finalized() 方法</li>
<li>finalize() 方法已经被虚拟机调用过</li>
</ul>
</li>
<li>
<p>如果对象被判定为有必要执行 finalized() 方法，那么这个对象将会被放置在一个叫做 F-Queue 的队列之中，并在稍后由一个虚拟机自动创建、低优先级的 Finalizer 线程去执行它（不保证会等待它执行结束）。此时它还有机会在 finalized() 方法中去拯救自己（重新与引用链上的任何一个对象关联即可），如果它没有拯救自己，将会在第二次标记时被移除队列，面临被 GC 回收。</p>
</li>
</ol>
<p>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象。</p>
<h2 id="垃圾回收算法">垃圾回收算法</h2>
<h3 id="标记清除">标记清除</h3>
<p>“标记-清除”（Mark-Sweep）算法，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。<strong>它的标记过程其实就是前面的可达性分析算法中判定垃圾对象的标记过程。</strong></p>
<p>缺点：</p>
<ul>
<li>标记和清除两个过程的效率都不高。</li>
<li>标记清除之后会产生大量不连续的内存碎片，内存碎片太多会导致<strong>以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</strong>。</li>
</ul>
<h3 id="复制">复制</h3>
<p>复制（Copying）收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。<strong>当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉</strong>。</p>
<ul>
<li>每次只对一块内存进行回收，运行高效</li>
<li>只需移动栈顶指针，按顺序分配内存即可，实现简单</li>
<li>内存回收时不用考虑内存碎片的出现</li>
</ul>
<p>缺点：可一次性分配的<strong>最大内存缩小了一半</strong>。</p>
<p>复制收集算法比较适合新生代，在老年代中，对象存活率比较高，会执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如“标记-整理”算法。</p>
<h3 id="标记整理">标记整理</h3>
<p>“标记-整理”（Mark-Compact）算法，标记过程和“标记-清除”算法一样，但后续不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<ul>
<li>没有内存碎片，但是效率比较慢</li>
</ul>
<h2 id="分代垃圾回收">分代垃圾回收</h2>
<p>“分代收集”（Generational Collection）算法，根据对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。当前的商业虚拟机的垃圾收集都采用该算法。</p>
<p>在新生代中，每次垃圾回收时都会发现有大批对象死去，只有少量存活。选用复制算法，只需要付出少量存活对象的复制成本就可以完成垃圾回收。</p>
<p>而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p>
<h4 id="新生代">新生代</h4>
<p>主要用来存放新生的对象。一般占据堆的 1/3 空间，由于频繁创建对象，所以新生代会频繁地触发 Minor GC 进行垃圾回收。</p>
<p>尽管新生代采用“复制”算法，但是新生代中的对象绝大部分都是“朝生夕死”的，所以并不需要按照 1:1 的比例来划分内存空间。而是将内存空间划分为<strong>伊甸园（Eden）</strong>、<strong>幸存区From（SurvivorFrom）</strong>、**幸存区To（SurviviorTo）**三个空间，默认比例是 <code>8:1:1</code>。</p>
<p>对象首先分配在伊甸园，当新生代空间不足时，触发 Minor GC，将伊甸园和幸存区From存活的对象使用“复制”算法复制到幸存区To中，然后让存活的对象<strong>年龄+1</strong>，并且<strong>交换</strong>幸存区From和幸存区To的<strong>指针</strong>。当某个对象年龄达到年龄阈值（默认值、最大值为15，4bit）时，就会把它们晋升到老年代中。在新生代中进行 GC 时，有可能遇到幸存区To空间没有足够空间存放新生代存活下来的对象，这些对象将通过<strong>分配担保机制</strong>（Handle Promotion，就像是去银行借贷）进入老年代。当老年代空间不足时，先尝试 Minor GC，如果还不足则触发 Full GC。</p>
<p>GC 会引发 Stop the world，停顿所有 Java 执行线程，确保可达性分析过程中引用（全局性引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表））关系的一致性。</p>
<p>一个线程内的 OOM 不会导致整个Java的线程结束。OOM 会清空线程占用的堆内存。</p>
<h2 id="相关vm参数">相关VM参数</h2>
<table>
<thead>
<tr>
<th>含义</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>堆初始大小</td>
<td><code>-Xms</code></td>
</tr>
<tr>
<td>堆最大大小</td>
<td><code>-Xmx</code> 或者 <code>-XX:MaxHeapSize=size</code></td>
</tr>
<tr>
<td>新生代大小</td>
<td><code>-Xmn</code> 或（<code>-XX:NewSize=size+XX:MaxNewSize=size</code>）</td>
</tr>
<tr>
<td>幸存区比例(动态)</td>
<td><code>-XX:InitialSurvivorRadio=radio</code> 和 <code>-XX:+UserAdaptiveSizePolicy</code></td>
</tr>
<tr>
<td>幸存区比例</td>
<td><code>-XX:SurvivorRadio=radio</code></td>
</tr>
<tr>
<td>晋升阈值</td>
<td><code>-XX:MaxTenuringThreshold=threshold</code></td>
</tr>
<tr>
<td>晋升详情</td>
<td><code>-XX:+PrintTenuringDistribution</code></td>
</tr>
<tr>
<td>GC详情</td>
<td><code>-XX:+PrintGCDetails -verbose:gc</code></td>
</tr>
<tr>
<td>Full GC前MinorGC</td>
<td><code>-XX:+ScavengeBeforeFullGC</code></td>
</tr>
</tbody>
</table>
<h2 id="理解gc日志">理解GC日志</h2>
<p>每一种收集器的日志形式都是由它们自身的实现所决定的但虚拟机设计者为了方便用户阅读，将各个收集器的日志都维持一定的共性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">33.125: [GC [DefNew:3324K-&gt;152K(3712K), 0.0025925 secs] 3324K-&gt;152K(11904K), 0.0031680 secs]</span><br><span class="line">100.667: [Full GC [Tenured:0K-&gt;210K(10240K), 0.0149142 secs] 4603K-&gt;210K(19456K), [Perm:2999K-&gt;2999K(21248K)], 0.0150007 secs][Times:user=0.01 sys=0.00, real=0.02 secs]</span><br></pre></td></tr></table></figure>
<p>最前面的数字“33.125:”和“100.667:”代表了 GC 发生的时间，这个数字的含义是从 Java 虚拟机启动以来经过的秒数。</p>
<p>GC 日志开头的 “[GC”和“[Full GC”说明了这次垃圾回收的停顿类型。如果有“Full”说明这次 GC 是发生了 Stop-The-World的。</p>
<p>“[DefNew”、“[Tenured”、“[Perm”表示 GC 发生的区域，这里显示的区域名称与使用的 GC 收集器是密切相关的。例如上面样例所使用的 Serial 收集器中新生代名为“Default New Generation”，所以显示的是“[DefNew&quot;，如果是 ParNew 收集器，新生代名称就会变为“[ParNew”。</p>
<p>后面方括号内部“3324K-&gt;152K(3712K)”含义是“GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量(该内存区域总容量)”。而方括号之外的“3324K-&gt;152K(11904K)”表示“GC前Java堆已使用容量-&gt;GC后Java堆已使用容量(Java堆总容量)”。</p>
<p>再往后，“0.0025925 secs”表示该内存区域 GC 所占用的时间，单位是秒。</p>
<h2 id="垃圾回收器">垃圾回收器</h2>
<p>7 种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。</p>
<p><img src="JVM/image-20210407210645337.png" alt="image-20210407210645337"></p>
<h3 id="串行serialgc">串行SerialGC</h3>
<ul>
<li>单线程</li>
<li>适合堆内存较小的客户端模式使用</li>
<li>新生代内存不足发生的垃圾回收 - Minor GC</li>
<li>老年代内存不足发生的垃圾回收 - Full GC</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UserSerialGC=Serial+SerialOld</span><br><span class="line"># Serial “复制”算法</span><br><span class="line"># SerialOld 工作在老年代，“标记-整理”算法</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.tyzhang.top/images/2021/04/07/image.png" alt="image.png"></p>
<h3 id="吞吐量优先parallelgc">吞吐量优先ParallelGC</h3>
<ul>
<li>多线程</li>
<li>堆内存较大，多核CPU支持</li>
<li>让单位时间内，STW时间最短</li>
<li>新生代内存不足发生的垃圾回收 - Minor GC</li>
<li>老年代内存不足发生的垃圾回收 - Full GC</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC ~ -XX:+UseParallelOldGC</span><br><span class="line"># Parallel 新生代 “复制”算法</span><br><span class="line"># ParallelOld 老年代 “标记-整理”算法</span><br><span class="line">-XX:+UseAdaptiveSizePolicy # 采用自适应新生代大小调整策略</span><br><span class="line">-XX:GCTimeRatio=ratio	# 调整吞吐量目标（垃圾回收时间与总时间占比，1/（1+radio）），一般设置为19</span><br><span class="line">-XX:MaxGCPauseMillis=ms	# 最大暂停毫秒数，默认是200，与上一个参数是冲突的</span><br><span class="line">-XX:ParallelGCThreads=n	# 控制运行时线程数</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.tyzhang.top/images/2021/04/07/imagee3d4c84df195ec48.png" alt="imagee3d4c84df195ec48.png"></p>
<h3 id="响应时间优先-cms">响应时间优先 CMS</h3>
<ul>
<li>多线程</li>
<li>堆内存较大，多核CPU支持</li>
<li>尽可能让STW单次时间最短</li>
<li>新生代内存不足发生的垃圾回收 - Minor GC</li>
<li>老年代内存不足发生的垃圾回收
<ul>
<li>若 CMS 回收垃圾的速度能高于新产生垃圾的速度，那么是属于 并发回收 的阶段，不会产生 Full GC</li>
<li>反之则会退化为 SerialOld回收器，产生 Full GC</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld</span><br><span class="line"># ParNew 新生代 “复制”算法</span><br><span class="line"># CMS 老年代 “标记-清除”算法，但是当CMS失效时，会退化采用SerialOld来进行垃圾回收</span><br><span class="line">-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads	# 一般设置为并行线程数量的1/4</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=percent	# 执行CMS垃圾回收的内存占比，预留空间给浮动垃圾（在垃圾回收过程中其他用户线程产生的新垃圾）</span><br><span class="line">-XX:+CMSScavengeBeforeRemark	# 在重新标记之前对新生代垃圾做一次回收工作，将来扫描对象就少，减轻回收压力</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.tyzhang.top/images/2021/04/07/image9132a69296b13538.png" alt="image9132a69296b13538.png"></p>
<p>缺点：</p>
<ul>
<li>CMS 回收器对 CPU 资源非常敏感。</li>
<li>CMS 回收器无法处理浮动垃圾，可能出现 “Concurrent Mode Failure” 失败而导致一次 Full GC 的产生。
<ul>
<li>浮动垃圾：由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次回收中处理掉它们，只好留待下一次 GC 时再清理掉，这部分垃圾就被称为浮动垃圾。</li>
<li></li>
</ul>
</li>
<li>CMS 使用“标记-清除”算法，会产生空间碎片问题。</li>
</ul>
<p><img src="https://pic.tyzhang.top/images/2021/04/07/imagee2a1c1115b2b2329.png" alt="imagee2a1c1115b2b2329.png"></p>
<h3 id="g1">G1</h3>
<p>Garbage First</p>
<ul>
<li>同时注重吞吐量和低延迟，默认暂停目标是200ms。</li>
<li>超大堆内存，会将堆划分为多个大小相等的Region，新生代和老年代不再是物理隔离的，它们都是一部分 Region（不需要连续）的集合。</li>
<li>整体上是“标记-整理”算法，两个区域之间是复制算法。</li>
<li>新生代内存不足发生的垃圾回收 - Minor GC</li>
<li>老年代内存不足发生的垃圾回收
<ul>
<li>若 并行回收垃圾的速度能高于新产生垃圾的速度，那么是属于并行回收的阶段，不会产生 Full GC</li>
<li>反之则会退化为 串行 回收器，产生 Full GC</li>
</ul>
</li>
</ul>
<p><strong>相关JVM参数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br><span class="line">-XX:G1HeapRegionSize=size</span><br><span class="line">-XX:MacGCPauseMills=time</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.tyzhang.top/images/2021/04/07/image71e588def6468222.png" alt="image71e588def6468222.png"></p>
<p>G1 回收器会跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的回收时间，优先回收价值最大的 Region。这也是 Garbage-First 名称的又来。</p>
<ul>
<li>初始标记阶段仅仅只是标记一下 GC Roots 能直接关联到的对象</li>
<li>并发标记阶段是从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象</li>
<li>最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录</li>
<li>筛选回收阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划</li>
</ul>
<p><strong>跨代引用时如何避免全堆扫描</strong></p>
<p>在 G1 回收器中，Region 之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用 Remembered Set 来避免全堆扫描的。</p>
<p>G1 中每个 Region 都有一个与之对应的 Remembered Set，虚拟机发现程序对 Reference 类型的数据进行写操作时，会产生一个写屏障暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，就通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 之中。</p>
<p>当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。</p>
<blockquote>
<p>CardTable 把 Region 分为一个一个的小表格，记录老年代中哪些区域存在跨代引用，存在的被称为脏卡区域。</p>
</blockquote>
<h2 id="内存分配与回收策略">内存分配与回收策略</h2>
<h3 id="对象优先在伊甸园区分配">对象优先在伊甸园区分配</h3>
<p>大多数情况下，对象在新生代伊甸园区中分配。当伊甸园区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p>
<ul>
<li>新生代 GC（Minor GC）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</li>
<li>老年代 GC（Major GC/Full GC）：指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。Major GC 的速度一般会比 Minor GC 慢 10 倍以上。</li>
</ul>
<h3 id="大对象直接进入老年代">大对象直接进入老年代</h3>
<p>所谓的大对象是指，需要大量连续内存空间的 Java 对象。经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。虚拟机提供了一个 <code>-XX：PretenureSizeThreshold</code> 参数，令大于这个设置值的对象直接在老年代分配，避免在伊甸园区及两个幸存区之间发生大量的内存复制。</p>
<blockquote>
<p><code>PretenureSizeThreshold</code> 参数只对 Serial 和 ParNew 两款回收器有效。</p>
</blockquote>
<h3 id="长期存活的对象将进入老年代">长期存活的对象将进入老年代</h3>
<p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在伊甸园区出生，并经过第一次 Minor GC 后仍然存活，并且能被幸存区容纳的话，将被移动到另一块幸存区空间中，并且对象年龄设为1。</p>
<p>对象在幸存区中每“熬过”一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就<br>
将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 <code>-XX：MaxTenuringThreshold</code>设置，最大为 15。</p>
<h3 id="动态对象年龄判定">动态对象年龄判定</h3>
<p>如果在幸存区空间中<strong>相同年龄</strong>所有对象<strong>大小的总和</strong>大于幸存区空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 <code>MaxTenuringThreshold</code> 中要求的年龄。</p>
<h3 id="空间分配担保">空间分配担保</h3>
<p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC。</p>
<p>冒险：新生代使用复制收集算法，但为了内存利用率，只使用其中一个幸存区空间来作为轮换备份。当出现大量对象在 Minor GC 后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把幸存区无法容纳的对象直接进入老年代。</p>
<h2 id="垃圾回收调优">垃圾回收调优</h2>
<p>显示所有VM相关参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:PrintFlagsFinal -version | findstr &quot;GC&quot;</span><br></pre></td></tr></table></figure>
<p>调优跟应用、环境有关，没有放之四海而皆准的法则。</p>
<h3 id="调优领域">调优领域</h3>
<ul>
<li>内存</li>
<li>锁竞争</li>
<li>CPU 占用</li>
<li>IO</li>
</ul>
<h3 id="确定目标">确定目标</h3>
<p>根据【低延迟】还是【高吞吐量】，选择合适的回收器</p>
<ul>
<li>低延迟：CMS，G1，ZGC</li>
<li>高吞吐量：ParallelGC</li>
</ul>
<h3 id="最快的gc是不发生gc">最快的GC是不发生GC</h3>
<p>查看 Full GC 前后的内存占用，考虑以下几个问题：</p>
<ul>
<li>数据是不是太多？
<ul>
<li>resultSet = statement.executeQuery(“select * from 大表”)，应该添加 limit 限制，即进行分页查询操作，限制查询出来数据的大小，防止表中数据爆炸。</li>
</ul>
</li>
<li>数据表示是否太臃肿？
<ul>
<li>对象图（对象相关信息全都查出来了），应该要什么查什么，避免对堆内存造成不必要的浪费。</li>
<li>对象大小</li>
</ul>
</li>
<li>是否存在内存泄漏？
<ul>
<li><code>static Map map =</code> 静态的map对象不断地向它添加对象，会造成OOM</li>
<li>解决方法：软引用、弱引用、第三方缓存实现比如redis等</li>
</ul>
</li>
</ul>
<h3 id="新生代调优">新生代调优</h3>
<p>1）新生代的特点</p>
<ul>
<li>所有的 new 操作的内存分配非常廉价
<ul>
<li>TLAB thread-local allocation buffer，每个线程都会在伊甸园中分配一块私有的区域，即TLAB。如果启动了本地线程分配缓存，当 new 一个对象的时候，会优先检查该区域内有没有足够的空间，如果有则在这块区域中给对象分配内存。</li>
</ul>
</li>
<li>死亡对象的回收代价是零</li>
<li>大部分对象用过即死</li>
<li>Minor GC 的时间远远低于 Full GC</li>
</ul>
<p>2）新生代理想大小</p>
<p>并不是越大越好，太大会导致原本用完即死的对象一直停留在内存中，等到新生代内存不足触发 GC 时才会被回收。</p>
<ul>
<li>新生代能容纳所有【并发量 *（请求响应）】的数据</li>
<li>幸存区大到能保留【当前活跃对象 + 需要晋升对象】</li>
<li>晋升阈值配置得当，让长时间存活的对象尽快晋升
<ul>
<li>-XX:MaxTenuringThreshold=threshold，调整最大晋升阈值</li>
<li>-XX:+PrintTenuringDistribution，打印晋升详细信息</li>
</ul>
</li>
</ul>
<h3 id="老年代调优">老年代调优</h3>
<p>以 CMS 为例</p>
<ul>
<li>CMS 的老年代内存越大越好</li>
<li>先尝试不做调优，如果没有 Full GG，那么说明老年代空间很充裕，否则先尝试调优新生代</li>
<li>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大1/4~1/3
<ul>
<li>-XX:CMSInitiatingOccupanyFraction=percent，控制老年代在空间占用多少的时候进行垃圾回收。</li>
</ul>
</li>
</ul>
<h3 id="案例">案例</h3>
<ul>
<li>
<p>Full GC 和 Minor GC 频繁</p>
<p>GC 频繁说明空间紧张。如果是新生代紧张，被塞满，幸存区空间紧张，导致空间晋升阈值降低，老年代存了很多生存周期短的对象，进而触发了 Full GC。先试着增大新生代内存，增大幸存区空间和晋升阈值。</p>
</li>
<li>
<p>请求高峰期发生 Full GC，单次暂停时间特别长（CMS）</p>
<p>因为业务需求需要低延迟，所以选择了 CMS。查看 GC 日志 CMS 的哪个阶段耗时较长。比较慢的一般在重新标记阶段，耗时比较长，因为 CMS 要扫描整个堆内存。设置在重新标记前先做一次新生代回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CMSScavengeBeforeRemark</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>老年代充裕情况下，发生 Full GC（CMS 假设使用 jdk 1.7）</p>
<p>1.7 及以前使用永久代作为方法区，1.8 使用元空间。永久代空间不足也会导致 Full GC，所以扩大永久代空间。（1.8 后元空间的垃圾回收不由 Java 控制？）</p>
</li>
</ul>
<h1 id="虚拟机性能监控与故障处理工具">虚拟机性能监控与故障处理工具</h1>
<p>给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用知识处理数据的手段。这里说的数据包括：运行日志、异常堆栈、GC 日志、线程快照（threaddump/javacore 文件）、堆转储快照（heapdump/hprof 文件）等。经常使用适当的虚拟机监控和分析的工具可以加快我们分析数据、定位解决问题的速度，但在学习工具前，也应<br>
当意识到工具永远都是知识技能的一层包装，没有什么工具是“秘密武器”，不可能学会了就能包治百病。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>主要作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>jps</td>
<td>JVM Process Status Tool，显示指定系统内所有的 HotSpot 虚拟机进程</td>
</tr>
<tr>
<td>jstat</td>
<td>JVM Statistics Monitoring Tool，用于收集 HotSpot 虚拟机各方面的运行数据</td>
</tr>
<tr>
<td>jinfo</td>
<td>Configuration Info for Java，显示虚拟机配置信息</td>
</tr>
<tr>
<td>jmap</td>
<td>Memory Map for Java，生成虚拟机的内存转储快照（heapdump 文件）</td>
</tr>
<tr>
<td>jhat</td>
<td>JVM Heap Dump Browser，用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果</td>
</tr>
<tr>
<td>jstack</td>
<td>Stack Trace for Java，显示虚拟机的线程快照</td>
</tr>
</tbody>
</table>
<h1 id="类加载与字节码技术">类加载与字节码技术</h1>
<p><img src="https://pic.tyzhang.top/images/2021/04/10/image.png" alt="image.png"></p>
<h2 id="类文件结构">类文件结构</h2>
<p>根据 JVM 规范的规定，Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，这种数据只有两种数据类型：无符号数和表。</p>
<p>无符号数属于基本的数据类型，以 <code>u1</code>、<code>u2</code>、<code>u4</code>、<code>u8</code> 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数。无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构造字符串值。</p>
<p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型。所有表都习惯性地以 <code>_info</code> 结尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;<span class="comment">// 魔数</span></span><br><span class="line">    u2             minor_version;<span class="comment">// 次版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">// 主版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">// 常量池容量计数值</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">// 常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">// 访问标志</span></span><br><span class="line">    u2             this_class;<span class="comment">// 类索引</span></span><br><span class="line">    u2             super_class;<span class="comment">// 父类索引</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">// 接口索引计数值</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">// 接口索引集合</span></span><br><span class="line">    u2             fields_count;<span class="comment">// 字段表计数值</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">// 字段表集合</span></span><br><span class="line">    u2             methods_count;<span class="comment">// 方法表计数值</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">// 方法表集合</span></span><br><span class="line">    u2             attributes_count;<span class="comment">// 属性表计数值</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">// 属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们以下面的 Java 程序为例来分析 Class 文件的结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.zbsong.clazz;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面的代码使用 JDK 8 以上编译输出 Class 文件为基础来进行分析。</p>
<p>命令：<code>javac .\TestClass.java</code></p>
<p>得到文件 <code>TestClass.class</code>，在 sublime 中打开内容如下：（注意，正常情况下偏移地址应该是8位，这里只标记出来4位是为了页面能够容下信息）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">offset  0 1  2 3  4 5  6 7  8 9  A B  C D  E F</span><br><span class="line">0000    cafe babe 0000 0038 0013 0a00 0400 0f09</span><br><span class="line">0010    0003 0010 0700 1107 0012 0100 016d 0100</span><br><span class="line">0020    0149 0100 063c 696e 6974 3e01 0003 2829</span><br><span class="line">0030    5601 0004 436f 6465 0100 0f4c 696e 654e</span><br><span class="line">0040    756d 6265 7254 6162 6c65 0100 0369 6e63</span><br><span class="line">0050    0100 0328 2949 0100 0a53 6f75 7263 6546</span><br><span class="line">0060    696c 6501 000e 5465 7374 436c 6173 732e</span><br><span class="line">0070    6a61 7661 0c00 0700 080c 0005 0006 0100</span><br><span class="line">0080    1a74 6f70 2f7a 6273 6f6e 672f 636c 617a</span><br><span class="line">0090    7a2f 5465 7374 436c 6173 7301 0010 6a61</span><br><span class="line">00A0    7661 2f6c 616e 672f 4f62 6a65 6374 0021</span><br><span class="line">00B0    0003 0004 0000 0001 0002 0005 0006 0000</span><br><span class="line">00C0    0002 0001 0007 0008 0001 0009 0000 001d</span><br><span class="line">00D0    0001 0001 0000 0005 2ab7 0001 b100 0000</span><br><span class="line">00E0    0100 0a00 0000 0600 0100 0000 0200 0100</span><br><span class="line">00F0    0b00 0c00 0100 0900 0000 1f00 0200 0100</span><br><span class="line">0100    0000 072a b400 0204 60ac 0000 0001 000a</span><br><span class="line">0110    0000 0006 0001 0000 0005 0001 000d 0000</span><br><span class="line">0120    0002 000e</span><br></pre></td></tr></table></figure>
<h3 id="1-魔数magic">1. 魔数magic</h3>
<p>每个 Class 文件的头 4 个字节称为魔数（Magic NUmber），它的唯一作用是确定这个文件是否为一个能够被虚拟机接受的 Class 文件。</p>
<p>Java 文件的魔数的值为：<code>0xCAFEBABE</code>，观察 TestClass.class 文件中的头 4 个字节</p>
<p><span style="color:red">cafe babe</span> 0000 0038 0013 0a00 0400 0f09</p>
<p>能够印证我们的观点。</p>
<h3 id="2-class文件的版本">2. Class文件的版本</h3>
<p>紧接着魔数的 4 个字节存储的是 Class 文件的版本号：第 5  和第 6 个字节为次版本号（Minor Version），第 7 和第 8 个字节是主版本号（Major Version）。</p>
<p>观察 TestClass.class 文件的第 5 ~ 8 个字节</p>
<p>cafe babe <span style="color:red">0000 0038 </span> 0013 0a00 0400 0f09</p>
<p>我电脑安装的是 JDK 12，所以主版本号是 <code>0x0038</code>（十六进制，转换十进制为 56），如果是 JDK 8 的话，主版本号应该是 0x0034（十六进制，转换十进制为 52）。</p>
<p>具体对应关系可以上网搜索。</p>
<h3 id="3-常量池">3. 常量池</h3>
<p>紧接着主次版本号之后的是常量池入口。常量池可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项目之一，同时它还是在 Class 文件中第一个出现的表类型数据项目。</p>
<p>常量池包含两个部分：</p>
<ol>
<li>常量池容量计数值（constant_pool_count），u2 类型</li>
<li>常量池（constant_pool），cp_info 表类型</li>
</ol>
<p>常量池容量计数从 1 开始计数， 把第 0 项常量空出来的目的是：满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义。</p>
<p>观察 TestClass.class 文件的常量池容量（偏移地址：0x0000 0008）</p>
<p>cafe babe 0000 0038  <span style="color:red">0013</span>  0a00 0400 0f09</p>
<p>0x0013（十六进制，转换十进制为 19）这代表常量池中有 19 项常量，索引值范围为 1~19。</p>
<p>常量池中主要存放两大类常量：</p>
<ul>
<li>
<p>字面量（Literal）</p>
<p>接近于 Java 语言层面的常量概念，如文本字符串、声明为 final 的常量值等。</p>
</li>
<li>
<p>符号引用（Symbolic References）</p>
<p>属于编译原理方面的概念，包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
</ul>
</li>
</ul>
<p>常量池中的每一项常量都是一个表，表都有一个共同的特点，就是表开始的第一位是一个 u1 类型的标志位（tag，取值见表 6-3 中标志列），代表当前这个常量属于哪种常量类型。下面列举一些常量类型所代表的的具体含义，且这些常量类型各自均有自己的结构。</p>
<p><img src="https://pic.tyzhang.top/images/2021/04/10/image9f9cfba27ab6f4b8.png" alt="image9f9cfba27ab6f4b8.png"></p>
<p><strong>第一项常量</strong></p>
<p>回头观察 TestClass.class 文件常量池中的第一项常量（偏移地址是 0x0000 000A）为 <code>0x0a</code></p>
<p>cafe babe 0000 0038  0013 <span style="color:red">0a</span>00 0400 0f09</p>
<p>查表 6-3 发现这个常量属于 <code>CONSTANT_Methodref_info</code> 类型，此类型的常量代表类中方法的符号引用，于是我上互联网进行搜索这个类型的结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志</th>
<th>数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
<td>值为10</td>
</tr>
<tr>
<td>u2</td>
<td>class_index</td>
<td>1</td>
<td>指向声明方法的类描述符 CONSTANT_Class_info 的索引项</td>
</tr>
<tr>
<td>u2</td>
<td>name_and_type_index</td>
<td>1</td>
<td>指向名称及类型描述符 CONSTANT_NameAndType_info 的索引项</td>
</tr>
</tbody>
</table>
<p>tag 是标志位，代表当前这个常量属于哪种常量类型。</p>
<p>class_index 是一个索引值，常量池在该索引处的项必须是 <code>CONSTANT_Class_info</code> 结构，表示一个类或接口，当前字段或方法是这个类或接口的成员。此处必须是类。</p>
<p>name_and_type_index 是一个索引值，常量池在该索引处的项必须是 <code>CONSTANT_NameAndType_info</code> 结构，它表示当前字段或方法的名字和描述符。此处必须是方法描述符。</p>
<p>观察 TestClass.class 文件，该常量的所有数据项为：</p>
<p>cafe babe 0000 0038  0013 <span style="color:red">0a</span><span style="color:yellowgreen">00 04</span><span style="color:blue">00 0f</span>09</p>
<p>tag（偏移地址 0x0000 000A)为 <code>0x0a</code> 代表个常量属于 <code>CONSTANT_Methodref_info</code> 类型，class_index（偏移地址 0x0000 000B）为 <code>0x0004</code>，即指向了常量池中的第 4 项常量，name_and_type_index（偏移地址 0x0000 000D）为 <code>0x000f</code>，即指向了常量池中的第 15 项常量。</p>
<p>篇幅受限，我们就不挨个去分析第 4 项常量和第 15 项常量，直接通过命令 <code>javap -verbose .\TestClass.class</code> 输出常量表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">javap -verbose  .\TestClass.class                                                                               Classfile /D:/TestClass.class</span><br><span class="line">  Last modified 2021年4月10日; size 292 bytes</span><br><span class="line">  MD5 checksum a4ca6bd139db017b6f2861fa6decc304</span><br><span class="line">  Compiled from &quot;TestClass.java&quot;</span><br><span class="line">public class top.zbsong.clazz.TestClass</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 56</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #3                          // top/zbsong/clazz/TestClass</span><br><span class="line">  super_class: #4                         // java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 1, methods: 2, attributes: 1</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#15         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #3.#16         // top/zbsong/clazz/TestClass.m:I</span><br><span class="line">   #3 = Class              #17            // top/zbsong/clazz/TestClass</span><br><span class="line">   #4 = Class              #18            // java/lang/Object</span><br><span class="line">   #5 = Utf8               m</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               inc</span><br><span class="line">  #12 = Utf8               ()I</span><br><span class="line">  #13 = Utf8               SourceFile</span><br><span class="line">  #14 = Utf8               TestClass.java</span><br><span class="line">  #15 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 = NameAndType        #5:#6          // m:I</span><br><span class="line">  #17 = Utf8               top/zbsong/clazz/TestClass</span><br><span class="line">  #18 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public top.zbsong.clazz.TestClass();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 2: 0</span><br><span class="line"></span><br><span class="line">  public int inc();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #2                  // Field m:I</span><br><span class="line">         4: iconst_1</span><br><span class="line">         5: iadd</span><br><span class="line">         6: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;TestClass.java&quot;</span><br></pre></td></tr></table></figure>
<p><strong>第4项常量</strong></p>
<p>可以看到第 4 项常量是一项 <code>CONSTANT_Class_info</code>  类型，其结构关系如下，</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志</th>
<th>数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
<td>值为7</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
<td>指向全限定名常量项的引用</td>
</tr>
</tbody>
</table>
<p>name_index 是一个索引值，它指向常量池中一个 <code>CONSTANT_Utf8_info</code> 类型常量，此常量代表了类（或者接口）的全限<br>
定名，通过常量表可以知道它的 name_index 指向第 18 个常量，该常量确实是一个 <code>CONSTANT_Utf8_info</code> 类型常量，。</p>
<p><code>CONSTANT_Utf8_info</code> 类型常量的结构如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志</th>
<th>数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
<td>值为1</td>
</tr>
<tr>
<td>u2</td>
<td>length</td>
<td>1</td>
<td>UTF-8 编码的字符串长度是多少字节</td>
</tr>
<tr>
<td>u1</td>
<td>bytes</td>
<td>length</td>
<td>长度为 length 的 UTF-8 编码的字符串</td>
</tr>
</tbody>
</table>
<p>顺带一提，由于 Class 文件中方法、字段等都需要引用 <code>CONSTANT_Utf8_info</code> 型常量来描述名称，所以 <code>CONSTANT_Utf8_info</code> 型常量的最大长度也就是 Java 中方法、字段名的最大长度。而这里的最大长度就是 length 的最大值，即 u2 类型能表达的最大值 65535。所以 Java 程序中如果定义了超过 64KB 英文字符的变量或方法名，将会无法编译。</p>
<p>于是我们就解析出来第 4 项常量所代表的含义是这个成员方法的所属类是 <code>java/lang/Object</code>。</p>
<p><strong>第15项常量</strong></p>
<p>第 15 项常量是一项 <code>CONSTANT_NameAndType_info</code> 类型的项目，其结构关系如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志</th>
<th>数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
<td>值为12</td>
</tr>
<tr>
<td>u2</td>
<td>index</td>
<td>1</td>
<td>指向该字段或方法名称常量项的引用</td>
</tr>
<tr>
<td>u2</td>
<td>index</td>
<td>1</td>
<td>指向该字段或方法描述符常量项的引用</td>
</tr>
</tbody>
</table>
<p>通过变量表我们知道第 15 项常量又指向第 7 项和第 8 项常量，分别表示方法的名称以及方法的描述符 <code>&quot;&lt;init&gt;&quot;:()V</code>。该内容具体的含义后边再进行分析。</p>
<p>于是我们就可以知道，第 1 项常量存放了一个方法，该方法属于 <code>java/lang/Object</code> 类，该方法的名称以及描述符是 <code>&quot;&lt;init&gt;&quot;:()V</code>。</p>
<p>后面的常量就不一一赘述了，有兴趣可以自己挨个分析。</p>
<h3 id="4-访问标志">4. 访问标志</h3>
<p>在常量池结束之后，紧接着的两个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等。具体的标志位以及标志的含义见表 6-7。</p>
<p><img src="https://pic.tyzhang.top/images/2021/04/10/image26377ac48f855564.png" alt="image26377ac48f855564.png"></p>
<p>access_flags 中一共有 16 个标志位可以使用，当前只定义了其中 8 个，没有使用到的标志位要求一律为 0。</p>
<p>由于 TestClass 是一个普通 Java 类，不是接口、枚举或者注解，被 public 关键字修饰但没有被声明为 final 和 abstract。因此它只有 ACC_PUBLIC、ACC_SUPER 标志应当为真，所以它的 access_flags 的值应该为 <code>0x0001 | 0x0020 = 0x0021</code>。观察 TestClass.class 文件，access_flags 标志（偏移地址 0x0000 00AE）的确为 <code>0x0021</code>。</p>
<p>7661 2f6c 616e 672f 4f62 6a65 6374 <span style="color:red">0021</span></p>
<h3 id="5-类索引-父类索引与接口索引集合">5. 类索引、父类索引与接口索引集合</h3>
<p>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定这个类的继承关系。</p>
<p><strong>类索引用</strong>  于确定这个类的全限定名。</p>
<p><strong>父类索引</strong> 用于确定这个类的父类的全限定名。由于 Java 语言不允许多重继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 Java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</p>
<p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后。</p>
<p>类索引和父类索引用两个 u2 类型的索引值表示，它们各自指向一个类型为 <code>CONSTANT_Class_info</code> 的类描述符常量，通过 <code>CONSTANT_Class_info</code> 类型的常量中的索引值可以找到定义在 <code>CONSTANT_Utf8_info</code> 类型的常量中的全限定名字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 类索引查找全限定名的过程</span><br><span class="line">this_class:&#123;value:3&#125;</span><br><span class="line">--&gt; </span><br><span class="line">#3 CONSTANT_Class_info:&#123;index:17&#125;</span><br><span class="line">--&gt; </span><br><span class="line">#17 CONSTANT_Utf8_info:&#123;length:26,bytes:top/zbsong/clazz/TestClass&#125;</span><br></pre></td></tr></table></figure>
<p><strong>接口索引集合</strong> 用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends 语句）后的接口顺序从左到右排列在接口索引集合中。</p>
<p>从偏移地址  0x0000 00B0 开始的 3 个 u2 类型的值分别为 0x0003、0x0004、0x0000，也就是类索引为 3，父类索引为 4，接口索引集合大小为 0，查询前面代码中 javap 命令计算出来的常量池，找出对应的类和父类的常量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#3 = Class              #17            // top/zbsong/clazz/TestClass</span><br><span class="line">#4 = Class              #18            // java/lang/Object</span><br><span class="line">#17 = Utf8               top/zbsong/clazz/TestClass</span><br><span class="line">#18 = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure>
<h3 id="6-字段表集合">6. 字段表集合</h3>
<p>字段表（field_info）用于描述接口或者类中声明的变量。</p>
<p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的 void 类型都用一个大写字符来表示，而对象类型则用字符 L 加对象的全限定名来表示。</p>
<p>对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组，将被记录为：“[[Ljava/lang/String；”，一个整型数组“int[]”将被记录为“[I”。</p>
<p>用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法 void inc() 的描述符为“()V”，方法 java.lang.String toString() 的描述符为“()Ljava/lang/String;”，方法 int indexOf(char[]source,int sourceOffset,int sourceCount,char[]target,int targetOffset,int targetCount,int fromIndex) 的描述符为“([CII[CIII)I”。</p>
<p>字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本 Java 代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</p>
<h3 id="7-方法表集合">7. 方法表集合</h3>
<p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。</p>
<p>方法里的 Java 代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面，</p>
<p>与字段表集合相对应的，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器“＜clinit＞”方法和实例构造器“＜init＞”方法。</p>
<h3 id="8-属性表集合">8. 属性表集合</h3>
<p>属性表（attribute_info），在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p>
<p>对于每个属性，它的名称需要从常量池中引用一个 <code>CONSTANT_Utf8_info</code> 类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个 u4 的长度属性去说明属性值所占用的位数即可。</p>
<p>属性表结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>info</td>
<td>attribute_length</td>
</tr>
</tbody>
</table>
<p><strong>Code属性</strong></p>
<p>Java 程序方法体中的代码经过 Javac 编译器处理后，最终变为字节码指令存储在 Code 属性内。</p>
<p>用 javap 命令计算字节码指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">javap -verbose  .\TestClass.class  </span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">  public top.zbsong.clazz.TestClass();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 2: 0</span><br><span class="line"></span><br><span class="line">  public int inc();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #2                  // Field m:I</span><br><span class="line">         4: iconst_1</span><br><span class="line">         5: iadd</span><br><span class="line">         6: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;TestClass.java&quot;</span><br></pre></td></tr></table></figure>
<p>看描述符 <code>()V</code> 虽然方法是无参的，但是 <code>args_size=1</code>，这是因为在任何实例方法里面，都可以通过 <code>this</code>关键字访问到此方法所属的对象。。这个访问机制对 Java 程序的编写很重要，而它的实现却非常简单，仅仅是通过 Javac 编译器编译的时候把对 this 关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个 Slot 位来存放对象实例的引用，方法参数值从 1 开始计算。</p>
<p>但是把方法声明为 static，那 <code>args_size</code> 的值就会等于 0 而不是 1了。</p>
<h2 id="字节码指令">字节码指令</h2>
<p>Java 虚拟机所支持的与数据类型相关的字节码指令，通过使用数据类型所代表的特殊字符替换指令模板中的T，就可以得到一个具体的字节码指令。</p>
<p><code>i</code> 代表对 int 类型的数据操作，<code>l</code> 代表 long，<code>s</code> 代表 short，<code>b</code> 代表 byte，<code>c</code> 代表 char，<code>f</code> 代表 float，<code>d</code> 代表 double，<code>a</code> 代表 reference。</p>
<p>大部分的指令都没有支持整数类型 byte、char、short 甚至是 boolean。大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的 int 类型作为运算类型。</p>
<h3 id="加载和存储指令">加载和存储指令</h3>
<p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。</p>
<p>将一个局部变量加载到操作数栈：<code>iload、iload_＜n＞、lload、lload_＜n＞、fload、fload_ ＜n＞、dload、dload_＜n＞、aload、aload_＜n＞</code><br>
将一个数值从操作数栈存储到局部变量表：<code>istore、istore_＜n＞、lstore、lstore_＜n＞、 fstore、fstore_＜n＞、dstore、dstore_＜n＞、astore、astore_＜n＞</code><br>
将一个常数加载到操作数栈：<code>bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、 iconst_m1、iconst_＜i＞、lconst_＜l＞、fconst_＜f＞、dconst_＜d＞</code><br>
扩充局部变量表的访问索引的指令：<code>wide</code></p>
<h3 id="运算指令">运算指令</h3>
<p>运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。</p>
<p>加法指令：<code>iadd、ladd、fadd、dadd</code><br>
减法指令：<code>isub、lsub、fsub、dsub</code><br>
乘法指令：<code>imul、lmul、fmul、dmul</code><br>
除法指令：<code>idiv、ldiv、fdiv、ddiv</code><br>
求余指令：<code>irem、lrem、frem、drem</code><br>
取反指令：<code>ineg、lneg、fneg、dneg</code><br>
位移指令：<code>ishl、ishr、iushr、lshl、lshr、lushr</code><br>
按位或指令：<code>ior、lor</code><br>
按位与指令：<code>iand、land</code><br>
按位异或指令：<code>ixor、lxor</code><br>
局部变量自增指令：<code>iinc</code><br>
比较指令：<code>dcmpg、dcmpl、fcmpg、fcmpl、lcmp</code></p>
<h3 id="类型转换指令">类型转换指令</h3>
<p>Java 虚拟机直接支持（即转换时无需显式的转换指令）以下数值类型的宽化类型转换：</p>
<ul>
<li>int 类型到 long、float 或者 double 类型</li>
<li>long 类型到 float、double 类型</li>
<li>float 类型到 double类型</li>
</ul>
<p>处理窄化类型转换（Narrowing Numeric Conversions）时，必须显式地使用转换 指令来完成，这些转换指令包括：<code>i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、d2f</code></p>
<h3 id="对象创建与访问指令">对象创建与访问指令</h3>
<p>创建类实例的指令：<code>new</code><br>
创建数组的指令：<code>newarray、anewarray、multianewarray</code><br>
访问类字段（static 字段，或者称为类变量）和实例字段（非static 字段，或者称为实例变量）的指令：<code>getfield、putfield、getstatic、putstatic</code><br>
把一个数组元素加载到操作数栈的指令：<code>baload、caload、saload、iaload、laload、faload、daload、aaload</code><br>
将一个操作数栈的值存储到数组元素中的指令：<code>bastore、castore、sastore、iastore、fastore、dastore、aastore</code><br>
取数组长度的指令：<code>arraylength</code><br>
检查类实例类型的指令：<code>instanceof、checkcast</code></p>
<h3 id="操作数栈管理指令">操作数栈管理指令</h3>
<p>将操作数栈的栈顶一个或两个元素出栈：<code>pop、pop2</code><br>
复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：<code>dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2</code><br>
将栈最顶端的两个数值互换：<code>swap</code></p>
<h3 id="控制转移指令">控制转移指令</h3>
<p>条件分支：<code>ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne</code><br>
复合条件分支：<code>tableswitch、lookupswitch</code><br>
无条件分支：<code>goto、goto_w、jsr、jsr_w、ret</code></p>
<h3 id="方法调用和返回指令">方法调用和返回指令</h3>
<p><code>invokevirtual</code> 指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。<br>
<code>invokeinterface</code> 指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。<br>
<code>invokespecial</code> 指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。<br>
<code>invokestatic</code> 指令用于调用类方法（static方法）。<br>
<code>invokedynamic</code> 指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面 4 条调用指令的分派逻辑都固化在 Java 虚拟机内部，而 <code>invokedynamic</code> 指令的分派逻辑是由用户所设定的引导方法决定的。<br>
方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括 <code>ireturn</code>（当返回值是 boolean、byte、char、short 和 int 类型时使用）、<code>lreturn、freturn、dreturn</code> 和 <code>areturn</code>，另外还有一条 <code>return</code> 指令供声明为 void 的方法、实例初始化方法以及类和接口的类初始化方法使用。</p>
<h3 id="异常处理指令">异常处理指令</h3>
<p>在 Java 程序中显式抛出异常的操作（throw语句）都由 <code>athrow</code> 指令来实现，除了用 throw 语句显式抛出异常情况之外，Java 虚拟机规范还规定了许多运行时异常会在其他 Java 虚拟机指令检测到异常状况时自动抛出。</p>
<p>处理异常（catch语句）不是由字节码指令来实现的，而是采用异常表来完成的。</p>
<h3 id="同步指令">同步指令</h3>
<p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来支持的。</p>
<p>同步一段指令集序列通常是由 Java 语言中的 synchronized 语句块来表示的，Java 虚拟机的指令集中有 <code>monitorenter</code> 和 <code>monitorexit</code>两条指令来支持 synchronized 关键字的语义。</p>
<p>为了保证在方法异常完成时 <code>monitorenter</code> 和 <code>monitorexit</code> 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 <code>monitorexit</code> 指令。</p>
<h2 id="编译期处理-语法糖">编译期处理 语法糖</h2>
<p>语法糖，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担。</p>
<p>这里用 Java 代码来解释语法糖。</p>
<h3 id="默认构造器">默认构造器</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy1</span> </span>&#123;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译成 class 后的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无参构造是编译器帮助我们加上的</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Candy1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 即调用父类 Object 的无参构造方法，即调用 java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动拆装箱">自动拆装箱</h3>
<p>这个特性是 JDK 5 开始加入的，代码片段 1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Integer x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码在 JDK 5 之前是无法编译通过的，必须改写为代码片段 2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Integer x = IInteger.valueOf(<span class="number">1</span>); <span class="comment">// 装箱</span></span><br><span class="line">        <span class="keyword">int</span> y = x.intValue(); <span class="comment">// 拆箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然之前版本的代码太麻烦了，需要在基本类型和包装类型之间来回转换（尤其是集合类中操作的都是包装类型），因此这些转换的事情在 JDK 5 以后都是由编译器在编译阶段完成。即代码片段 1 都会在编译阶段被转换为代码片段 2。</p>
<h3 id="泛型集合取值">泛型集合取值</h3>
<p>泛型也是在 JDK 5 开始加入的特性，但 Java 在编译泛型代码后悔执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当作了 Object 类型来处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">10</span>); <span class="comment">// 实际调用的是 List.add(Object e)</span></span><br><span class="line">        Integer x = list.get(<span class="number">0</span>); <span class="comment">// 实际调用的是 Object obj = List.get(int index);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要将 Object 转为 Integer</span></span><br><span class="line">Integer x = (Integer)list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>如果前面的 x 变量类型修改为 int 基本类型，那么最终生成的字节码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要将 Object 转换为 Integer，并执行拆箱操作</span></span><br><span class="line"><span class="keyword">int</span> x = ((Integer)list.get(<span class="number">0</span>).intValue());</span><br></pre></td></tr></table></figure>
<p>还好这些麻烦事都不用自己做。</p>
<p><strong>泛型擦除</strong>  即在字节码层面，调用 List.add 或者 List.get 方法时，会擦除泛型信息，统一按照 Object 来处理。</p>
<p>擦除的是字节码上的泛型信息，但是 LocalVariabletypeTable 局部变量类型泛型表仍然保留了方法参数泛型的信息。</p>
<h3 id="可变参数">可变参数</h3>
<p>可变参数也是 JDK 5 开始加入的新特性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        String[] array = args; <span class="comment">// 直接赋值</span></span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> vois <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        foo(<span class="string">"hello"</span>, <span class="string">"world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可变参数 <code>String... arg</code> 其实是一个 <code>String[] args</code>，从代码中的复制语句就可以看出来。</p>
<p>同样 Java 编译器会在编译期间将上述代码变换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] array = args; <span class="comment">// 直接赋值</span></span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> vois <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        foo(<span class="string">"hello"</span>, <span class="string">"world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong></p>
<p>如果调用了 <code>foo()</code> 则等价代码为 <code>foo(new String[]{})</code>，创建了一个空的数组，而不会传递 null 进去。</p>
</blockquote>
<h3 id="foreach循环">foreach循环</h3>
<p>仍是 JDK 5 开始引入的语法糖，数组的循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy5_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 数组赋初值的简化写法也是语法糖</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : array) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会被编译器转换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy5_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Candy5_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; array.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> e = array[i];</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>集合的循环，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy5_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际被编译器转化为对迭代器的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy5_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Candy5_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        Iterator iter = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            Integer e = (Integer)iter.next();</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch字符串">switch字符串</h3>
<p>从 JDK 7 开始，switch 可以作用于字符串和枚举类，但变量不能为null。这个功能其实也是语法糖，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy6_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">choose</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"hello"</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">"h"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"world"</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">"w"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会被编译器转换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy6_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Candy6_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">choose</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> x = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (str.hashCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">99162322</span>: <span class="comment">// hello 的 hashCode，提高比较效率，减少比较次数</span></span><br><span class="line">                <span class="keyword">if</span> (str.equals(<span class="string">"hello"</span>)) &#123; <span class="comment">// equals防止hashcode冲突</span></span><br><span class="line">                    x = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">113318802</span>: <span class="comment">// world 的 hashCode</span></span><br><span class="line">                <span class="keyword">if</span> (str.equals(<span class="string">"world"</span>)) &#123;</span><br><span class="line">                    x = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                System.out.println(<span class="string">"h"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">"w"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 hashCode 冲突的情况，会在该 hashCode 下用 <code>if...else</code> 语句来判断处理。</p>
<h3 id="switch枚举">switch枚举</h3>
<p>switch 枚举的例子，原始代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Sec &#123;</span><br><span class="line">    MALE, FEMALE</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Sex sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (sex) &#123;</span><br><span class="line">            <span class="keyword">case</span> MALE:</span><br><span class="line">                System.out.println(<span class="string">"男"</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FEMALE:</span><br><span class="line">                System.out.println(<span class="string">"女"</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换后代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy7</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）</span></span><br><span class="line"><span class="comment">    * 用来映射枚举的 ordinal 与数组元素的关系</span></span><br><span class="line"><span class="comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始</span></span><br><span class="line"><span class="comment">    * 即 MALE 的ordinal()=0，FEMALE 的ordinal()=1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> $<span class="title">MAP</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数组大小即为枚举元素个数，里面存储 case 用来对比的数字</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            map[Sex.MALE.ordinal()] = <span class="number">1</span>;</span><br><span class="line">            map[Sex.FEMALE.ordinal()] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Sex sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = $MAP.map[sex.ordinal()];</span><br><span class="line">        <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">"男"</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">"女"</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举类">枚举类</h3>
<p>JDK 7 新增了枚举类，以前面的性别枚举为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Sex &#123;</span><br><span class="line">    MALE, FEMALE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换后代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sex</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">Sex</span>&gt;</span>&#123; <span class="comment">// 枚举类不能再被继承</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex MALE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex FEMALE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex[] $VALUES;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        MALE = <span class="keyword">new</span> Sex(<span class="string">"MALE"</span>, <span class="number">0</span>);</span><br><span class="line">        FEMALE = <span class="keyword">new</span> Sex(<span class="string">"FEMALE"</span>, <span class="number">1</span>);</span><br><span class="line">        $VALUES = <span class="keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Sex</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, ordinal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sex[] values()&#123;</span><br><span class="line">        <span class="keyword">return</span> $VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sex <span class="title">valueOf</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Enum.valueOf(Sex.class, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="try-with-resources">try-with-resources</h3>
<p>JDK 7 开始新增了对需要关闭的资源处理的特殊语法 <code>try-with-resources</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(资源变量 = 创建资源对象) &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中资源对象需要实现 AutoCloseable 接口，例如 InputStream、OutputStream、Connection、Statement、ResultSet 等接口都实现了 AutoCloseable，使用 try-with-resources 可以不用写 finally 语句块，编译器会帮助生成关闭资源代码，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"d:\\1.txt"</span>)) &#123;</span><br><span class="line">            System.out.println(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会被转换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy9</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Candy9</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"d:\\q.txt"</span>);</span><br><span class="line">            Throwable t = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(is);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e1)&#123;</span><br><span class="line">                <span class="comment">// t 是代码出现的异常</span></span><br><span class="line">                t = e1;</span><br><span class="line">                <span class="keyword">throw</span> e1;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 判断了资源不为空</span></span><br><span class="line">                <span class="keyword">if</span> (is != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">// 如果我们代码有异常</span></span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            is.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable e2)&#123;</span><br><span class="line">                            <span class="comment">// 如果close有异常，作为被压制异常添加，防止try-with-resourcesfinally里的异常信息的丢失</span></span><br><span class="line">                            t.addSuppressed(e2);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果我们代码没有异常，close出现的异常就是最后catch块中的e</span></span><br><span class="line">                        is.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法重写时的桥接方法">方法重写时的桥接方法</h3>
<p>方法重写时对返回值分两种情况：</p>
<ul>
<li>父子类的返回值完全一致</li>
<li>子类返回值可以是父类返回值的子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Number <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于子类，Java 编译器会做如下处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此方法才是真正重写了父类public Number m()的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synthetic bridge Number <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 调用public Integer m()</span></span><br><span class="line">        <span class="keyword">return</span> m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中桥接方法比较特殊，仅对Java虚拟机可见，并且与原来的public Integer m()没有命名冲突，可以用下面的反射代码来验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method m : B.class.getDeclaredMethods())&#123;</span><br><span class="line">    System.out.println(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匿名内部类">匿名内部类</h3>
<p><strong>匿名内部类</strong></p>
<p>源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy10</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换后代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 额外生成的类</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy10</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Cady10$<span class="number">1</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy10</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Candy10$<span class="number">1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>引用局部变量的匿名内部类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy11</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"OK"</span> + x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换后代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 额外生成类</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy11</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val$x;</span><br><span class="line">    Candy$<span class="number">1</span>(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val$x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OK"</span> + <span class="keyword">this</span>.val$x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy10</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Candy11$<span class="number">1</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是 final 的：因为在创建 Candy11$1 对象时，将 x 的值赋值给了 Candy11$1 对象的 val$x 属性，所以 x 不应该再发生变化了，如果变化，那么 val$x 属性没有机会再跟着一起变化。</p>
<h2 id="类加载机制">类加载机制</h2>
<p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p>
<ul>
<li>在实际情况中，每个 Class 文件都有可能代表着 Java 语言中的一个类或接口，后文中直接对“类”的描述都包括了类和接口的可能性，而对于类和接口需要分开描述的场景会特别指明</li>
<li>与前面介绍 Class 文件格式时的约定一致，笔者本章所提到的“Class 文件”并非特指某个存在于具体磁盘中的文件，这里所说的“Class 文件”应当是一串二进制的字节流，无论以何种形式存在都可以</li>
</ul>
<h3 id="类加载的时机">类加载的时机</h3>
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载 7 个阶段。</p>
<p><img src="https://pic.tyzhang.top/images/2021/04/12/image.png" alt="image.png"></p>
<p>红框标记的加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始。</p>
<p><strong>什么时候开始类加载阶段（可以看初始化阶段的开始时机）：</strong></p>
<ol>
<li>遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 1.7的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<h3 id="加载">加载</h3>
<p>在加载阶段主要完成三件事：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的<strong>开始时间仍然保持着固定的先后顺序</strong>。</p>
<h3 id="链接">链接</h3>
<h4 id="验证">验证</h4>
<p>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>它大致完成了 4 个检验动作：</p>
<ol>
<li>文件格式验证：第一阶段要验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。</li>
<li>元数据验证：第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。</li>
<li>字节码验证：第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证：第四个阶段可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。</li>
</ol>
<h4 id="准备">准备</h4>
<p>准备阶段是为被 static 修饰的变量分配内存，设置默认值。</p>
<ul>
<li>static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段（构造方法）完成。</li>
<li>如果 static 变量是 final 的基本类型，那么编译阶段值就确定了，赋值在准备阶段完成。</li>
<li>如果 static 变量是 final 的，但属于引用类型，那么赋值也会在初始化阶段完成。</li>
</ul>
<h4 id="解析">解析</h4>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>符号引用：以一组符号来描述所引用的目标。</p>
<p>直接引用：直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。</p>
<p>直接引用和虚拟机实现的内存布局相关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException</span>&#123;</span><br><span class="line">        ClassLoader classloader = Load.class.getClassLoader();</span><br><span class="line">        <span class="comment">// loadClass方法不会导致类的解析和初始化</span></span><br><span class="line">        Class&lt;?&gt; c = classloader.loadClass(<span class="string">"类全限定类名.C"</span>);</span><br><span class="line">        <span class="comment">// new C();会</span></span><br><span class="line">        <span class="keyword">new</span> C();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    D d = <span class="keyword">new</span> D();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化">初始化</h3>
<p>&lt;cinit&gt;()V 方法，初始化即调用 &lt;cinit&gt;()V，虚拟机会保证这个类的构造方法的线程安全。</p>
<p><strong>发生的时机</strong></p>
<p>概括的说，类的初始化是懒惰的。</p>
<ul>
<li>main 方法所在的类，总会被首先初始化。</li>
<li>首次访问这个类的静态变量或静态方法时</li>
<li>子类初始化，如果父类还没初始化，会引发</li>
<li>子类访问父类的静态变量，只会触发父类的初始化</li>
<li>Class.forName</li>
<li>new 会导致初始化</li>
</ul>
<p>不会导致类初始化的情况</p>
<ul>
<li>访问类的 static final 的静态常量（基本类型和字符串）不会触发初始化，在链接时候就完成了</li>
<li>访问类对象 .class 不会触发初始化</li>
<li>创建该类的数组不会触发初始化</li>
<li>类加载器的 loadClass 方法</li>
<li>Class.forName 的参数 2 为 false 时</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load</span> </span>&#123;</span><br><span class="line">    <span class="comment">// main 方法所在的类，总会被首先初始化。</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"main init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. final静态变量不会初始化</span></span><br><span class="line">        System.out.println(B.b);</span><br><span class="line">        <span class="comment">// 2. 类对象.class不会触发初始化</span></span><br><span class="line">        System.out.println(B.class);</span><br><span class="line">        <span class="comment">// 3. 创建该类的数组不会触发初始化</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> B[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 4. 不会初始化类B，但是会加载B、A</span></span><br><span class="line">        ClassLoader c1 = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        c1.loadClass(<span class="string">"java.Load.B"</span>);</span><br><span class="line">        <span class="comment">// 5. 不会初始化类B，但会加载B、A</span></span><br><span class="line">        ClassLoader c2 = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        Class.forName(<span class="string">"java.Load.B"</span>, <span class="keyword">false</span>, c2);</span><br><span class="line">        <span class="comment">// 1. 首次访问这个类的静态变量或静态方法时</span></span><br><span class="line">        System.out.println(A.a);</span><br><span class="line">        <span class="comment">// 2. 子类初始化，如果父类还没初始化会引发</span></span><br><span class="line">        System.out.println(B.c);</span><br><span class="line">        <span class="comment">// 3. 子类访问父类静态变量，只触发父类初始化</span></span><br><span class="line">        System.out.println(B.a);</span><br><span class="line">        <span class="comment">// 4. 会初始化类B，并先初始化类A</span></span><br><span class="line">        Class.forName(<span class="string">"java.Load.B"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"a init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> b = <span class="number">5.0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> c = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"b init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习">练习</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(E.a);	<span class="comment">// 不会初始化，访问类的static final的静态常量(基本类型和字符串)不会触发初始化，在链接时候就完成了</span></span><br><span class="line">        System.out.println(E.b);	<span class="comment">// 不会初始化</span></span><br><span class="line">        System.out.println(E.c);	<span class="comment">// 初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String b = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer c = <span class="number">20</span>;	<span class="comment">// Integer.valueOf(20)</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"init E"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒惰实例化，懒惰单例模式</span></span><br><span class="line"><span class="comment">// 初始化时的线程安全是有保障的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton.test();	<span class="comment">// test，未导致初始化</span></span><br><span class="line">        Singleton.getInstance();	<span class="comment">//lazy holder init，导致初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"lazy hoder init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类加载器">类加载器</h2>
<p>以 JDK 8 为例：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>加载哪儿的类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bootstrap ClassLoader</td>
<td>JAVA_HOME/jre/lib</td>
<td>无法直接访问</td>
</tr>
<tr>
<td>Extension ClassLoader</td>
<td>JAVA_HOME/jre/lib/ext</td>
<td>上级为 Bootstrap，显示为 null</td>
</tr>
<tr>
<td>Application ClassLoader</td>
<td>classpath</td>
<td>上级为 Extension</td>
</tr>
<tr>
<td>自定义类加载器</td>
<td>自定义</td>
<td>上级为 Application</td>
</tr>
</tbody>
</table>
<p><strong>双亲委派模式</strong>：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<h3 id="启动类加载器">启动类加载器</h3>
<p>用 Bootstrap 类加载器加载类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.jvm.t3.load;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">F</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"bootstrap F init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load5_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">"cn.itcast.jvm.t3.load.F"</span>);</span><br><span class="line">        System.out.println(aClass.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 控制台编译</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java -Xbootclasspath/a:. cn.itcast.jvm.t3.load.Load5_1</span></span><br><span class="line"><span class="comment"># /a:.表示将当前目录追加到bootclasspath后</span></span><br><span class="line"><span class="comment"># 使用该方法替代核心类</span></span><br><span class="line"><span class="comment"># java -Xbootclasspath:&lt;new bootclasspath&gt;</span></span><br><span class="line"><span class="comment"># java -Xbootclasspath/a:&lt;追加路径&gt;	后追加</span></span><br><span class="line"><span class="comment"># java -Xbootclasspath/p:&lt;追加路径&gt;	前追加</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bootstrap F init</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>如果是应用程序加载器是 AppClassLoader，如果是扩展类加载器会打印 ExtClassLoader，但是启动类加载器是 C++ 代码编写的，不能通过 Java 代码直接访问，所以打印的是 null。</p>
<h3 id="扩展类加载器">扩展类加载器</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.jvm.t3.load;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">G</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"classpath G init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load5_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">"cn.itcast.jvm.t3.load.G"</span>);</span><br><span class="line">        System.out.println(aClass.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">classpath G init</span></span><br><span class="line"><span class="comment">sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>写一个同名类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">G</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"ext G init"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打个 jar 包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf my.jar com/itcast/jvm/t3/G.class</span><br></pre></td></tr></table></figure>
<p>拷贝到 <code>JAVA_HOME/jre/lib/ext</code>，重新执行 Load5_2</p>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ext G init</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@29453f44</span><br></pre></td></tr></table></figure>
<h3 id="双亲委派模式">双亲委派模式</h3>
<p>即调用类加载器的 loadClass 方法时，查找类的规则。虽然是双亲，但是它们并没有继承关系。</p>
<p><strong>双亲委派模式</strong>： 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<p><strong>实现逻辑：</strong> 先检查是否已经被加载过，若没有加载则调用父加载器的 loadClass() 方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出 ClassNotFoundException 异常后，再调用自己的 findClass() 方法进行加载。</p>
<p><strong>好处：</strong> 可以避免类的重复加载（相同的类文件被不同的类加载器加载产生的是两个不同的类）</p>
<p>Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类 java.lang.Object，它存放在 JAVA_HOME/jre/lib  之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。</p>
<h3 id="线程上下文类加载器破坏双亲委派模式">线程上下文类加载器（破坏双亲委派模式）</h3>
<blockquote>
<p>一句话总结：线程上下文类加载器在默认情况下是指向的应用程序加载器。在使用 SPI 服务去加载比如 JDBC 驱动时，在启动类加载器中通过当前线程去获取线程上下文类加载器，然后利用线程上下文类加载器去加载它不能完成的类加载任务。这个时候就破坏了双亲委派模式的一般性原则。</p>
</blockquote>
<p>我们在使用 JDBC 时，都需要加载 Driver 驱动，但是我们几乎没写过第一句，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">con=DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/tsetjdbc"</span>,</span><br><span class="line">					 <span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br></pre></td></tr></table></figure>
<p>也能够让 <code>com.mysql.jdbc.Driver</code> 正确加载，这是为什么呢？</p>
<p>这归功于线程上下文类加载器。 在 DriverManager.getConnection() 中，调用类的静态方法会初始化该类，进而执行该类的静态代码块，DriverManager 的静态代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册驱动的集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">	<span class="comment">// 初始化驱动</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		loadInitialDrivers();</span><br><span class="line">		println(<span class="string">"JDBC DriverManager initialized"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印 DriverManager 的类加载器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(DriverManager.class.getClassLoader());	<span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>表示它的类加载器是 Bootstrap ClassLoader，回到 JAVA_HOME/jre/lib 下搜索类，但是该目录下显然并没有 mysql 的 jar 包，继续查看 loadInitialDriver() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String drivers;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 1 先读取系统属性</span></span><br><span class="line">		drivers = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> System.getProperty(<span class="string">"jdbc.drivers"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        drivers = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2 通过SPI加载驱动类</span></span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                    driversIterator.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">                <span class="comment">// Do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 3 使用jdbc.drivers定义的驱动名加载驱动</span></span><br><span class="line">    <span class="keyword">if</span> (drivers == <span class="keyword">null</span> || drivers.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String[] driversList = drivers.split(<span class="string">":"</span>);</span><br><span class="line">    println(<span class="string">"number of Drivers:"</span> + driversList.length);</span><br><span class="line">    <span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(<span class="string">"DriverManager.Initialize: loading "</span> + aDriver);</span><br><span class="line">            <span class="comment">// 使用AppClassloader加载</span></span><br><span class="line">            Class.forName(aDriver, <span class="keyword">true</span>,</span><br><span class="line">                    ClassLoader.getSystemClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            println(<span class="string">"DriverManager.Initialize: load failed: "</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看 3 ，说明最后使用的是 Class.forName 完成类的加载和初始化，关联的是应用程序类加载器，因此可以顺利完成类加载。</p>
<p>1 就是 Service Provider Interface(SPI)，约定如下，在 jar 包中的 META-INF/services 包下，以接口全限定名为文件，文件内容是实现类名称。</p>
<p><img src="https://pic.tyzhang.top/images/2020/05/27/spi.jpg" alt=""></p>
<p>这样就可以使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;接口类型&gt; allImpls = ServiceLoader.load(接口类型.class);</span><br><span class="line">Iterator&lt;接口类型&gt; iter = allImpls.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">    iter.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来得到实现类，体现的是面向接口编程 + 解耦的思想，在以下框架中都运用了此思想：</p>
<ul>
<li>JDBC</li>
<li>Servlet 初始化器</li>
<li>Spring 容器</li>
<li>Dubbo(对 SPI 进行了扩展)</li>
</ul>
<p>继续看上述代码中的 ServiceLoader.load 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取线程上下文类加载器</span></span><br><span class="line">  ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">  <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程上下文类加载器是当前线程使用的类加载器，默认是应用程序类加载器。ServiceLoader.load 的内部是由 CLass.forName 调用了线程上下文类加载器完成类加载。具体代码在 ServiceLoader 的内部类 LazyIterator 中。</p>
<p>适用场景：</p>
<ul>
<li>当高层提供了统一接口让低层去实现，同时又要是在高层加载（或实例化）低层的类时，必须通过线程上下文类加载器来帮助高层的 ClassLoader 找到并加载该类。</li>
<li>当使用本类托管类加载，然而加载本类的 ClassLoader 未知时，为了隔离不同的调用者，可以取调用者各自的线程上下文类加载器代为托管。</li>
</ul>
<h3 id="自定义类加载器">自定义类加载器</h3>
<h4 id="应用场景">应用场景</h4>
<ul>
<li>想加载非 classpath 随意路径中的类文件</li>
<li>都是通过接口来实现，希望解耦时，常用在框架设计</li>
<li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li>
</ul>
<h4 id="步骤">步骤</h4>
<ol>
<li>继承 ClassLoader 父类</li>
<li>要遵从双亲委派机制，重写 findClass 方法
<ul>
<li>不是重写 loadClass 方法，否则不会走双亲委派机制</li>
</ul>
</li>
<li>读取类文件的字节码</li>
<li>调用父类的 defineClass 方法来加载类</li>
<li>使用者调用该类加载器的 loadClass 方法</li>
</ol>
<h4 id="例子">例子</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        String path = <span class="string">"e:\\myclasspath\\"</span> + name + <span class="string">".class"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayOutputStream os = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            Files.copy(Paths.get(path), os);</span><br><span class="line">            <span class="comment">// 得到字节数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = os.tobyteArray();</span><br><span class="line">            <span class="comment">// byte[]转化为*.class</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"类文件未找到"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">Class&lt;?&gt; c1 = classLoader.loadClass(<span class="string">"name1"</span>);</span><br><span class="line">Class&lt;?&gt; c2 = classLoader.loadClass(<span class="string">"name1"</span>);</span><br><span class="line">System.out.println(c1 == c2);	<span class="comment">// true</span></span><br><span class="line">MyClassLoader classLoader2 = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">Class&lt;?&gt; c3 = classLoader.loadClass(<span class="string">"name1"</span>);</span><br><span class="line">System.out.println(c1 == c3);	<span class="comment">// false，同一个类加载器为true</span></span><br><span class="line"></span><br><span class="line">c1.newInstance();	<span class="comment">// 实例化一个name1对象</span></span><br></pre></td></tr></table></figure>
<h1 id="虚拟机字节码执行引擎">虚拟机字节码执行引擎</h1>
<h2 id="栈帧">栈帧</h2>
<p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>
<p>对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（Current Stack Frame），与这个栈帧相关联的方法称为当前方法（Current Method）。</p>
<h3 id="局部变量表">局部变量表</h3>
<p>局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。</p>
<p>局部变量表以变量槽（Variable Slot）为最小单位，每个 slot 都能存放下一个 boolean、byte、char、short、int、float、reference 或 returnAddress 类型的数据，这 8 种数据类型，都可以使用 32 位或更小的物理内存来存放。对于 64 位的数据类型 long 和 double，虚拟机会以高位对齐的方式为其分配两个连续的 slot 空间。</p>
<h3 id="操作数栈">操作数栈</h3>
<p>操作数栈（Operand Stack）也常称为操作栈，它是一个后入先出 LIFO 栈。操作数栈的每一个元素可以是任意类型的 Java 数据类型，包括 long 和 double。32 位数据类型所占的栈容量为 1，64 位数据类型所占的栈容量为 2。</p>
<p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈\入栈操作。</p>
<h3 id="动态连接">动态连接</h3>
<p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。</p>
<p>Class 文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为<strong>静态解析</strong>。另外一部分将在每一次运行期间转化为直接引用，这部分称为<strong>动态连接</strong>。</p>
<h3 id="方法返回地址">方法返回地址</h3>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法。</p>
<p>第一种是执行引擎遇到任意一个方法返回的字节码指令将会退出这个方法，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为<strong>正常完成出口</strong>。</p>
<p>另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理（只要在本方法的异常表中没有搜索到匹配的异常处理器），就会导致方法退出，这种退出方法的方式称为<strong>异常完成出口</strong>，这种退出方式不会给它的上层调用者产生任何返回值。</p>
<p>一般来说，方法正常退出时，调用者的 PC 计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p>
<p>方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令等。</p>
<h2 id="方法调用">方法调用</h2>
<p>方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时不涉及方法内部的具体运行过程。Class 文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于之前说的直接引用）。</p>
<h2 id="java语言半解释半编译执行">Java语言半解释半编译执行</h2>
<p>Java 语言中，Javac 编译器完成了程序代码到线性的字节码指令流的过程，这一部分动作是在 Java 虚拟机之外进行的，而解释器是在虚拟机的内部，所以 Java 程序的编译就是半独立的实现。</p>
<h1 id="运行期优化">运行期优化</h1>
<h2 id="即时编译">即时编译</h2>
<h3 id="分层编译逃逸分析">分层编译——逃逸分析</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JIT1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Object();</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">      System.out.printf(<span class="string">"%d\t%d\n"</span>,i,(end - start));</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="comment">// 结果耗用时间分几个阶段下降明显</span></span><br></pre></td></tr></table></figure>
<p>JVM 将执行状态分成了 5 个层次：</p>
<ul>
<li>0 层，解释执行（Interpreter）</li>
<li>1 层，使用 C1 即时编译器编译执行（不带 profiling）</li>
<li>2 层，使用 C1 即时编译器编译执行（带基本的 profiling）</li>
<li>3 层，使用 C1 即时编译器编译执行（带完全的 profiling）</li>
<li>4 层，使用 C2 即时编译器编译执行</li>
</ul>
<p>profiling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的回边次数】等。</p>
<p><strong>即时编译器（JIT）与解释器的区别</strong></p>
<ul>
<li>解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li>
<li>JIT 是将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需再编译</li>
<li>解释器是将字节码解释为针对所有平台都通用的机器码</li>
<li>JIT 会根据平台类型，生成平台特定的机器码</li>
</ul>
<p>对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1(提升5倍) &lt; C2(提升10-100倍)，总的目标是发现热点代码（hotspot 名称的由来），优化之。</p>
<p>刚才的一种优化手段称之为【逃逸分析】。逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p>
<p>如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化：</p>
<ul>
<li>栈上分配：如果确定一个对象不会逃逸出方法之外，让这个对象在栈上分配内存，对象所占用的内存空间就可以随栈帧出栈而销毁。</li>
<li>同步消除：线程同步本身是一个相对耗时的过程，如果确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以消除掉。</li>
<li>标量替换：标量是指一个数据已经无法再分解成更小的数据来表示，Java 虚拟机中的原始数据类型都不能再进一步分解，可以称为标量。如果把一个 Java 对象拆散，根据程序访问的情况，将其使用到的成员变量恢复原始类型来访问就叫做标量替换。如果确定一个对象不会被外部访问，并且这个对象可以拆散的话，那程序真正执行的时<br>
候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。</li>
</ul>
<p>可以使用 <code>-XX:-DoEscapeAnalysis</code> 关闭逃逸分析。通过逃逸分析后的对象，可将这些对象直接在栈上进行分配，而非堆上。极大的降低了GC次数，从而提升了程序整体的执行效率。</p>
<h3 id="方法内联">方法内联</h3>
<p>方法内联，它是编译器最重要的优化手段之一，除了消除方法调用的成本之外，它更重要的意义是为其他优化手段建立良好的基础。它的行为很简单：把目标方法的代码“复制”到发起调用的方法之中，避免发生真实的方法调用而已</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i * i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(square(<span class="number">9</span>));</span><br></pre></td></tr></table></figure>
<p>如果发现  square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、粘贴到调用者的位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">9</span> * <span class="number">9</span>);</span><br></pre></td></tr></table></figure>
<p>还可以进行常量折叠：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">81</span>);</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JIT2</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining （解锁隐藏参数）打印inlining 信息</span></span><br><span class="line">        <span class="comment">// -XX:CompileCommand=dontinline,*JIT2.square 禁止某个如square方法 inlining</span></span><br><span class="line">        <span class="comment">// -XX:+PrintCompilation 打印编译信息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                x = square(<span class="number">9</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">            System.out.printf(<span class="string">"%d\t%d\t%d\n"</span>,i,x,(end - start));</span><br><span class="line">            <span class="comment">// 方法内联后已经没有了方法调用，运行速度会提升很多</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i * i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字段优化">字段优化</h3>
<p>读取优化：</p>
<ul>
<li>即时编译器会优化实例字段和静态字段的访问，以减少总的内存访问次数</li>
<li>即时编译器将沿着控制流 ，缓存各个字段存储节点将要存储的值，或者字段读取节点所得到的值</li>
<li>当即时编译器遇到对同一字段的读取节点时，如果缓存值还没有失效，那么将读取节点替换为该缓存值</li>
<li>当即时编译器遇到对同一字段的存储节点时，会更新所缓存的值</li>
<li>当即时编译器遇到可能更新字段的节点时，它会采取保守的策略，舍弃所有的缓存值</li>
<li>方法调用节点 ：在即时编译器看来，方法调用会执行未知代码</li>
<li>内存屏障节点 ：其他线程可能异步更新了字段</li>
</ul>
<p>存储优化：</p>
<ul>
<li>如果一个字段先后被存储了两次，而且这两次存储之间没有对第一次存储内容读取 ，那么即时编译器将消除第一个字段存储</li>
</ul>
<p>实例：</p>
<p>JMH 基准测试依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jmh.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jmh.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>基准测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Warmup</span>(iterations = <span class="number">2</span>, time = <span class="number">1</span>)</span><br><span class="line"><span class="meta">@Measurement</span>(iterations = <span class="number">5</span>, time = <span class="number">1</span>)</span><br><span class="line"><span class="meta">@State</span>(Scope.Benchmark)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Benchmark1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] elements = randomInts(<span class="number">1_000</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] randomInts(<span class="keyword">int</span> size) &#123;</span><br><span class="line">    Random random = ThreadLocalRandom.current();</span><br><span class="line">    <span class="keyword">int</span>[] values = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      values[i] = random.nextInt();</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="meta">@Benchmark</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">      doSum(elements[i]);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="meta">@Benchmark</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] local = <span class="keyword">this</span>.elements;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; local.length; i++) &#123;</span><br><span class="line">      doSum(local[i]);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="meta">@Benchmark</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> element : elements) &#123;</span><br><span class="line">      doSum(element);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="meta">@CompilerControl</span>(CompilerControl.Mode.INLINE)</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sum += x;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">    Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">       .include(Benchmark1.class.getSimpleName())</span><br><span class="line">       .forks(<span class="number">1</span>)</span><br><span class="line">       .build();</span><br><span class="line">    <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先启用 doSum 的方法内联，测试结果如下（每秒吞吐量，分数越高的更好）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Benchmark       Mode Samples    Score Score error Units</span><br><span class="line">t.Benchmark1.test1  thrpt    5 2420286.539  390747.467 ops/s</span><br><span class="line">t.Benchmark1.test2  thrpt    5 2544313.594  91304.136 ops/s</span><br><span class="line">t.Benchmark1.test3  thrpt    5 2469176.697  450570.647 ops/s</span><br></pre></td></tr></table></figure>
<p>接下来禁用 doSum 方法内联</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CompilerControl</span>(CompilerControl.Mode.DONT_INLINE)</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  sum += x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Benchmark       Mode Samples    Score Score error Units</span><br><span class="line">t.Benchmark1.test1  thrpt    5 296141.478  63649.220 ops/s</span><br><span class="line">t.Benchmark1.test2  thrpt    5 371262.351  83890.984 ops/s</span><br><span class="line">t.Benchmark1.test3  thrpt    5 368960.847  60163.391 ops/s</span><br></pre></td></tr></table></figure>
<p>分析：<br>
在刚才的示例中，doSum 方法是否内联会影响 elements 成员变量读取的优化：如果 doSum 方法内联了，刚才的 test1 方法会被优化成下面的样子（伪代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// elements.length 首次读取会缓存起来 -&gt; int[] local</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123; <span class="comment">// 后续 999 次 求长度 &lt;- local</span></span><br><span class="line">    sum += elements[i]; <span class="comment">// 1000 次取下标 i 的元素 &lt;- local</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以节省 1999 次 Field 读取操作，但如果 doSum 方法没有内联，则不会进行上面的优化</p>
<h2 id="反射优化">反射优化</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflect1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"foo..."</span>);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Method foo = Reflect1.class.getMethod(<span class="string">"foo"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">16</span>; i++) &#123;</span><br><span class="line">      System.out.printf(<span class="string">"%d\t"</span>, i);</span><br><span class="line">      foo.invoke(<span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    System.in.read();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现。</p>
<p>当调用到第 16 次（从0开始算）时，会采用运行时生成的类代替掉最初的实现，可以通过 debug 得到类名为 sun.reflect.GeneratedMethodAccessor1。由于生成新的类要花比较长的时间，比直接 native 调用要长3倍左右的时间。但是生成类以后，native 调用就会比调用花的时间长 20 倍。</p>
<blockquote>
<p>即在经过膨胀超过调用阈值后，会生成一个类，下次反射调用的时候将不会调用 native 方法去完成调用方法的操作，而是直接调用该生成类的方法。</p>
</blockquote>
<p>注意<br>
通过查看 ReflectionFactory 源码可知</p>
<ul>
<li>sun.reflect.noInflation 可以用来禁用膨胀（直接生成 GeneratedMethodAccessor1，但首<br>
次生成比较耗时，如果仅反射调用一次，不划算）</li>
<li>sun.reflect.inflationThreshold 可以修改膨胀阈值</li>
</ul>
<h1 id="内存模型">内存模型</h1>
<p>Java 内存模型，Java Memory Module(JMM) 的意思。它定义了一套多线程读写共享数据(成员变量、数组)时，对数据的可见性、有序性和原子性的规则和保障。</p>
<p>这一段懒得写了，直接摘录《并发编程》中的内容吧。</p>
<h2 id="java内存模型">Java内存模型</h2>
<p>JMM 本身是一个抽象的概念，并不真实存在，它描述的是通过一组规则或规范定制了程序中各个变量（包括实例字段、静态字段和构成数组对象的元素）的访问方式。因为它不是对物理内存的规范，而是在虚拟机基础上进行的规范从而能实现平台一致性，以达到 Java 程序能够“一次编写，到处运行”。</p>
<p>由于JVM 运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存（有些地方成为栈空间），工作内存是每个线程的私有数据区域，而 Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作空间，然后对变量进行操作，操作完成再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存储存着主内存中的变量副本拷贝，因此不同的线程无法访问对方的工作内存，此线程间的通讯（传值） 必须通过主内存来完成。</p>
<p><img src="https://pic.tyzhang.top/images/2021/03/15/imagedceb6e4934633705.png" alt="imagedceb6e4934633705.png"></p>
<p>JMM 是围绕着在并发过程中如何处理可见性、原子性、有序性这三个特性而简历的模型。</p>
<blockquote>
<p>有时间专门整理一篇 JMM 相关内容。</p>
</blockquote>
<h3 id="原子性atomicity">原子性（Atomicity）</h3>
<blockquote>
<p>一个操作不能被打断，要么全部执行完毕，要么不执行</p>
</blockquote>
<p>基本类型数据的访问大都是原子操作，long 和 double 类型的变量是 64 位，但是在 32 位 JVM 中，32 位的 JVM 会将 64 位数据的读写操作分为 2 次 32 位的读写操作来进行，这就导致了 long、double 类型的变量在 32 位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的。</p>
<p>解决原子性问题（如多个线程同时操作一个共享变量），可以使用：</p>
<ul>
<li>加 synchronized 关键字</li>
<li>使用 JUC 下的 AtomicInteger 类</li>
</ul>
<h3 id="可见性visibility">可见性（visibility）</h3>
<blockquote>
<p>一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量的这种修改（变化）。</p>
</blockquote>
<p>volatile 关键字、synchronized关键字、Lock接口、final 可以实现可见性。</p>
<p>volatile 关键字的特殊规则保证了被 volatile 修饰的变量的值修改后，新值会立刻同步到主内存，每次使用被 volatile 修饰的变量时会立刻从主内存中刷新，因此 volatile 关键字可以保证多线程之间的操作变量的可见性。</p>
<p>synchronized 关键字在同步方法/同步块开始时（Monitor Enter），使用共享变量时会从主内存中刷新变量值到工作内存中；在同步方法/同步块结束时（Monitor Exit），会将工作内存中的变量值同步到主内存中去。</p>
<p>使用 Lock 接口（拿最常用的实现 ReentrantLock 重入锁）来实现可见性：在方法开始的位置执行 <code>lock（）</code> 方法，这和 synchronized 开始位置（Monitor Entry）有相同的语义，即使用共享变量时会从主内存中刷新变量值到工作内存中；在方法最后的执行 <code>unlock（）</code> 方法，和 synchronized 结束位置（Monitor Exit）有相同的语义，即将工作内存中的变量值同步到主内存中去。</p>
<p>被 final 关键字修饰的变量，在构造函数完成且构造函数中没有把 <code>this</code> 的引用传递出去时，其他线程就可以看到 final 变量的值，实现了可见性。（<code>this</code> 引用逃逸非常危险，其他的线程很可能通过引用访问到只初始化了一半的对象）</p>
<h3 id="有序性ordering">有序性（Ordering）</h3>
<blockquote>
<p>在单线程中，代码的执行时从前往后依次执行的。但是在多线程并发时，程序的执行有可能是无序的。在本线程内观察，所有操作都是有序的。如果在一个线程中观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序、工作内存和主内存同步延迟现象（单线程中不存在）。</p>
</blockquote>
<p>一个最经典的例子就是银行汇款问题，一个银行账户存款 100，这时一个人从该账户取 10 元，同时另一个人向该账户汇 10 元，那么余额应该还是 100。那么此时可能发生这种情况，A 线程负责取款，B 线程负责汇款，A 从主内存读到 100，B 从主内存读到 100，A 执行减 10 操作，并将数据刷新到主内存，这时主内存数据 $100-10=90$，而 B 内存执行加 10 操作，并将数据刷新到主内存，最后主内存数据 $100+10=110$，显然这是一个严重的问题，我们要保证 A 线程和 B 线程有序执行，先取款后汇款或者先汇款后取款，此为有序性。</p>
<p>可以通过 volatile 关键字和 synchronized 关键字来保证多线程操作的有序性，volatile 关键字通过加入内存屏障来禁止指令的重排序优化，而 synchronized 关键字通过加锁来允许同一时间只有一个线程对共享变量进行操作。</p>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/算法—两数之和三数之和四数之和/" data-toggle="tooltip" data-placement="top" title="两数之和三数之和四数之和">&larr; 上一篇</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/多线程—CAS无锁-乐观锁/" data-toggle="tooltip" data-placement="top" title="多线程—乐观锁CAS机制">下一篇 &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">目录</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#内存结构"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">&#x5185;&#x5B58;&#x7ED3;&#x6784;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#程序计数器"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">&#x7A0B;&#x5E8F;&#x8BA1;&#x6570;&#x5668;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#虚拟机栈"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">&#x865A;&#x62DF;&#x673A;&#x6808;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#线程安全"><span class="toc-nav-number">1.2.1.</span> <span class="toc-nav-text">&#x7EBF;&#x7A0B;&#x5B89;&#x5168;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#栈内存溢出"><span class="toc-nav-number">1.2.2.</span> <span class="toc-nav-text">&#x6808;&#x5185;&#x5B58;&#x6EA2;&#x51FA;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#线程运行诊断"><span class="toc-nav-number">1.2.3.</span> <span class="toc-nav-text">&#x7EBF;&#x7A0B;&#x8FD0;&#x884C;&#x8BCA;&#x65AD;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#本地方法栈"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">&#x672C;&#x5730;&#x65B9;&#x6CD5;&#x6808;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#heap堆"><span class="toc-nav-number">1.4.</span> <span class="toc-nav-text">Heap&#x5806;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#堆内存溢出"><span class="toc-nav-number">1.4.1.</span> <span class="toc-nav-text">&#x5806;&#x5185;&#x5B58;&#x6EA2;&#x51FA;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#堆内存诊断"><span class="toc-nav-number">1.4.2.</span> <span class="toc-nav-text">&#x5806;&#x5185;&#x5B58;&#x8BCA;&#x65AD;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#方法区"><span class="toc-nav-number">1.5.</span> <span class="toc-nav-text">&#x65B9;&#x6CD5;&#x533A;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#方法区内存溢出"><span class="toc-nav-number">1.5.1.</span> <span class="toc-nav-text">&#x65B9;&#x6CD5;&#x533A;&#x5185;&#x5B58;&#x6EA2;&#x51FA;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#场景"><span class="toc-nav-number">1.5.2.</span> <span class="toc-nav-text">&#x573A;&#x666F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#运行时常量池"><span class="toc-nav-number">1.5.3.</span> <span class="toc-nav-text">&#x8FD0;&#x884C;&#x65F6;&#x5E38;&#x91CF;&#x6C60;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#stringtable"><span class="toc-nav-number">1.5.4.</span> <span class="toc-nav-text">StringTable</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#特性"><span class="toc-nav-number">1.5.4.1.</span> <span class="toc-nav-text">&#x7279;&#x6027;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#存放位置"><span class="toc-nav-number">1.5.4.2.</span> <span class="toc-nav-text">&#x5B58;&#x653E;&#x4F4D;&#x7F6E;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#垃圾回收"><span class="toc-nav-number">1.5.4.3.</span> <span class="toc-nav-text">&#x5783;&#x573E;&#x56DE;&#x6536;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#性能调优"><span class="toc-nav-number">1.5.5.</span> <span class="toc-nav-text">&#x6027;&#x80FD;&#x8C03;&#x4F18;</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#垃圾回收"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">&#x5783;&#x573E;&#x56DE;&#x6536;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#如何判断对象可以回收"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">&#x5982;&#x4F55;&#x5224;&#x65AD;&#x5BF9;&#x8C61;&#x53EF;&#x4EE5;&#x56DE;&#x6536;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#引用计数法"><span class="toc-nav-number">2.1.1.</span> <span class="toc-nav-text">&#x5F15;&#x7528;&#x8BA1;&#x6570;&#x6CD5;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#可达性分析算法"><span class="toc-nav-number">2.1.2.</span> <span class="toc-nav-text">&#x53EF;&#x8FBE;&#x6027;&#x5206;&#x6790;&#x7B97;&#x6CD5;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#四种引用"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">&#x56DB;&#x79CD;&#x5F15;&#x7528;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#强引用"><span class="toc-nav-number">2.2.1.</span> <span class="toc-nav-text">&#x5F3A;&#x5F15;&#x7528;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#软引用"><span class="toc-nav-number">2.2.2.</span> <span class="toc-nav-text">&#x8F6F;&#x5F15;&#x7528;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#弱引用"><span class="toc-nav-number">2.2.3.</span> <span class="toc-nav-text">&#x5F31;&#x5F15;&#x7528;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#虚引用"><span class="toc-nav-number">2.2.4.</span> <span class="toc-nav-text">&#x865A;&#x5F15;&#x7528;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#终结器引用了解"><span class="toc-nav-number">2.2.5.</span> <span class="toc-nav-text">&#x7EC8;&#x7ED3;&#x5668;&#x5F15;&#x7528;&#xFF08;&#x4E86;&#x89E3;&#xFF09;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#垃圾回收算法"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">&#x5783;&#x573E;&#x56DE;&#x6536;&#x7B97;&#x6CD5;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#标记清除"><span class="toc-nav-number">2.3.1.</span> <span class="toc-nav-text">&#x6807;&#x8BB0;&#x6E05;&#x9664;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#复制"><span class="toc-nav-number">2.3.2.</span> <span class="toc-nav-text">&#x590D;&#x5236;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#标记整理"><span class="toc-nav-number">2.3.3.</span> <span class="toc-nav-text">&#x6807;&#x8BB0;&#x6574;&#x7406;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#分代垃圾回收"><span class="toc-nav-number">2.4.</span> <span class="toc-nav-text">&#x5206;&#x4EE3;&#x5783;&#x573E;&#x56DE;&#x6536;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#新生代"><span class="toc-nav-number">2.4.0.1.</span> <span class="toc-nav-text">&#x65B0;&#x751F;&#x4EE3;</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#相关vm参数"><span class="toc-nav-number">2.5.</span> <span class="toc-nav-text">&#x76F8;&#x5173;VM&#x53C2;&#x6570;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#理解gc日志"><span class="toc-nav-number">2.6.</span> <span class="toc-nav-text">&#x7406;&#x89E3;GC&#x65E5;&#x5FD7;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#垃圾回收器"><span class="toc-nav-number">2.7.</span> <span class="toc-nav-text">&#x5783;&#x573E;&#x56DE;&#x6536;&#x5668;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#串行serialgc"><span class="toc-nav-number">2.7.1.</span> <span class="toc-nav-text">&#x4E32;&#x884C;SerialGC</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#吞吐量优先parallelgc"><span class="toc-nav-number">2.7.2.</span> <span class="toc-nav-text">&#x541E;&#x5410;&#x91CF;&#x4F18;&#x5148;ParallelGC</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#响应时间优先-cms"><span class="toc-nav-number">2.7.3.</span> <span class="toc-nav-text">&#x54CD;&#x5E94;&#x65F6;&#x95F4;&#x4F18;&#x5148; CMS</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#g1"><span class="toc-nav-number">2.7.4.</span> <span class="toc-nav-text">G1</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#内存分配与回收策略"><span class="toc-nav-number">2.8.</span> <span class="toc-nav-text">&#x5185;&#x5B58;&#x5206;&#x914D;&#x4E0E;&#x56DE;&#x6536;&#x7B56;&#x7565;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#对象优先在伊甸园区分配"><span class="toc-nav-number">2.8.1.</span> <span class="toc-nav-text">&#x5BF9;&#x8C61;&#x4F18;&#x5148;&#x5728;&#x4F0A;&#x7538;&#x56ED;&#x533A;&#x5206;&#x914D;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#大对象直接进入老年代"><span class="toc-nav-number">2.8.2.</span> <span class="toc-nav-text">&#x5927;&#x5BF9;&#x8C61;&#x76F4;&#x63A5;&#x8FDB;&#x5165;&#x8001;&#x5E74;&#x4EE3;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#长期存活的对象将进入老年代"><span class="toc-nav-number">2.8.3.</span> <span class="toc-nav-text">&#x957F;&#x671F;&#x5B58;&#x6D3B;&#x7684;&#x5BF9;&#x8C61;&#x5C06;&#x8FDB;&#x5165;&#x8001;&#x5E74;&#x4EE3;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#动态对象年龄判定"><span class="toc-nav-number">2.8.4.</span> <span class="toc-nav-text">&#x52A8;&#x6001;&#x5BF9;&#x8C61;&#x5E74;&#x9F84;&#x5224;&#x5B9A;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#空间分配担保"><span class="toc-nav-number">2.8.5.</span> <span class="toc-nav-text">&#x7A7A;&#x95F4;&#x5206;&#x914D;&#x62C5;&#x4FDD;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#垃圾回收调优"><span class="toc-nav-number">2.9.</span> <span class="toc-nav-text">&#x5783;&#x573E;&#x56DE;&#x6536;&#x8C03;&#x4F18;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#调优领域"><span class="toc-nav-number">2.9.1.</span> <span class="toc-nav-text">&#x8C03;&#x4F18;&#x9886;&#x57DF;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#确定目标"><span class="toc-nav-number">2.9.2.</span> <span class="toc-nav-text">&#x786E;&#x5B9A;&#x76EE;&#x6807;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#最快的gc是不发生gc"><span class="toc-nav-number">2.9.3.</span> <span class="toc-nav-text">&#x6700;&#x5FEB;&#x7684;GC&#x662F;&#x4E0D;&#x53D1;&#x751F;GC</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#新生代调优"><span class="toc-nav-number">2.9.4.</span> <span class="toc-nav-text">&#x65B0;&#x751F;&#x4EE3;&#x8C03;&#x4F18;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#老年代调优"><span class="toc-nav-number">2.9.5.</span> <span class="toc-nav-text">&#x8001;&#x5E74;&#x4EE3;&#x8C03;&#x4F18;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#案例"><span class="toc-nav-number">2.9.6.</span> <span class="toc-nav-text">&#x6848;&#x4F8B;</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#虚拟机性能监控与故障处理工具"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">&#x865A;&#x62DF;&#x673A;&#x6027;&#x80FD;&#x76D1;&#x63A7;&#x4E0E;&#x6545;&#x969C;&#x5904;&#x7406;&#x5DE5;&#x5177;</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#类加载与字节码技术"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">&#x7C7B;&#x52A0;&#x8F7D;&#x4E0E;&#x5B57;&#x8282;&#x7801;&#x6280;&#x672F;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#类文件结构"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">&#x7C7B;&#x6587;&#x4EF6;&#x7ED3;&#x6784;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-魔数magic"><span class="toc-nav-number">4.1.1.</span> <span class="toc-nav-text">1. &#x9B54;&#x6570;magic</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-class文件的版本"><span class="toc-nav-number">4.1.2.</span> <span class="toc-nav-text">2. Class&#x6587;&#x4EF6;&#x7684;&#x7248;&#x672C;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-常量池"><span class="toc-nav-number">4.1.3.</span> <span class="toc-nav-text">3. &#x5E38;&#x91CF;&#x6C60;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-访问标志"><span class="toc-nav-number">4.1.4.</span> <span class="toc-nav-text">4. &#x8BBF;&#x95EE;&#x6807;&#x5FD7;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-类索引-父类索引与接口索引集合"><span class="toc-nav-number">4.1.5.</span> <span class="toc-nav-text">5. &#x7C7B;&#x7D22;&#x5F15;&#x3001;&#x7236;&#x7C7B;&#x7D22;&#x5F15;&#x4E0E;&#x63A5;&#x53E3;&#x7D22;&#x5F15;&#x96C6;&#x5408;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-字段表集合"><span class="toc-nav-number">4.1.6.</span> <span class="toc-nav-text">6. &#x5B57;&#x6BB5;&#x8868;&#x96C6;&#x5408;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-方法表集合"><span class="toc-nav-number">4.1.7.</span> <span class="toc-nav-text">7. &#x65B9;&#x6CD5;&#x8868;&#x96C6;&#x5408;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8-属性表集合"><span class="toc-nav-number">4.1.8.</span> <span class="toc-nav-text">8. &#x5C5E;&#x6027;&#x8868;&#x96C6;&#x5408;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#字节码指令"><span class="toc-nav-number">4.2.</span> <span class="toc-nav-text">&#x5B57;&#x8282;&#x7801;&#x6307;&#x4EE4;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#加载和存储指令"><span class="toc-nav-number">4.2.1.</span> <span class="toc-nav-text">&#x52A0;&#x8F7D;&#x548C;&#x5B58;&#x50A8;&#x6307;&#x4EE4;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#运算指令"><span class="toc-nav-number">4.2.2.</span> <span class="toc-nav-text">&#x8FD0;&#x7B97;&#x6307;&#x4EE4;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#类型转换指令"><span class="toc-nav-number">4.2.3.</span> <span class="toc-nav-text">&#x7C7B;&#x578B;&#x8F6C;&#x6362;&#x6307;&#x4EE4;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#对象创建与访问指令"><span class="toc-nav-number">4.2.4.</span> <span class="toc-nav-text">&#x5BF9;&#x8C61;&#x521B;&#x5EFA;&#x4E0E;&#x8BBF;&#x95EE;&#x6307;&#x4EE4;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#操作数栈管理指令"><span class="toc-nav-number">4.2.5.</span> <span class="toc-nav-text">&#x64CD;&#x4F5C;&#x6570;&#x6808;&#x7BA1;&#x7406;&#x6307;&#x4EE4;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#控制转移指令"><span class="toc-nav-number">4.2.6.</span> <span class="toc-nav-text">&#x63A7;&#x5236;&#x8F6C;&#x79FB;&#x6307;&#x4EE4;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#方法调用和返回指令"><span class="toc-nav-number">4.2.7.</span> <span class="toc-nav-text">&#x65B9;&#x6CD5;&#x8C03;&#x7528;&#x548C;&#x8FD4;&#x56DE;&#x6307;&#x4EE4;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#异常处理指令"><span class="toc-nav-number">4.2.8.</span> <span class="toc-nav-text">&#x5F02;&#x5E38;&#x5904;&#x7406;&#x6307;&#x4EE4;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#同步指令"><span class="toc-nav-number">4.2.9.</span> <span class="toc-nav-text">&#x540C;&#x6B65;&#x6307;&#x4EE4;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#编译期处理-语法糖"><span class="toc-nav-number">4.3.</span> <span class="toc-nav-text">&#x7F16;&#x8BD1;&#x671F;&#x5904;&#x7406; &#x8BED;&#x6CD5;&#x7CD6;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#默认构造器"><span class="toc-nav-number">4.3.1.</span> <span class="toc-nav-text">&#x9ED8;&#x8BA4;&#x6784;&#x9020;&#x5668;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#自动拆装箱"><span class="toc-nav-number">4.3.2.</span> <span class="toc-nav-text">&#x81EA;&#x52A8;&#x62C6;&#x88C5;&#x7BB1;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#泛型集合取值"><span class="toc-nav-number">4.3.3.</span> <span class="toc-nav-text">&#x6CDB;&#x578B;&#x96C6;&#x5408;&#x53D6;&#x503C;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#可变参数"><span class="toc-nav-number">4.3.4.</span> <span class="toc-nav-text">&#x53EF;&#x53D8;&#x53C2;&#x6570;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#foreach循环"><span class="toc-nav-number">4.3.5.</span> <span class="toc-nav-text">foreach&#x5FAA;&#x73AF;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#switch字符串"><span class="toc-nav-number">4.3.6.</span> <span class="toc-nav-text">switch&#x5B57;&#x7B26;&#x4E32;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#switch枚举"><span class="toc-nav-number">4.3.7.</span> <span class="toc-nav-text">switch&#x679A;&#x4E3E;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#枚举类"><span class="toc-nav-number">4.3.8.</span> <span class="toc-nav-text">&#x679A;&#x4E3E;&#x7C7B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#try-with-resources"><span class="toc-nav-number">4.3.9.</span> <span class="toc-nav-text">try-with-resources</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#方法重写时的桥接方法"><span class="toc-nav-number">4.3.10.</span> <span class="toc-nav-text">&#x65B9;&#x6CD5;&#x91CD;&#x5199;&#x65F6;&#x7684;&#x6865;&#x63A5;&#x65B9;&#x6CD5;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#匿名内部类"><span class="toc-nav-number">4.3.11.</span> <span class="toc-nav-text">&#x533F;&#x540D;&#x5185;&#x90E8;&#x7C7B;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#类加载机制"><span class="toc-nav-number">4.4.</span> <span class="toc-nav-text">&#x7C7B;&#x52A0;&#x8F7D;&#x673A;&#x5236;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#类加载的时机"><span class="toc-nav-number">4.4.1.</span> <span class="toc-nav-text">&#x7C7B;&#x52A0;&#x8F7D;&#x7684;&#x65F6;&#x673A;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#加载"><span class="toc-nav-number">4.4.2.</span> <span class="toc-nav-text">&#x52A0;&#x8F7D;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#链接"><span class="toc-nav-number">4.4.3.</span> <span class="toc-nav-text">&#x94FE;&#x63A5;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#验证"><span class="toc-nav-number">4.4.3.1.</span> <span class="toc-nav-text">&#x9A8C;&#x8BC1;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#准备"><span class="toc-nav-number">4.4.3.2.</span> <span class="toc-nav-text">&#x51C6;&#x5907;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#解析"><span class="toc-nav-number">4.4.3.3.</span> <span class="toc-nav-text">&#x89E3;&#x6790;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#初始化"><span class="toc-nav-number">4.4.4.</span> <span class="toc-nav-text">&#x521D;&#x59CB;&#x5316;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#练习"><span class="toc-nav-number">4.4.5.</span> <span class="toc-nav-text">&#x7EC3;&#x4E60;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#类加载器"><span class="toc-nav-number">4.5.</span> <span class="toc-nav-text">&#x7C7B;&#x52A0;&#x8F7D;&#x5668;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#启动类加载器"><span class="toc-nav-number">4.5.1.</span> <span class="toc-nav-text">&#x542F;&#x52A8;&#x7C7B;&#x52A0;&#x8F7D;&#x5668;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#扩展类加载器"><span class="toc-nav-number">4.5.2.</span> <span class="toc-nav-text">&#x6269;&#x5C55;&#x7C7B;&#x52A0;&#x8F7D;&#x5668;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#双亲委派模式"><span class="toc-nav-number">4.5.3.</span> <span class="toc-nav-text">&#x53CC;&#x4EB2;&#x59D4;&#x6D3E;&#x6A21;&#x5F0F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#线程上下文类加载器破坏双亲委派模式"><span class="toc-nav-number">4.5.4.</span> <span class="toc-nav-text">&#x7EBF;&#x7A0B;&#x4E0A;&#x4E0B;&#x6587;&#x7C7B;&#x52A0;&#x8F7D;&#x5668;&#xFF08;&#x7834;&#x574F;&#x53CC;&#x4EB2;&#x59D4;&#x6D3E;&#x6A21;&#x5F0F;&#xFF09;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#自定义类加载器"><span class="toc-nav-number">4.5.5.</span> <span class="toc-nav-text">&#x81EA;&#x5B9A;&#x4E49;&#x7C7B;&#x52A0;&#x8F7D;&#x5668;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#应用场景"><span class="toc-nav-number">4.5.5.1.</span> <span class="toc-nav-text">&#x5E94;&#x7528;&#x573A;&#x666F;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#步骤"><span class="toc-nav-number">4.5.5.2.</span> <span class="toc-nav-text">&#x6B65;&#x9AA4;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#例子"><span class="toc-nav-number">4.5.5.3.</span> <span class="toc-nav-text">&#x4F8B;&#x5B50;</span></a></li></ol></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#虚拟机字节码执行引擎"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">&#x865A;&#x62DF;&#x673A;&#x5B57;&#x8282;&#x7801;&#x6267;&#x884C;&#x5F15;&#x64CE;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#栈帧"><span class="toc-nav-number">5.1.</span> <span class="toc-nav-text">&#x6808;&#x5E27;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#局部变量表"><span class="toc-nav-number">5.1.1.</span> <span class="toc-nav-text">&#x5C40;&#x90E8;&#x53D8;&#x91CF;&#x8868;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#操作数栈"><span class="toc-nav-number">5.1.2.</span> <span class="toc-nav-text">&#x64CD;&#x4F5C;&#x6570;&#x6808;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#动态连接"><span class="toc-nav-number">5.1.3.</span> <span class="toc-nav-text">&#x52A8;&#x6001;&#x8FDE;&#x63A5;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#方法返回地址"><span class="toc-nav-number">5.1.4.</span> <span class="toc-nav-text">&#x65B9;&#x6CD5;&#x8FD4;&#x56DE;&#x5730;&#x5740;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#方法调用"><span class="toc-nav-number">5.2.</span> <span class="toc-nav-text">&#x65B9;&#x6CD5;&#x8C03;&#x7528;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#java语言半解释半编译执行"><span class="toc-nav-number">5.3.</span> <span class="toc-nav-text">Java&#x8BED;&#x8A00;&#x534A;&#x89E3;&#x91CA;&#x534A;&#x7F16;&#x8BD1;&#x6267;&#x884C;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#运行期优化"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">&#x8FD0;&#x884C;&#x671F;&#x4F18;&#x5316;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#即时编译"><span class="toc-nav-number">6.1.</span> <span class="toc-nav-text">&#x5373;&#x65F6;&#x7F16;&#x8BD1;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#分层编译逃逸分析"><span class="toc-nav-number">6.1.1.</span> <span class="toc-nav-text">&#x5206;&#x5C42;&#x7F16;&#x8BD1;&#x2014;&#x2014;&#x9003;&#x9038;&#x5206;&#x6790;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#方法内联"><span class="toc-nav-number">6.1.2.</span> <span class="toc-nav-text">&#x65B9;&#x6CD5;&#x5185;&#x8054;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#字段优化"><span class="toc-nav-number">6.1.3.</span> <span class="toc-nav-text">&#x5B57;&#x6BB5;&#x4F18;&#x5316;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#反射优化"><span class="toc-nav-number">6.2.</span> <span class="toc-nav-text">&#x53CD;&#x5C04;&#x4F18;&#x5316;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#内存模型"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">&#x5185;&#x5B58;&#x6A21;&#x578B;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#java内存模型"><span class="toc-nav-number">7.1.</span> <span class="toc-nav-text">Java&#x5185;&#x5B58;&#x6A21;&#x578B;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#原子性atomicity"><span class="toc-nav-number">7.1.1.</span> <span class="toc-nav-text">&#x539F;&#x5B50;&#x6027;&#xFF08;Atomicity&#xFF09;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#可见性visibility"><span class="toc-nav-number">7.1.2.</span> <span class="toc-nav-text">&#x53EF;&#x89C1;&#x6027;&#xFF08;visibility&#xFF09;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#有序性ordering"><span class="toc-nav-number">7.1.3.</span> <span class="toc-nav-text">&#x6709;&#x5E8F;&#x6027;&#xFF08;Ordering&#xFF09;</span></a></li></ol></li></ol></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">标签</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#java" title="java">java</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
				<!--
                
                <hr>
                <h5>朋友们</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://tyzhang.top/" target="_blank">ztygalaxy</a></li>
                    
                        <li><a href="http://www.tangyincheng.com/" target="_blank">yctang</a></li>
                    
                        <li><a href="https://dolnw.github.io" target="_blank">JCWang</a></li>
                    
                </ul>
                
				-->
            </div>
        </div>
    </div>
</article>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: ''
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


<!-- chrome Firefox 中文锚点定位失效-->
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<!-- smooth scroll behavior polyfill  -->
<script type="text/javascript" src="/js/smoothscroll.js"></script>
<script>
        $('#toc').on('click','a',function(a){
            // var isChrome = window.navigator.userAgent.indexOf("Chrome") !== -1;
            // console.log(window.navigator.userAgent,isChrome)
                // if(isChrome) {
                    // console.log(a.currentTarget.outerHTML);
                    // console.log($(a.currentTarget).attr("href"));
                    //跳转到指定锚点
                    // document.getElementById(a.target.innerText.toLowerCase()).scrollIntoView(true);
                    document.getElementById($(a.currentTarget).attr("href").replace("#","")).scrollIntoView({behavior: 'smooth' });
                // }
        })  
</script>


    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                
				
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/songzblink">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 宋正兵 2022 
                    <br>
                    Theme by <a href="http://www.huweihuang.com">Huwei Huang</a>
                    re-Ported by <a href="https://github.com/ztygalaxy">ztygalaxy</a>
					
					<br>
                    <a href="http://www.beian.miit.gov.cn/" style="color: gray">浙ICP备2021018896号</a>
					<br>
					<!-- <p class="copyright text-muted" style="margin-top: 5px"> -->
						<img src="../../img/备案图标.png"/>
						<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null" style="color: gray">null</a>
					<!-- </p> -->
					
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("zbsong.top/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="zbsong.top/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>

</html>
